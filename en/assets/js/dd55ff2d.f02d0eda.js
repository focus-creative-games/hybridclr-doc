"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9178],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>y});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),c=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return r.createElement(s.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,l=e.originalType,s=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),d=c(t),m=a,y=d["".concat(s,".").concat(m)]||d[m]||p[m]||l;return t?r.createElement(y,i(i({ref:n},u),{},{components:t})):r.createElement(y,i({ref:n},u))}));function y(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,i=new Array(l);i[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[d]="string"==typeof e?e:a,i[1]=o;for(var c=2;c<l;c++)i[c]=t[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},75144:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var r=t(87462),a=(t(67294),t(3905));const l={},i="Quick Start",o={unversionedId:"business/reload/quickstart",id:"business/reload/quickstart",title:"Quick Start",description:"Almost identical to the community version's Quick Start, this document only introduces the differences.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/business/reload/quickstart.md",sourceDirName:"business/reload",slug:"/business/reload/quickstart",permalink:"/en/docs/business/reload/quickstart",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/en/docs/business/reload/intro"},next:{title:"Manual",permalink:"/en/docs/business/reload/manual"}},s={},c=[{value:"Installation",id:"installation",level:2},{value:"Usage in Code",id:"usage-in-code",level:2},{value:"TryUnloadAssembly",id:"tryunloadassembly",level:3},{value:"ForceUnloadAssembly",id:"forceunloadassembly",level:3},{value:"Precautions",id:"precautions",level:2}],u={toc:c},d="wrapper";function p(e){let{components:n,...l}=e;return(0,a.kt)(d,(0,r.Z)({},u,l,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"quick-start"},"Quick Start"),(0,a.kt)("p",null,"Almost identical to the community version's ",(0,a.kt)("a",{parentName:"p",href:"/en/docs/beginner/quickstart"},"Quick Start"),", this document only introduces the differences."),(0,a.kt)("h2",{id:"installation"},"Installation"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Extract hybridclr_unity and place it in the project Packages directory, rename it to com.code-philosophy.hybridclr"),(0,a.kt)("li",{parentName:"ul"},"Extract the corresponding ",(0,a.kt)("inlineCode",{parentName:"li"},"il2cpp_plus-{version}.zip")," according to your Unity version"),(0,a.kt)("li",{parentName:"ul"},"Extract ",(0,a.kt)("inlineCode",{parentName:"li"},"hybridclr.zip")),(0,a.kt)("li",{parentName:"ul"},"Place the hybridclr directory from the extracted ",(0,a.kt)("inlineCode",{parentName:"li"},"hybridclr.zip")," into the libil2cpp directory from the extracted ",(0,a.kt)("inlineCode",{parentName:"li"},"il2cpp-{version}.zip")),(0,a.kt)("li",{parentName:"ul"},"Open ",(0,a.kt)("inlineCode",{parentName:"li"},"HybridCLR/Installer"),", enable the ",(0,a.kt)("inlineCode",{parentName:"li"},"Copy libil2cpp from local")," option, select the libil2cpp directory you just extracted, and perform the installation")),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"installer",src:t(69456).Z,width:"802",height:"563"})),(0,a.kt)("h2",{id:"usage-in-code"},"Usage in Code"),(0,a.kt)("p",null,"Call ",(0,a.kt)("inlineCode",{parentName:"p"},"RuntimeApi.TryUnloadAssembly")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"RuntimeApi.ForceUnloadAssembly")," to unload assemblies, use ",(0,a.kt)("inlineCode",{parentName:"p"},"Assembly.Load")," to reload assemblies. You must successfully unload an assembly before you can load it again."),(0,a.kt)("p",null,"Currently there are two unloading workflows:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"TryUnloadAssembly"),(0,a.kt)("li",{parentName:"ul"},"ForceUnloadAssembly")),(0,a.kt)("h3",{id:"tryunloadassembly"},"TryUnloadAssembly"),(0,a.kt)("p",null,"Attempts to unload. If there are references to objects in the unloaded assembly in the AppDomain, it maintains the current state and returns failure; otherwise returns success."),(0,a.kt)("p",null,"Example code as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'\n    // First load\n    Assembly ass = Assembly.Load(yyy);\n\n    // Execute some code\n    Type mainType = ass.GetType("Entry");\n    mainType.GetMethod("Main").Invoke(null, null);\n\n    // First unload\n    // printObjectReferenceLink=true will maintain object reference relationships, causing unloading to be time-consuming.\n    // First try unloading with printObjectReferenceLink=false, if it fails set printObjectReferenceLink=true,\n    // try unloading again and print illegal reference logs\n    var report = RuntimeApi.TryUnloadAssembly(ass, false);\n    if (!report.success)\n    {\n        report = RuntimeApi.TryUnloadAssembly(ass, true);\n        foreach (string log in report.invalidObjectReferenceLinkLogs)\n        {\n            Debug.LogError(log);\n        }\n        throw new Exception("unload fail");\n    }\n\n    // Second load\n    Assembly newAss = Assembly.Load(yyy);\n\n    // Execute some code\n    mainType = ass.GetType("Entry");\n    mainType.GetMethod("Main").Invoke(null, null);\n\n    // Second unload\n    report = RuntimeApi.TryUnloadAssembly(ass, false);\n    if (!report.success)\n    {\n        report = RuntimeApi.TryUnloadAssembly(ass, true);\n        foreach (string log in report.invalidObjectReferenceLinkLogs)\n        {\n            Debug.LogError(log);\n        }\n        throw new Exception("unload fail");\n    }\n')),(0,a.kt)("h3",{id:"forceunloadassembly"},"ForceUnloadAssembly"),(0,a.kt)("p",null,"Force unload, even if there are references to objects in the unloaded assembly in the AppDomain. Returns true if there are no problems, returns false if illegal references are detected during unloading. If it returns false, it ",(0,a.kt)("strong",{parentName:"p"},"may")," crash after running for a while. Use this operation with caution, it's recommended to communicate in detail with official technical support."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'\n    // First load\n    Assembly ass = Assembly.Load(yyy);\n\n    // Execute some code\n    Type mainType = ass.GetType("Entry");\n    mainType.GetMethod("Main").Invoke(null, null);\n\n    // First unload\n    // ignoreObjectReferenceValidation parameter as true means not checking illegal object references during unloading, which can shorten unloading time. But it\'s recommended to set to false both during development and production release\n    // printObjectReferenceLink parameter as true means when unloading fails, detailed illegal object reference chain logs will be printed to help developers locate where illegal references are maintained. It\'s recommended to be true only during development, change to false after production release\n    var report = RuntimeApi.ForceUnloadAssembly(ass, false, true);\n    if (!report.success)\n    {\n        foreach (string log in report.invalidObjectReferenceLinkLogs)\n        {\n            Debug.LogError(log);\n        }\n        throw new Exception("unload fail");\n    }\n\n    // Second load\n    Assembly newAss = Assembly.Load(yyy);\n\n    // Execute some code\n    mainType = ass.GetType("Entry");\n    mainType.GetMethod("Main").Invoke(null, null);\n\n    // Second unload\n    report = RuntimeApi.ForceUnloadAssembly(ass, false, true);\n    if (!report.success)\n    {\n        foreach (string log in report.invalidObjectReferenceLinkLogs)\n        {\n            Debug.LogError(log);\n        }\n        throw new Exception("unload fail");\n    }\n')),(0,a.kt)("h2",{id:"precautions"},"Precautions"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Async or coroutines can easily implicitly maintain references to unloaded assembly code in other threads. Be sure to clear all async or coroutine functions before unloading"),(0,a.kt)("li",{parentName:"ul"},"UI OnClick or various callback events can easily cause maintaining references to unloaded assemblies, must be cleaned thoroughly"),(0,a.kt)("li",{parentName:"ul"},"Events registered globally or other callbacks can easily accidentally maintain references to unloaded assemblies, must be cleaned thoroughly"),(0,a.kt)("li",{parentName:"ul"},"According to the illegal reference logs printed during unloading, clean up illegal references in the code\n\0\n\0")))}p.isMDXComponent=!0},69456:(e,n,t)=>{t.d(n,{Z:()=>r});const r=t.p+"assets/images/ultimate-installer-2ca1e4616b01f9e02b2de3384a53f585.jpg"}}]);