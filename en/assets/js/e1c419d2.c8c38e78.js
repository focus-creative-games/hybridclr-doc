"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4340],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>g});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var d=r.createContext({}),p=function(e){var t=r.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(d.Provider,{value:t},e.children)},s="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,d=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),s=p(n),m=a,g=s["".concat(d,".").concat(m)]||s[m]||c[m]||i;return n?r.createElement(g,l(l({ref:t},u),{},{components:n})):r.createElement(g,l({ref:t},u))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=m;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o[s]="string"==typeof e?e:a,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},89834:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var r=n(87462),a=(n(67294),n(3905));const i={},l="Bridge Functions",o={unversionedId:"basic/methodbridge",id:"basic/methodbridge",title:"Bridge Functions",description:"HybridCLR's interpreter needs bidirectional function calls with AOT. For example, interpreter calling AOT functions, or AOT calling back to interpreter through interface or delegate callbacks.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/basic/methodbridge.md",sourceDirName:"basic",slug:"/basic/methodbridge",permalink:"/en/docs/basic/methodbridge",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"AOT Generics",permalink:"/en/docs/basic/aotgeneric"},next:{title:"DOTS Support",permalink:"/en/docs/basic/dots"}},d={},p=[{value:"Bridge Function Signatures",id:"bridge-function-signatures",level:2},{value:"Generating Bridge Functions",id:"generating-bridge-functions",level:2},{value:"Platform-Related",id:"platform-related",level:2}],u={toc:p},s="wrapper";function c(e){let{components:t,...n}=e;return(0,a.kt)(s,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"bridge-functions"},"Bridge Functions"),(0,a.kt)("p",null,"HybridCLR's interpreter needs bidirectional function calls with AOT. For example, interpreter calling AOT functions, or AOT calling back to interpreter through interface or delegate callbacks."),(0,a.kt)("p",null,"The parameter passing and storage methods between the AOT part and interpreter part are different. When the interpreter calls AOT functions, all interpreter parameters are on the interpreter stack, and appropriate methods must be used to pass interpreter function parameters to AOT functions. Similarly, the interpreter cannot directly obtain parameters from AOT callback functions. Bridge functions must be generated for each function signature to enable bidirectional function parameter passing between interpreter and AOT parts. For ",(0,a.kt)("inlineCode",{parentName:"p"},"interpreter -> AOT")," direction calls, although they can be completed through libraries like ffi, the function call cost is too high. The most reasonable approach is still to pre-generate these bidirectional bridge functions. Internal interpreter calls go directly through the interpreter stack and don't need bridge functions."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"According to the principle of bridge functions, for a fixed AOT part, the set of bridge functions is determined. No matter what hot updates are performed subsequently, no new additional bridge functions will be needed. ",(0,a.kt)("strong",{parentName:"p"},"Therefore, you don't need to worry about suddenly missing bridge functions after hot updates go live."))),(0,a.kt)("h2",{id:"bridge-function-signatures"},"Bridge Function Signatures"),(0,a.kt)("p",null,"Bridge functions must be generated in advance in the AOT part, which is similar to the principle of lua wrapper functions."),(0,a.kt)("p",null,"To find the corresponding bridge function for each ",(0,a.kt)("inlineCode",{parentName:"p"},"AOT <-> interpreter")," function call, there must be a way to calculate function signatures. Additionally, functions with completely equivalent parameter types and return value types can share the same bridge function, which greatly reduces the number of bridge functions. In the following example, class types share the same signature. Therefore, they can all share a bridge function with signature ",(0,a.kt)("inlineCode",{parentName:"p"},"object (object, long)"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"object Fun1(object a, long b);\nstring Fun2(string a, long b);\n")),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Type"),(0,a.kt)("th",{parentName:"tr",align:null},"Signature"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"sbyte"),(0,a.kt)("td",{parentName:"tr",align:null},"i1")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"byte"),(0,a.kt)("td",{parentName:"tr",align:null},"u1")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"bool"),(0,a.kt)("td",{parentName:"tr",align:null},"u1")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"char"),(0,a.kt)("td",{parentName:"tr",align:null},"u2")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"short"),(0,a.kt)("td",{parentName:"tr",align:null},"i2")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"ushort"),(0,a.kt)("td",{parentName:"tr",align:null},"u2")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"int"),(0,a.kt)("td",{parentName:"tr",align:null},"i4")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"uint"),(0,a.kt)("td",{parentName:"tr",align:null},"u4")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"long"),(0,a.kt)("td",{parentName:"tr",align:null},"i8")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"ulong"),(0,a.kt)("td",{parentName:"tr",align:null},"u8")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"IntPtr"),(0,a.kt)("td",{parentName:"tr",align:null},"i")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"UintPtr"),(0,a.kt)("td",{parentName:"tr",align:null},"u")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"float"),(0,a.kt)("td",{parentName:"tr",align:null},"r4")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"double"),(0,a.kt)("td",{parentName:"tr",align:null},"r8")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"class types"),(0,a.kt)("td",{parentName:"tr",align:null},"u")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"pointer types"),(0,a.kt)("td",{parentName:"tr",align:null},"u")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"enum types"),(0,a.kt)("td",{parentName:"tr",align:null},"signature corresponding to underlying type, e.g., ",(0,a.kt)("inlineCode",{parentName:"td"},"enum Color:short {}")," has signature i2")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"TypedReference"),(0,a.kt)("td",{parentName:"tr",align:null},"typedbyref")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"struct"),(0,a.kt)("td",{parentName:"tr",align:null},"globally unique struct signature, like ",(0,a.kt)("inlineCode",{parentName:"td"},"s{sequence number}"))))),(0,a.kt)("h2",{id:"generating-bridge-functions"},"Generating Bridge Functions"),(0,a.kt)("p",null,"The com.code-philosophy.hybridclr package provides tool scripts. It's recommended to use the menu command ",(0,a.kt)("inlineCode",{parentName:"p"},"HybridCLR/Generate/All")," to automatically generate all bridge functions. You can also directly use ",(0,a.kt)("inlineCode",{parentName:"p"},"HybridCLR/Generate/MethodBridge"),"\nto generate bridge functions, but this command depends on ",(0,a.kt)("inlineCode",{parentName:"p"},"stripped AOT dlls")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"hot update dlls"),", while ",(0,a.kt)("inlineCode",{parentName:"p"},"stripped AOT dlls")," depend on ",(0,a.kt)("inlineCode",{parentName:"p"},"generating LinkXml")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"generating Il2CppDef"),". Therefore, if you haven't used the ",(0,a.kt)("inlineCode",{parentName:"p"},"HybridCLR/Generate/All")," command, you must run them in sequence:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"HybridCLR/Generate/Il2CppDef")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"HybridCLR/Generate/LinkXml")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"HybridCLR/CompileDll/ActiveBuildTarget")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"HybridCLR/Generate/AotDlls")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"HybridCLR/Generate/MethodBridge"))),(0,a.kt)("h2",{id:"platform-related"},"Platform-Related"),(0,a.kt)("p",null,"Bridge functions themselves are platform-independent. For the same dll, the bridge function files generated for all platforms are completely identical. However, due to different compilation macro switches and different base libraries (like mscorlib) on each platform, the bridge functions generated for different platforms are also different. Therefore, ",(0,a.kt)("strong",{parentName:"p"},"do not reuse")," bridge functions,\nbut generate them separately for each platform."))}c.isMDXComponent=!0}}]);