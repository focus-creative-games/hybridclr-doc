"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[439],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=i,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||o;return n?a.createElement(h,r(r({ref:t},p),{},{components:n})):a.createElement(h,r({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:i,r[1]=l;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},481:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const o={},r="AOT generic problem",l={unversionedId:"basic/aotgeneric",id:"basic/aotgeneric",title:"AOT generic problem",description:"There are two types of generic features in the CLR: generic types and generic functions. Generics are an extremely widely used feature in C#. Even a usage that does not explicitly contain generics may imply generic-related definitions or operations.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/basic/aotgeneric.md",sourceDirName:"basic",slug:"/basic/aotgeneric",permalink:"/en/docs/basic/aotgeneric",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Use MonoBehaviour",permalink:"/en/docs/basic/monobehaviour"},next:{title:"AOT-interpreter bridge function",permalink:"/en/docs/basic/methodbridge"}},s={},c=[{value:"Generic sharing mechanism of il2cpp",id:"generic-sharing-mechanism-of-il2cpp",level:2},{value:"Shared type calculation rules",id:"shared-type-calculation-rules",level:2},{value:"Non-enumeration value types",id:"non-enumeration-value-types",level:3},{value:"Enum Type",id:"enum-type",level:3},{value:"class reference type",id:"class-reference-type",level:3},{value:"Generic Types",id:"generic-types",level:3},{value:"Shared generic function evaluation rules for generic functions",id:"shared-generic-function-evaluation-rules-for-generic-functions",level:3},{value:"The reason why the value type in il2cpp does not support generic sharing",id:"the-reason-why-the-value-type-in-il2cpp-does-not-support-generic-sharing",level:2},{value:"Problems caused by memory alignment",id:"problems-caused-by-memory-alignment",level:3},{value:"ABI issues",id:"abi-issues",level:3},{value:"Defects of the generic sharing mechanism",id:"defects-of-the-generic-sharing-mechanism",level:2},{value:"Generic function instantiation technology based on supplementary metadata (HybridCLR&#39;s patented technology)",id:"generic-function-instantiation-technology-based-on-supplementary-metadata-hybridclrs-patented-technology",level:2},{value:"Get Supplementary Metadata dll",id:"get-supplementary-metadata-dll",level:3},{value:"should make up",id:"should-make-up",level:3},{value:"Metadata Mode HomologousImageMode",id:"metadata-mode-homologousimagemode",level:3},{value:"Load supplementary metadata sample code",id:"load-supplementary-metadata-sample-code",level:3},{value:"AOT generic problems caused by some C# special mechanisms",id:"aot-generic-problems-caused-by-some-c-special-mechanisms",level:2},{value:"<code>full generic sharing</code> technical supplementary introduction",id:"full-generic-sharing-technical-supplementary-introduction",level:2},{value:"Appendix: Example of shared generic instantiation of AOT generics",id:"appendix-example-of-shared-generic-instantiation-of-aot-generics",level:2},{value:"Example 1",id:"example-1",level:3},{value:"Example 2",id:"example-2",level:3},{value:"Example 3",id:"example-3",level:3}],p={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"aot-generic-problem"},"AOT generic problem"),(0,i.kt)("p",null,"There are two types of generic features in the CLR: generic types and generic functions. Generics are an extremely widely used feature in C#. Even a usage that does not explicitly contain generics may imply generic-related definitions or operations."),(0,i.kt)("p",null,"For the generic class defined in ",(0,i.kt)("strong",{parentName:"p"},"hot update code, you can use it freely without restrictions, but for "),"AOT generics**, you have encountered some problems."),(0,i.kt)("p",null,"il2cpp is an AOT runtime, and almost all (why not all?) types used in its runtime are statically determined at compile time. You have only instantiated ",(0,i.kt)("inlineCode",{parentName:"p"},"List<int>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"List<string>")," in AOT, you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"new List<int>()")," in hot update code\n, but cannot use ",(0,i.kt)("inlineCode",{parentName:"p"},"new List<float>()"),". Because although il2cpp can create most of the metadata of the ",(0,i.kt)("inlineCode",{parentName:"p"},"List<float>")," type in memory, it cannot create its member function implementations.\nFor example, you can get ",(0,i.kt)("inlineCode",{parentName:"p"},"typeof(List<float>)")," through reflection, but you cannot call any of its member functions, including constructors."),(0,i.kt)("p",null,"Generic classes, especially generic containers such as List and Dictionary are widely used in code. If ",(0,i.kt)("inlineCode",{parentName:"p"},"List<HotUpdateType>")," cannot run due to AOT restrictions, then the code restriction for game hot update is also too large up. Fortunately, HybridCLR solves this problem completely using two types of techniques:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Generic sharing")," technology based on il2cpp"),(0,i.kt)("li",{parentName:"ul"},"Based on ",(0,i.kt)("inlineCode",{parentName:"li"},"Supplementary Metadata")," technology, which is also HybridCLR's patented technology")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Since the il2cpp generic sharing technology has great limitations, it is strongly recommended to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"supplementary metadata")," technology to solve the generic problem.")),(0,i.kt)("h2",{id:"generic-sharing-mechanism-of-il2cpp"},"Generic sharing mechanism of il2cpp"),(0,i.kt)("p",null,"In order to avoid generic code expansion and save memory, il2cpp generates only one code for some codes that can be shared while ensuring the correctness of code logic. To introduce a concept called ",(0,i.kt)("strong",{parentName:"p"},"generic code sharing")," ",(0,i.kt)("a",{parentName:"p",href:"https://blog.unity.com/technology/il2cpp-internals-generic-sharing-implementation"},"Generic Sharing"),".\nGeneric function implementations whose generic parameters are of class type can be shared. For example, the code compiled for the List","<","String",">"," method can be directly used for the List","<","Stream",">"," method, but the generic parameter of the value type cannot be shared."),(0,i.kt)("p",null,"  Take List","<","T",">"," as an example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"You can use any instantiation type of List used in AOT. For example, if you have used List","<","vector3",">"," in AOT, you can also use it in hot update"),(0,i.kt)("li",{parentName:"ul"},"Any List","<","HotUpdateEnum",">"," can be used. You only need to instantiate a certain List","<","enumeration type of the same underlying type",">"," in AOT."),(0,i.kt)("li",{parentName:"ul"},"The generic parameter List","<","HotUpdateClass",">"," of any reference type can be used. You only need to instantiate List","<","object",">"," (or any reference generic parameter such as List","<","string",">",") in AOT")),(0,i.kt)("h2",{id:"shared-type-calculation-rules"},"Shared type calculation rules"),(0,i.kt)("p",null,"Assuming that the shared type of the generic class T is sharing type, the calculation rules are as follows."),(0,i.kt)("h3",{id:"non-enumeration-value-types"},"Non-enumeration value types"),(0,i.kt)("p",null,"The sharing type is itself. For example, the sharing type of int is int"),(0,i.kt)("h3",{id:"enum-type"},"Enum Type"),(0,i.kt)("p",null,"The sharing type is an enumeration whose underlying type is the same as it. For example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"enum MyEnumA\n{\n     A = 1,\n}\nenum MyEnumB\n{\n     A = 10,\n}\n\nenum MyEnumC : short\n{\n     A = 1,\n}\n\nenum MyEnumD : short\n{\n     A = 1,\n}\n\n")),(0,i.kt)("p",null,"MyEnumA and MyEnumB sharing the same type, and MyEnumC and MyEnumD sharing the same type."),(0,i.kt)("h3",{id:"class-reference-type"},"class reference type"),(0,i.kt)("p",null,"sharing type is object"),(0,i.kt)("h3",{id:"generic-types"},"Generic Types"),(0,i.kt)("p",null,"For ",(0,i.kt)("inlineCode",{parentName:"p"},"GenericType<T1, T2, ...>"),", if the GenericType is a class type, then the sharing type is object, otherwise the sharing type is ",(0,i.kt)("inlineCode",{parentName:"p"},"GenericType<shareType<T1>, shareType<T2>, ...>"),". For example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The sharing type of ",(0,i.kt)("inlineCode",{parentName:"li"},"Dictionary<int, string>")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"object")),(0,i.kt)("li",{parentName:"ul"},"The sharing type of ",(0,i.kt)("inlineCode",{parentName:"li"},"ValueTuple<int, string>")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"ValueTuple<int, object>"))),(0,i.kt)("h3",{id:"shared-generic-function-evaluation-rules-for-generic-functions"},"Shared generic function evaluation rules for generic functions"),(0,i.kt)("p",null,"The AOT generic function of ",(0,i.kt)("inlineCode",{parentName:"p"},"Class<C1, C2, ...>.Method<M1, M2, ...>(A1, A2, ...)")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"Class<sharing(C1), sharing(C2) , ...>.Method<sharing(M1), sharing(M2), ...>(sharing(A1), sharing(A2), ...)"),". For example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Shared function of ",(0,i.kt)("inlineCode",{parentName:"li"},"List<string>.ctor")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"List<object>.ctor")),(0,i.kt)("li",{parentName:"ul"},"The shared function of ",(0,i.kt)("inlineCode",{parentName:"li"},"List<int>.Add(int)")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"List<int>.Add(int)")),(0,i.kt)("li",{parentName:"ul"},"The shared function of ",(0,i.kt)("inlineCode",{parentName:"li"},"YourGenericClass<string, int, List<int>>.Show<string, List<int>, int>(ValueTuple<int, string>, string, int)")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"YourGenericClass<object, int, object >.Show<object, object, int>(ValueTuple<int, object>, object, int)"))),(0,i.kt)("h2",{id:"the-reason-why-the-value-type-in-il2cpp-does-not-support-generic-sharing"},"The reason why the value type in il2cpp does not support generic sharing"),(0,i.kt)("p",null,"It is easy to understand that value types of different sizes cannot be shared, but why can't value types of the same size be shared generically like a class? There are two main reasons."),(0,i.kt)("h3",{id:"problems-caused-by-memory-alignment"},"Problems caused by memory alignment"),(0,i.kt)("p",null,"Even if the value types have the same size, if the alignment is different, when they are used as subfields of other classes, the memory size and layout of the final class may be different."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"struct A // size = 4, alignment = 2\n{\n     short x;\n     short y;\n};\n\nstruct B // size = 4, alignment = 4\n{\n     int x;\n};\n\nstruct GenericDemo<T>\n{\n     short x;\n     T v;\n\n     public T GetValue() => v;\n};\n\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"GenericDemo<A>")," size=6, alignment=2, field v is offset by 2 in the class; and ",(0,i.kt)("inlineCode",{parentName:"p"},"GenericDemo<B>")," size=8, alignment=4, field v is offset by 4 in the class. Obviously, for the GetValue function, due to the different offsets of v, it is impossible to use the same set of c++ codes to work correctly for these two classes."),(0,i.kt)("h3",{id:"abi-issues"},"ABI issues"),(0,i.kt)("p",null,"Structures of the same size and alignment are equivalent in ",(0,i.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/zh-cn/cpp/build/x64-software-conventions?redirectedfrom=MSDN&view=msvc-170"},"x64 ABI")," , you can use structures of the same size for shared generic instantiation. But it doesn't work in ",(0,i.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/zh-cn/cpp/build/arm64-windows-abi-conventions?view=msvc-170"},"arm64 ABI"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"struct IntVec3 { int32_t x, y, z; }")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"struct FloatVec3 { float x, y, z}")," are both 12 in size, but when they are passed as function parameters, the way of passing parameters is different:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"IntVec3 is passed by reference"),(0,i.kt)("li",{parentName:"ul"},"The three fields of FloatVec3 are placed in three floating-point registers respectively")),(0,i.kt)("p",null,"This is another key reason why structs cannot be shared generically."),(0,i.kt)("h2",{id:"defects-of-the-generic-sharing-mechanism"},"Defects of the generic sharing mechanism"),(0,i.kt)("p",null,"Since value types cannot be shared generically, if a value type appears in the generic parameter of a generic instance (class or function), this generic instance must be instantiated in advance in AOT. if\nYour generic parameter type is the value type defined in the hot update code. Since the hot update type is obviously impossible to instantiate generics in AOT in advance, you are hot updating the code\nCodes such as ",(0,i.kt)("inlineCode",{parentName:"p"},"List<hot update value type>")," cannot be used in , which brings great inconvenience to development."),(0,i.kt)("p",null,"Fortunately, we innovatively proposed the patented technology of ",(0,i.kt)("inlineCode",{parentName:"p"},"Supplementary Metadata"),", which completely solved this problem."),(0,i.kt)("h2",{id:"generic-function-instantiation-technology-based-on-supplementary-metadata-hybridclrs-patented-technology"},"Generic function instantiation technology based on supplementary metadata (HybridCLR's patented technology)"),(0,i.kt)("p",null,"All metadata except functions in AOT generic metadata can be instantiated in memory through the Inflate technology, but functions cannot be instantiated. The problem that AOT generic functions cannot be instantiated is essentially because il2cpp loses the original function body IL metadata during the translation of ",(0,i.kt)("inlineCode",{parentName:"p"},"IL -> C++"),".\nTake the ",(0,i.kt)("inlineCode",{parentName:"p"},"List<T>.Add")," function as an example, if there is no original IL function information, the correct ",(0,i.kt)("inlineCode",{parentName:"p"},"List<long The implementation of >.Add"),". Our solution is very ingenious - to supplement the lost metadata of the original generic function body."),(0,i.kt)("p",null,"Use the ",(0,i.kt)("inlineCode",{parentName:"p"},"HybridCLR.RuntimeApi.LoadMetadataForAOTAssembly")," function in the com.code-philosophy.hybridclr package to supplement the corresponding metadata for the AOT assembly.\nThe LoadMetadataForAOTAssembly function can be called at any time. In addition, it can be called in AOT or hot update. You just need to call it before using AOT generics (only need to call it once).\nIn theory, the earlier the loading, the better. In practice, the more reasonable time is after the hot update is completed, or after the hot update dll is loaded but before any code is executed. If the dll that supplements the metadata is also entered into the main package as an additional data file (for example, put it under StreamingAssets), it will be better loaded when the main project starts."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Supplementary metadata has no load order requirement"),"."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"It is the generic function that loses the IL function body metadata, not the generic parameter type that loses metadata. Take ",(0,i.kt)("inlineCode",{parentName:"p"},"List<YourValueType>.Add")," as an example,\nIt is the ",(0,i.kt)("inlineCode",{parentName:"p"},"List<T>.Add")," function that is missing raw IL function body metadata, not ",(0,i.kt)("inlineCode",{parentName:"p"},"YourValueType")," that is missing metadata, so\nThe metadata of the aot dll where the generic class resides should be supplemented. For example, in order to use ",(0,i.kt)("inlineCode",{parentName:"p"},"List<Vector3>"),", you should supplement the metadata of the dll where ",(0,i.kt)("inlineCode",{parentName:"p"},"List<T>")," resides (namely ",(0,i.kt)("inlineCode",{parentName:"p"},"mscorlib"),"), instead of supplementing the metadata of the dll where ",(0,i.kt)("inlineCode",{parentName:"p"},"YourValueType")," resides.")),(0,i.kt)("p",null,"If the AOT generic supplements the corresponding generic metadata, and il2cpp generic sharing instantiation also exists, in order to maximize performance, HybridCLR will give priority to il2cpp generic sharing."),(0,i.kt)("p",null,"Although the generic function instantiation technology based on supplementary metadata is quite perfect, after all, the instantiated function is executed in an interpreted manner. If the generic instantiation in AOT can be performed in advance, the performance can be greatly improved.\nTherefore, generic classes and functions that are commonly used, especially performance-sensitive, can be instantiated in AOT in advance. We provide tools to help automatically scan and collect corresponding generic instances, you can run the menu command ",(0,i.kt)("inlineCode",{parentName:"p"},"HybridCLR/Generate/AOTGenericReference"),"."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"This command only collects the AOT generic instances used in the hot update, and all generated are in the form of annotations. You need to refer to this file yourself and explicitly instantiate some generics in other places according to actual needs.")),(0,i.kt)("h3",{id:"get-supplementary-metadata-dll"},"Get Supplementary Metadata dll"),(0,i.kt)("p",null,"The clipped AOT dll generated by ",(0,i.kt)("strong",{parentName:"p"},"building pipeline")," can be used to supplement metadata. The com.code-philosophy.hybridclr plugin will automatically copy them to ",(0,i.kt)("inlineCode",{parentName:"p"},"{project}/HybridCLRData/AssembliesPostIl2CppStrip/{target}"),". Note that tailoring AOT dlls of different BuildTargets cannot be reused."),(0,i.kt)("p",null,"Using the ",(0,i.kt)("inlineCode",{parentName:"p"},"HybridCLR/Generate/AotDlls")," command can also generate the trimmed AOT dll immediately, it works by exporting a Temp project to get the trimmed AOT dll."),(0,i.kt)("h3",{id:"should-make-up"},"should make up"),(0,i.kt)("p",null,"A list of assemblies filled with metadata"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"AOTGenericReferences.cs")," file generated by the ",(0,i.kt)("inlineCode",{parentName:"p"},"HybridCLR/generate/AOTGenericReference")," command contains a list of assemblies that should be supplemented with metadata, like this. You don't need to run the game to quickly know which metadata should be added."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"// {{ AOT assemblies\n// Main.dll\n// System. Core. dll\n// UnityEngine.CoreModule.dll\n// mscorlib.dll\n// }}\n")),(0,i.kt)("h3",{id:"metadata-mode-homologousimagemode"},"Metadata Mode HomologousImageMode"),(0,i.kt)("p",null,"Two metadata schemas are currently supported:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"HomologousImageMode::Consistent")," mode, that is, the supplementary dll is exactly the same as the cropped dll when packaging. Therefore, the clipped dll generated during the build process must be used, and the original dll cannot be copied directly."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"HomologousImageMode::SuperSet")," mode, that is, the supplementary dll is a superset of the cropped dll when packaging. This mode relaxes the requirements for AOT dll, you can use either the cut AOT dll or the original AOT dll.")),(0,i.kt)("h3",{id:"load-supplementary-metadata-sample-code"},"Load supplementary metadata sample code"),(0,i.kt)("p",null,"See the sample code below for how to load the supplementary metadata dll in the code, and you can also refer to ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/focus-creative-games/hybridclr_trial"},"hybridclr_trial"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'     public static unsafe void LoadMetadataForAOTAssembly()\n     {\n         List<string> aotDllList = new List<string>\n         {\n             "mscorlib.dll",\n             "System.dll",\n             "System.Core.dll", // required if using Linq\n             // "Newtonsoft.Json.dll",\n             // "protobuf-net.dll",\n         };\n\n         AssetBundle dllAB = LoadDll. AssemblyAssetBundle;\n         foreach (var aotDllName in aotDllList)\n         {\n             byte[] dllBytes = dllAB.LoadAsset<TextAsset>(aotDllName).bytes;\n               int err = HybridCLR.RuntimeApi.LoadMetadataForAOTAssembly(dllBytes, HomologousImageMode.SuperSet);\n               Debug.Log($"LoadMetadataForAOTAssembly:{aotDllName}.ret:{err}");\n         }\n     }\n')),(0,i.kt)("h2",{id:"aot-generic-problems-caused-by-some-c-special-mechanisms"},"AOT generic problems caused by some C# special mechanisms"),(0,i.kt)("p",null,"The compiler may generate implicit AOT generic references for complex syntactic sugar such as async. Therefore, in order for these mechanisms to work properly, the AOT generic instantiation problems caused by them must also be resolved."),(0,i.kt)("p",null,"Taking async as an example, the compiler generates several classes, state machines and some codes for async. These hidden generated codes contain calls to multiple AOT generic functions. The common ones are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"void AsyncTaskMethodBuilder::Start<TStateMachine>(ref TStateMachine stateMachine)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"void AsyncTaskMethodBuilder::AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"void AsyncTaskMethodBuilder::SetException(Exception exception)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"void AsyncTaskMethodBuilder::SetResult()")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"void AsyncTaskMethodBuilder<T>::Start<TStateMachine>(ref TStateMachine stateMachine)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"void AsyncTaskMethodBuilder<T>::AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"void AsyncTaskMethodBuilder<T>::SetException(Exception exception)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"void AsyncTaskMethodBuilder<T>::SetResult(T result)"))),(0,i.kt)("p",null,"Both generic instantiation techniques can solve these problems. You can use the generic sharing mechanism, that is, instantiate these functions in advance in AOT, but ",(0,i.kt)("strong",{parentName:"p"},"Note"),", the state machine generated by Unity in the dll compiled in release mode is of the ValueType type, which makes it impossible to sharing generics, but The state machine generated in debug mode is of class type and can be shared generically. Therefore, if you use the il2cpp generic sharing mechanism, in order to use the async syntax in the hot update, when using the script to compile the dll, you must add ",(0,i.kt)("inlineCode",{parentName:"p"},"scriptCompilationSettings.options = ScriptCompilationOptions.DevelopmentBuild;")," code, so that the compiled state machine is a class type, Works fine in hot update code. If ",(0,i.kt)("inlineCode",{parentName:"p"},"Supplementary Metadata Technology")," has been used, due to full support for AOT generics, there are ",(0,i.kt)("strong",{parentName:"p"},"unlimited")," compilation methods."),(0,i.kt)("p",null,"Instantiating these generics in AOT is tedious and ",(0,i.kt)("strong",{parentName:"p"},"strongly recommended")," to use the supplementary metadata mechanism."),(0,i.kt)("h2",{id:"full-generic-sharing-technical-supplementary-introduction"},(0,i.kt)("inlineCode",{parentName:"h2"},"full generic sharing")," technical supplementary introduction"),(0,i.kt)("p",null,"Since the 2021.3.x LTS version, il2cpp has fully supported the ",(0,i.kt)("inlineCode",{parentName:"p"},"full generic sharing' technology. When the "),"Il2Cpp Code Generation",(0,i.kt)("inlineCode",{parentName:"p"},"option in Build Settings is"),"faster runtime",(0,i.kt)("inlineCode",{parentName:"p"},", it is the generic sharing mechanism introduced in the previous chapter , enabled for "),"faster(smaller) build",(0,i.kt)("inlineCode",{parentName:"p"}),"full generic sharing",(0,i.kt)("inlineCode",{parentName:"p"},"mechanism. The"),"full generic sharing` technology can overcome the defect that the value type generics of traditional il2cpp cannot be shared. All generic instances of generic functions (regardless of whether the generic parameters are value types or class types) completely sharing one code."),(0,i.kt)("p",null,"The advantage of full generic sharing is that it can be instantiated arbitrarily, and it can save code size. The disadvantage is that it greatly hurts the performance of generic functions. The fully generic shared code is sometimes several to ten times slower than the standard generic shared code, and even worse than the purely interpreted version. Therefore it is strongly recommended to ",(0,i.kt)("strong",{parentName:"p"},"not enable")," the ",(0,i.kt)("inlineCode",{parentName:"p"},"faster(smaller) build")," option. Because of this, although HybridCLR can work with the ",(0,i.kt)("inlineCode",{parentName:"p"},"full generic sharing")," mechanism, it does not take advantage of this mechanism at all. Because this mechanism has basically no practical significance except when you want to reduce the inclusion extremely."),(0,i.kt)("h2",{id:"appendix-example-of-shared-generic-instantiation-of-aot-generics"},"Appendix: Example of shared generic instantiation of AOT generics"),(0,i.kt)("h3",{id:"example-1"},"Example 1"),(0,i.kt)("p",null,"error log"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"MissingMethodException: AOT generic method isn't instantiated in aot module\n   void System.Collections.Generic.List<System.String>.ctor()\n")),(0,i.kt)("p",null,"You add a call to ",(0,i.kt)("inlineCode",{parentName:"p"},"List<string>.ctor()")," in RefType, which is ",(0,i.kt)("inlineCode",{parentName:"p"},"new List<string>()"),". Thanks to the ",(0,i.kt)("strong",{parentName:"p"},"generic sharing mechanism"),", you just call ",(0,i.kt)("inlineCode",{parentName:"p"},"new List<object>()"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"class RefTypes\n{\n   public void MyAOTRefs()\n   {\n       new List<object>(); // can also use new List<string>()\n   }\n}\n")),(0,i.kt)("h3",{id:"example-2"},"Example 2"),(0,i.kt)("p",null,"error log"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"MissingMethodException: AOT generic method isn't instantiated in aot module\n     void System.ValueType<System.Int32, System.String>.ctor()\n")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The empty constructor of the value type does not call the corresponding constructor, but corresponds to the initobj instruction. In fact, you can't directly reference it, but you just need to force the instantiation of this type, and all functions of the preserve class will naturally include the .ctor function.")),(0,i.kt)("p",null,"In practice you can use forced boxing ",(0,i.kt)("inlineCode",{parentName:"p"},"(object)(default(ValueTuple<int, object>))"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"class RefTypes\n{\n   public void MyAOTRefs()\n   {\n       // The following two ways of writing are both possible\n       _ = (object)(new ValueTuple<int, object>());\n       _ = (object)(default(ValueTuple<int, object>));\n   }\n}\n")),(0,i.kt)("h3",{id:"example-3"},"Example 3"),(0,i.kt)("p",null,"error log"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"MissingMethodException: AOT generic method isn't instantiated in aot module\n   System.Void System.Runtime.CompilerService.AsyncVoidMethodBuilder::Start<UIMgr+ShowUId__2>(UIMgr+<ShowUI>d__2&)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"class RefTypes\n{\n   public void MyAOTRefs()\n   {\n       System.Runtime.CompilerService.AsyncVoidMethodBuilder builder = default;\n       IAsyncStateMachine asm = default;\n       builder.Start(ref asm);\n   }\n}\n")))}u.isMDXComponent=!0}}]);