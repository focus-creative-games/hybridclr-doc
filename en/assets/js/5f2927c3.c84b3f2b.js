"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3650],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>y});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var m=n.createContext({}),s=function(e){var t=n.useContext(m),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=s(e.components);return n.createElement(m.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,m=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=s(a),u=i,y=d["".concat(m,".").concat(u)]||d[u]||c[u]||r;return a?n.createElement(y,o(o({ref:t},p),{},{components:a})):n.createElement(y,o({ref:t},p))}));function y(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=u;var l={};for(var m in t)hasOwnProperty.call(t,m)&&(l[m]=t[m]);l.originalType=e,l[d]="string"==typeof e?e:i,o[1]=l;for(var s=2;s<r;s++)o[s]=a[s];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},77679:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>m,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var n=a(87462),i=(a(67294),a(3905));const r={},o="Impact on App Memory",l={unversionedId:"basic/impactonappmemory",id:"basic/impactonappmemory",title:"Impact on App Memory",description:"After integrating HybridCLR, the impact on App runtime memory mainly consists of the following parts:",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/basic/impactonappmemory.md",sourceDirName:"basic",slug:"/basic/impactonappmemory",permalink:"/en/docs/basic/impactonappmemory",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Impact on App Package Size",permalink:"/en/docs/basic/impactonappsize"},next:{title:"Unsupported Features",permalink:"/en/docs/basic/notsupportedfeatures"}},m={},s=[{value:"Testing",id:"testing",level:2},{value:"Summary",id:"summary",level:2},{value:"Community Version",id:"community-version",level:3},{value:"Professional Version",id:"professional-version",level:3},{value:"Ultimate Version",id:"ultimate-version",level:3}],p={toc:s},d="wrapper";function c(e){let{components:t,...a}=e;return(0,i.kt)(d,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"impact-on-app-memory"},"Impact on App Memory"),(0,i.kt)("p",null,"After integrating HybridCLR, the impact on App runtime memory mainly consists of the following parts:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Dynamic Heap Memory",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"(Increase) Memory occupied by maintaining bridge function mappings"),(0,i.kt)("li",{parentName:"ul"},"(Increase) Interpreter thread data stack and frame stack memory"),(0,i.kt)("li",{parentName:"ul"},"(Increase) Memory occupied by instruction optimization module (",(0,i.kt)("strong",{parentName:"li"},"only available in commercial versions"),")"),(0,i.kt)("li",{parentName:"ul"},"(Increase) Additional metadata memory occupied by DHE (",(0,i.kt)("strong",{parentName:"li"},"only available in Ultimate version"),")"),(0,i.kt)("li",{parentName:"ul"},"(",(0,i.kt)("strong",{parentName:"li"},"Decrease"),") Optimized libil2cpp metadata memory management (",(0,i.kt)("strong",{parentName:"li"},"only available in commercial versions"),"). Significantly reduces metadata memory overhead"))),(0,i.kt)("li",{parentName:"ul"},"Static Code Segment Memory",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"(Increase) Bridge function MethodBridge.cpp increases binary code size after compilation"),(0,i.kt)("li",{parentName:"ul"},"(Increase) Additional code bloat introduced by DHE code injection increases binary code size (",(0,i.kt)("strong",{parentName:"li"},"only available in Ultimate version"),")"),(0,i.kt)("li",{parentName:"ul"},"(",(0,i.kt)("strong",{parentName:"li"},"Decrease"),") After converting AOT assemblies to regular interpreted assemblies (excluding DHE assemblies, as DHE assemblies also need to be compiled into AOT), reduces binary code size")))),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"Although the increased static Code segment memory size will be displayed in the App's total memory, it does not represent the actual memory usage of the code. Static Code segment code is loaded on demand, and the actual memory usage should be checked with ",(0,i.kt)("inlineCode",{parentName:"p"},"Resident Set Size (RSS)")," data.")),(0,i.kt)("p",null,"We built a test project to test the actual impact of HybridCLR on the package."),(0,i.kt)("h2",{id:"testing"},"Testing"),(0,i.kt)("p",null,"We tested the memory of Android Armv8 platform apk built with Unity 2021 version."),(0,i.kt)("p",null,"The AOT part of the test project fully includes the following frameworks and libraries:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"mscorlib, System, System.Core"),(0,i.kt)("li",{parentName:"ul"},"UnityEngine.dll, UnityEngine.CoreModule.dll, UnityEngine.UI.dll, UnityEngine.PhysicsModule.dll"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/EllanJiang/GameFramework"},"GameFramework")),(0,i.kt)("li",{parentName:"ul"},"HybridCLR.Runtime.dll"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/focus-creative-games/luban"},"Luban")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/Cysharp/UniTask"},"UniTask")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/tuyoogame/YooAsset"},"YooAsset"))),(0,i.kt)("p",null,"We counted the total size of AOT module dlls after building the apk: 12.0M in total."),(0,i.kt)("p",null,"The hot update part of the test project code consists of the following parts:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Unit test project code"),(0,i.kt)("li",{parentName:"ul"},"Configuration code generated by Luban")),(0,i.kt)("p",null,"The compiled HotUpdate.dll is 1216k."),(0,i.kt)("p",null,"The bridge function MethodBridge.cpp size is 15088K."),(0,i.kt)("p",null,"We compared the memory usage in the following scenarios:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"NotHybridCLR-NotHotUpdateCode   Not integrated with HybridCLR, does not include HotUpdate code"),(0,i.kt)("li",{parentName:"ul"},"NotHybridCLR-HotUpdateCode Not integrated with HybridCLR, includes HotUpdate code"),(0,i.kt)("li",{parentName:"ul"},"HybridCLR Community-NotHotUpdateCode Integrated with HybridCLR community version, does not include HotUpdate code, normally generates bridge function files"),(0,i.kt)("li",{parentName:"ul"},"HybridCLR Community-HotUpdateCode Integrated with HybridCLR community version, includes HotUpdate code, normally generates bridge function files"),(0,i.kt)("li",{parentName:"ul"},"HybridCLR Professional-NotHotUpdateCode Integrated with HybridCLR professional version, does not include HotUpdate code, normally generates bridge function files"),(0,i.kt)("li",{parentName:"ul"},"HybridCLR Professional-HotUpdateCode Integrated with HybridCLR professional version, includes HotUpdate code, normally generates bridge function files"),(0,i.kt)("li",{parentName:"ul"},"HybridCLR Ultimate-NotHotUpdateCode Integrated with HybridCLR ultimate version, does not include HotUpdate code, normally generates bridge functions"),(0,i.kt)("li",{parentName:"ul"},"HybridCLR Ultimate-HotUpdateCode-LoadOriginalDifferentialHybridAssembly Integrated with HybridCLR ultimate version, includes HotUpdate code, normally generates bridge functions, HotUpdate assembly unchanged, uses RuntimeApi::LoadOriginalDifferentialHybridAssembly to load HotUpdate"),(0,i.kt)("li",{parentName:"ul"},"HybridCLR Ultimate-HotUpdateCode-LoadDifferentialHybridAssembly Integrated with HybridCLR ultimate version, includes HotUpdate code, normally generates bridge functions, HotUpdate assembly unchanged, uses RuntimeApi::LoadDifferentialHybridAssembly to load HotUpdate")),(0,i.kt)("p",null,"Test results are as follows:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Build Method"),(0,i.kt)("th",{parentName:"tr",align:null},"App Heap Memory(K)"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"NotHybridCLR-NotHotUpdateCode"),(0,i.kt)("td",{parentName:"tr",align:null},"51343")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"NotHybridCLR-HotUpdateCode"),(0,i.kt)("td",{parentName:"tr",align:null},"59400")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"HybridCLR Community-NotHotUpdateCode"),(0,i.kt)("td",{parentName:"tr",align:null},"53592")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"HybridCLR Community-HotUpdateCode"),(0,i.kt)("td",{parentName:"tr",align:null},"65695")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"HybridCLR Professional-NotHotUpdateCode"),(0,i.kt)("td",{parentName:"tr",align:null},"50380")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"HybridCLR Professional-HotUpdateCode"),(0,i.kt)("td",{parentName:"tr",align:null},"62235")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"HybridCLR Ultimate-NotHotUpdateCode"),(0,i.kt)("td",{parentName:"tr",align:null},"52531")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"HybridCLR Ultimate-HotUpdateCode-LoadOriginalDifferentialHybridAssembly"),(0,i.kt)("td",{parentName:"tr",align:null},"61276")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"HybridCLR Ultimate-HotUpdateCode-LoadDifferentialHybridAssembly"),(0,i.kt)("td",{parentName:"tr",align:null},"65655")))),(0,i.kt)("p",null,"Based on the above test project, we can roughly draw the following conclusions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"(Increase) Bridge functions occupy approximately ",(0,i.kt)("inlineCode",{parentName:"li"},"{MethodBridge.cpp file size} * 0.1")," size of heap memory"),(0,i.kt)("li",{parentName:"ul"},"(Increase) Each thread that has executed hot update code occupies approximately 1.2M memory"),(0,i.kt)("li",{parentName:"ul"},"(Increase) Instruction optimization module (",(0,i.kt)("strong",{parentName:"li"},"only available in commercial versions"),") occupies about 700K"),(0,i.kt)("li",{parentName:"ul"},"(Increase) Additional metadata memory occupied by DHE (",(0,i.kt)("strong",{parentName:"li"},"only available in Ultimate version"),"). Approximately ",(0,i.kt)("inlineCode",{parentName:"li"},"{total AOT assembly size + total DHE assembly size} * 0.12")," size of memory"),(0,i.kt)("li",{parentName:"ul"},"(Increase) Bridge function MethodBridge.cpp increases binary code size after compilation. Approximately ",(0,i.kt)("inlineCode",{parentName:"li"},"{MethodBridge.cpp file size} * 0.3")," size"),(0,i.kt)("li",{parentName:"ul"},"(Increase) Additional code introduced by DHE (",(0,i.kt)("strong",{parentName:"li"},"only available in Ultimate version"),") code injection increases binary code size. Approximately ",(0,i.kt)("inlineCode",{parentName:"li"},"{DHE assembly size} * 0.86")," size"),(0,i.kt)("li",{parentName:"ul"},"(",(0,i.kt)("strong",{parentName:"li"},"Decrease"),") Optimized libil2cpp metadata memory management (",(0,i.kt)("strong",{parentName:"li"},"only available in commercial versions"),"), reduces ",(0,i.kt)("inlineCode",{parentName:"li"},"10-25%")," of metadata memory overhead"),(0,i.kt)("li",{parentName:"ul"},"(",(0,i.kt)("strong",{parentName:"li"},"Decrease"),") After converting AOT assemblies to regular interpreted assemblies (excluding DHE assemblies, as DHE assemblies also need to be compiled into AOT), reduces binary code size. Approximately ",(0,i.kt)("inlineCode",{parentName:"li"},"{hot update assembly size} * 5.2")," size")),(0,i.kt)("h2",{id:"summary"},"Summary"),(0,i.kt)("h3",{id:"community-version"},"Community Version"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Additional heap memory is approximately ",(0,i.kt)("inlineCode",{parentName:"li"},"{MethodBridge.cpp size} * 0.1")," + ",(0,i.kt)("inlineCode",{parentName:"li"},"1.2M * {number of threads that executed interpreted code}")," + ",(0,i.kt)("inlineCode",{parentName:"li"},"{hot update assembly size} * 2.2")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Increase")," in code segment memory is approximately ",(0,i.kt)("inlineCode",{parentName:"li"},"{MethodBridge.cpp size} * 0.3")," - ",(0,i.kt)("inlineCode",{parentName:"li"},"{hot update assembly size} * 5.2"))),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Generally speaking, after integrating the community version, binary code will decrease, meaning the ",(0,i.kt)("inlineCode",{parentName:"p"},"increased code segment memory")," is usually a ",(0,i.kt)("strong",{parentName:"p"},"negative value"),".")),(0,i.kt)("h3",{id:"professional-version"},"Professional Version"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Additional heap memory is approximately ",(0,i.kt)("inlineCode",{parentName:"li"},"{MethodBridge.cpp size} * 0.1")," + 0.7M (instruction optimization module memory) + ",(0,i.kt)("inlineCode",{parentName:"li"},"1.2M * {number of threads that executed interpreted code}")," + ",(0,i.kt)("inlineCode",{parentName:"li"},"{hot update assembly size} * 1.6")," - ",(0,i.kt)("inlineCode",{parentName:"li"},"{total assembly size} * 0.2")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Increase")," in code segment memory is approximately ",(0,i.kt)("inlineCode",{parentName:"li"},"{MethodBridge.cpp size} * 0.3")," - ",(0,i.kt)("inlineCode",{parentName:"li"},"{hot update assembly size} * 5.2"))),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Generally speaking, after integrating the professional version, binary code will decrease, meaning the ",(0,i.kt)("inlineCode",{parentName:"p"},"increased code segment memory")," is usually a ",(0,i.kt)("strong",{parentName:"p"},"negative value"),".")),(0,i.kt)("h3",{id:"ultimate-version"},"Ultimate Version"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Additional heap memory is approximately ",(0,i.kt)("inlineCode",{parentName:"li"},"{MethodBridge.cpp size} * 0.1")," + 0.7M (instruction optimization module memory) + ",(0,i.kt)("inlineCode",{parentName:"li"},"1.2M * {number of threads that executed interpreted code}")," + ",(0,i.kt)("inlineCode",{parentName:"li"},"{hot update assembly size} * 3 (questionable, seems significantly overestimated)")," + ",(0,i.kt)("inlineCode",{parentName:"li"},"{total AOT assembly size + total DHE assembly size} * 0.12")," - ",(0,i.kt)("inlineCode",{parentName:"li"},"{total assembly size} * 0.2")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Increase")," in code segment memory is approximately ",(0,i.kt)("inlineCode",{parentName:"li"},"{DHE assembly size} * 0.86")," + ",(0,i.kt)("inlineCode",{parentName:"li"},"{MethodBridge.cpp size} * 0.3"))),(0,i.kt)("admonition",{type:"warning"},(0,i.kt)("p",{parentName:"admonition"},"Due to the limited scale of the sample project, the test results may not match real projects. The ",(0,i.kt)("inlineCode",{parentName:"p"},"{hot update assembly size} * 3")," portion of memory is clearly overestimated, please refer to actual projects.")))}c.isMDXComponent=!0}}]);