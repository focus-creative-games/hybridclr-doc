"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1904],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>y});var l=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);t&&(l=l.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,l)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function r(e,t){if(null==e)return{};var a,l,n=function(e,t){if(null==e)return{};var a,l,n={},s=Object.keys(e);for(l=0;l<s.length;l++)a=s[l],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(l=0;l<s.length;l++)a=s[l],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var c=l.createContext({}),o=function(e){var t=l.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=o(e.components);return l.createElement(c.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return l.createElement(l.Fragment,{},t)}},m=l.forwardRef((function(e,t){var a=e.components,n=e.mdxType,s=e.originalType,c=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),u=o(a),m=n,y=u["".concat(c,".").concat(m)]||u[m]||d[m]||s;return a?l.createElement(y,i(i({ref:t},p),{},{components:a})):l.createElement(y,i({ref:t},p))}));function y(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var s=a.length,i=new Array(s);i[0]=m;var r={};for(var c in t)hasOwnProperty.call(t,c)&&(r[c]=t[c]);r.originalType=e,r[u]="string"==typeof e?e:n,i[1]=r;for(var o=2;o<s;o++)i[o]=a[o];return l.createElement.apply(null,i)}return l.createElement.apply(null,a)}m.displayName="MDXCreateElement"},83786:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>o});var l=a(87462),n=(a(67294),a(3905));const s={},i="Access Control Policy",r={unversionedId:"business/accesspolicy",id:"business/accesspolicy",title:"Access Control Policy",description:"For some platform-type applications, they may load and execute third-party developed code. If these third-party codes are not restricted, it will bring security risks.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/business/accesspolicy.md",sourceDirName:"business",slug:"/business/accesspolicy",permalink:"/en/docs/business/accesspolicy",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Code Hardening",permalink:"/en/docs/business/basicencryption"},next:{title:"Commercial Project Cases",permalink:"/en/docs/business/businesscase"}},c={},o=[{value:"Access Policy File",id:"access-policy-file",level:2},{value:"Configuration Rules",id:"configuration-rules",level:2},{value:"Rule",id:"rule",level:3},{value:"assembly",id:"assembly",level:3},{value:"type",id:"type",level:3},{value:"Target",id:"target",level:3},{value:"XmlAccessPolicyReader and BinaryAccessPolicyWriter",id:"xmlaccesspolicyreader-and-binaryaccesspolicywriter",level:2},{value:"Validate AccessPolicy Configuration Validity",id:"validate-accesspolicy-configuration-validity",level:2},{value:"Pre-validate whether assembly meets AccessPolicy",id:"pre-validate-whether-assembly-meets-accesspolicy",level:2},{value:"Set access policy at runtime",id:"set-access-policy-at-runtime",level:2}],p={toc:o},u="wrapper";function d(e){let{components:t,...a}=e;return(0,n.kt)(u,(0,l.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"access-control-policy"},"Access Control Policy"),(0,n.kt)("p",null,"For some platform-type applications, they may load and execute third-party developed code. If these third-party codes are not restricted, it will bring security risks.\nThe access control mechanism is used to control the set of functions that these third-party codes can access."),(0,n.kt)("h2",{id:"access-policy-file"},"Access Policy File"),(0,n.kt)("p",null,"We use access policy files to conveniently configure control information. Currently only class-level access control is supported (function-level access control may be supported in the future), that is, if a certain class is not allowed to be accessed, any function of that type cannot be called, including class constructors (functions from parent classes can still be called if they are not in the restriction range). A typical policy configuration file is as follows:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-xml"},'<AccessPolicy>\n\n    <Rule id="DisableIO">\n        <assembly fullname="mscorlib">\n            <type fullname="System.IO.*"/> disable\n            <type fullname="System.IO.File" access="1"/> enable\n        </assembly>\n    </Rule>\n\n    <Rule id="DisableReflection">\n        <assembly fullname="mscorlib">\n            <type fullname="System.Reflection.*"/>\n        </assembly>\n    </Rule>\n\n    <Rule id="DisableHybridCLR">\n        <assembly fullname="HybridCLR.Runtime">\n            <type fullname="*"/>\n        </assembly>\n    </Rule>\n\n    <Target assembly="Tests2" accessAssemblyNotInRules="0" rules="DisableReflection,DisableIO,DisableHybridCLR"/>\n\n</AccessPolicy>\n\n')),(0,n.kt)("h2",{id:"configuration-rules"},"Configuration Rules"),(0,n.kt)("p",null,"The top-level tag is AccessPolicy, containing 0-N Rule and Target configuration items."),(0,n.kt)("h3",{id:"rule"},"Rule"),(0,n.kt)("p",null,"Each Rule contains access control rules for multiple assemblies. Each Rule will calculate a set of types that restrict access, and the final set of restricted access is the union of all Rules, that is, as long as a certain Rule restricts access to a certain type, access to this type is not allowed in the end."),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Name"),(0,n.kt)("th",{parentName:"tr",align:null},"Type"),(0,n.kt)("th",{parentName:"tr",align:null},"Nullable"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"id"),(0,n.kt)("td",{parentName:"tr",align:null},"attribute"),(0,n.kt)("td",{parentName:"tr",align:null},"No"),(0,n.kt)("td",{parentName:"tr",align:null},"Rule id. String type, cannot be empty, must be globally unique")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"assembly"),(0,n.kt)("td",{parentName:"tr",align:null},"sub-element"),(0,n.kt)("td",{parentName:"tr",align:null}),(0,n.kt)("td",{parentName:"tr",align:null},"Restriction set for a single assembly. Rule can contain 0-N assemblies. The same Rule cannot have assemblies with the same name, but different Rules can have assemblies with the same name")))),(0,n.kt)("h3",{id:"assembly"},"assembly"),(0,n.kt)("p",null,"A set of restriction rules for a single assembly, configuring which types of the assembly are prohibited from access."),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Name"),(0,n.kt)("th",{parentName:"tr",align:null},"Type"),(0,n.kt)("th",{parentName:"tr",align:null},"Nullable"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"fullname"),(0,n.kt)("td",{parentName:"tr",align:null},"attribute"),(0,n.kt)("td",{parentName:"tr",align:null},"No"),(0,n.kt)("td",{parentName:"tr",align:null},"Assembly name. String type, cannot be empty. Assembly name does not include '.dll' (e.g., mscorlib)")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"type"),(0,n.kt)("td",{parentName:"tr",align:null},"sub-element"),(0,n.kt)("td",{parentName:"tr",align:null}),(0,n.kt)("td",{parentName:"tr",align:null},"Restriction rules for a single type or a group of types. Can have 0-N elements")))),(0,n.kt)("p",null,"Within the same assembly, if multiple rules appear that are related to a certain type, the last effective rule shall prevail. For example:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-xml"},'        <assembly fullname="mscorlib">\n            <type fullname="System.IO.*"/> disable\n            <type fullname="System.IO.File" access="1"/> enable\n        </assembly>\n')),(0,n.kt)("p",null,"In the above example, although ",(0,n.kt)("inlineCode",{parentName:"p"},'<type fullname="System.IO.*"/>')," prohibits access to all types under the ",(0,n.kt)("inlineCode",{parentName:"p"},"System.IO")," namespace, including ",(0,n.kt)("inlineCode",{parentName:"p"},"System.IO.File"),", the subsequent ",(0,n.kt)("inlineCode",{parentName:"p"},'<type fullname="System.IO.File" access="1"/>')," separately cancels the access restriction on ",(0,n.kt)("inlineCode",{parentName:"p"},"System.IO.File"),"."),(0,n.kt)("h3",{id:"type"},"type"),(0,n.kt)("p",null,"Restriction rules for one or a group of types."),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Name"),(0,n.kt)("th",{parentName:"tr",align:null},"Type"),(0,n.kt)("th",{parentName:"tr",align:null},"Nullable"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"fullname"),(0,n.kt)("td",{parentName:"tr",align:null},"attribute"),(0,n.kt)("td",{parentName:"tr",align:null},"No"),(0,n.kt)("td",{parentName:"tr",align:null},"Type full name or type wildcard. When it's a type wildcard, only supports ",(0,n.kt)("inlineCode",{parentName:"td"},"*")," full match or ",(0,n.kt)("inlineCode",{parentName:"td"},"xx.yy.zz.*")," namespace wildcard, does not support ",(0,n.kt)("inlineCode",{parentName:"td"},"xx.yy*")," prefix wildcard or ",(0,n.kt)("inlineCode",{parentName:"td"},"xx.*.yy")," arbitrary wildcard. If you want to match all types with empty namespace, use ",(0,n.kt)("inlineCode",{parentName:"td"},".*"))),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"access"),(0,n.kt)("td",{parentName:"tr",align:null},"attribute"),(0,n.kt)("td",{parentName:"tr",align:null},"Yes"),(0,n.kt)("td",{parentName:"tr",align:null},"Whether accessible, default is false. When set to ",(0,n.kt)("inlineCode",{parentName:"td"},"true, yes, 1"),", it's true; when set to ",(0,n.kt)("inlineCode",{parentName:"td"},"false, no, 0"),", it's false")))),(0,n.kt)("h3",{id:"target"},"Target"),(0,n.kt)("p",null,"Target configures the access restriction rules applied to code in the assembly."),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Name"),(0,n.kt)("th",{parentName:"tr",align:null},"Type"),(0,n.kt)("th",{parentName:"tr",align:null},"Nullable"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"assembly"),(0,n.kt)("td",{parentName:"tr",align:null},"attribute"),(0,n.kt)("td",{parentName:"tr",align:null},"No"),(0,n.kt)("td",{parentName:"tr",align:null},"Target assembly for access restrictions, that is, functions accessed by code in this assembly must satisfy the access restriction rules specified in rules")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"accessAssemblyNotInRules"),(0,n.kt)("td",{parentName:"tr",align:null},"attribute"),(0,n.kt)("td",{parentName:"tr",align:null},"Yes"),(0,n.kt)("td",{parentName:"tr",align:null},"Whether assemblies not involved in rules can be accessed. Default is false, when set to ",(0,n.kt)("inlineCode",{parentName:"td"},"true, yes, 1"),", it's true; when set to ",(0,n.kt)("inlineCode",{parentName:"td"},"false, no, 0"),", it's false")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"rules"),(0,n.kt)("td",{parentName:"tr",align:null},"attribute"),(0,n.kt)("td",{parentName:"tr",align:null},"No"),(0,n.kt)("td",{parentName:"tr",align:null},"List of Rule ids, separated by ",(0,n.kt)("inlineCode",{parentName:"td"},","),". Functions accessed by code in assembly must not be in the restriction set of any Rule")))),(0,n.kt)("h2",{id:"xmlaccesspolicyreader-and-binaryaccesspolicywriter"},"XmlAccessPolicyReader and BinaryAccessPolicyWriter"),(0,n.kt)("p",null,"Access policy files are in xml format, which is complex to parse and has certain overhead when loaded at runtime. Therefore, it's necessary to convert AccessPolicy.xml to AccessPolicy.bin file in advance during packaging, and load the AccessPolicy.bin file at runtime."),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"HybridCLR.Editor.Security.AccessPolicyUtil")," class implements the ConvertXmlAccessPolicyToBinaryAccessPolicy function, used to convert xml format to bin format.\nExample code is as follows:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp"},'        [MenuItem("Test/ConvertXmlAccessPolicyToBinary")]\n        public static void ConvertXmlAccessPolicyToBinary()\n        {\n            string accessPolicyDir = Application.dataPath + "/AccessPolicy";\n            AccessPolicyUtil.ConvertXmlAccessPolicyToBinaryAccessPolicy($"{accessPolicyDir}/AccessPolicy.xml",\n                $"{accessPolicyDir}/AccessPolicy.bytes");\n        }\n')),(0,n.kt)("h2",{id:"validate-accesspolicy-configuration-validity"},"Validate AccessPolicy Configuration Validity"),(0,n.kt)("p",null,"In practice, it's easy to incorrectly fill in names like ",(0,n.kt)("inlineCode",{parentName:"p"},"assembly.fullname"),", ",(0,n.kt)("inlineCode",{parentName:"p"},"type.fullname"),", etc., causing the expected access control policy to not be executed correctly.\n",(0,n.kt)("inlineCode",{parentName:"p"},"HybridCLR.Editor.Security.AccessPolicyConfigValidator")," is used to check the validity of AccessPolicy to avoid such errors."),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Function"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"ValidateRules"),(0,n.kt)("td",{parentName:"tr",align:null},"Check the validity of Rule rules")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"ValidateTargets"),(0,n.kt)("td",{parentName:"tr",align:null},"Check the validity of Target rules")))),(0,n.kt)("p",null,"Example code is as follows:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp"},'    public static void ValidateAccessPolicy()\n    {\n        var reader = new XmlAccessPolicyReader();\n        reader.LoadXmlFile("Assets/AccessPolicy/AccessPolicy.xml");\n        List<string> hotUpdateDllNames = SettingsUtil.HotUpdateAssemblyNamesExcludePreserved;\n        var assemblyCache = new AssemblyCache(MetaUtil.CreateHotUpdateAndAOTAssemblyResolver(EditorUserBuildSettings.activeBuildTarget, hotUpdateDllNames));\n        var validator = new AccessPolicyConfigValidator(assemblyCache);\n\n        var accessPolicy = reader.GetAccessPolicy();\n        validator.ValidateRules(accessPolicy);\n        validator.ValidateTargets(accessPolicy, new List<string> { "Tests2" });\n    }\n')),(0,n.kt)("h2",{id:"pre-validate-whether-assembly-meets-accesspolicy"},"Pre-validate whether assembly meets AccessPolicy"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"Assembly.Load")," does not check whether there are illegal calls in the assembly when loading it. It only checks whether calling a function conforms to AccessPolicy when the function is called for the first time during runtime, which is inconvenient.\n",(0,n.kt)("inlineCode",{parentName:"p"},"HybridCLR.Editor.Security.AssemblyValidator")," is used to offline pre-validate whether all calls in assembly conform to AccessPolicy."),(0,n.kt)("p",null,"Example code is as follows:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp"},'        public static void ValidateAssembly()\n        {\n            var reader = new XmlAccessPolicyReader();\n            reader.LoadXmlFile("Assets/AccessPolicy/AccessPolicy.xml");\n            var validator = new AssemblyValidator(reader.GetAccessPolicy());\n            string test2DllPath = $"{SettingsUtil.GetHotUpdateDllsOutputDirByTarget(EditorUserBuildSettings.activeBuildTarget)}/Tests2.dll";\n            var mod = ModuleDefMD.Load(test2DllPath);\n            validator.ValidateAssembly(mod);\n        }\n\n')),(0,n.kt)("h2",{id:"set-access-policy-at-runtime"},"Set access policy at runtime"),(0,n.kt)("p",null,"The RuntimeApi class provides the LoadAccessPolicy function to set access policies. This function can be called multiple times during runtime to update access policies."),(0,n.kt)("p",null,"Example code is as follows:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp"},'\nvoid LoadAccessPolicy()\n{\n    byte[] accessPolicyData = File.ReadAllBytes($"{Application.streamingAssetsPath}/AccessPolicy.bin");\n    RuntimeApi.LoadAccessPolicy(accessPolicyData);\n}\n\n')))}d.isMDXComponent=!0}}]);