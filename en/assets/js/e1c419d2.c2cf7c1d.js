"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4340],{3905:(t,e,n)=>{n.d(e,{Zo:()=>u,kt:()=>k});var a=n(7294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function l(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?l(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},l=Object.keys(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var d=a.createContext({}),p=function(t){var e=a.useContext(d),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},u=function(t){var e=p(t.components);return a.createElement(d.Provider,{value:e},t.children)},m="mdxType",g={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},s=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,l=t.originalType,d=t.parentName,u=o(t,["components","mdxType","originalType","parentName"]),m=p(n),s=r,k=m["".concat(d,".").concat(s)]||m[s]||g[s]||l;return n?a.createElement(k,i(i({ref:e},u),{},{components:n})):a.createElement(k,i({ref:e},u))}));function k(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=n.length,i=new Array(l);i[0]=s;var o={};for(var d in e)hasOwnProperty.call(e,d)&&(o[d]=e[d]);o.originalType=t,o[m]="string"==typeof t?t:r,i[1]=o;for(var p=2;p<l;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}s.displayName="MDXCreateElement"},4866:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>d,contentTitle:()=>i,default:()=>g,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const l={},i="Method Bridge",o={unversionedId:"basic/methodbridge",id:"basic/methodbridge",title:"Method Bridge",description:"Two-way function calls are required between the Interpreter of HybridCLR and AOT. For example, the interpreter calls the AOT function, or the AOT calls back the interpreter through the interface interface or delegate.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/basic/methodbridge.md",sourceDirName:"basic",slug:"/basic/methodbridge",permalink:"/en/docs/basic/methodbridge",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"AOT generic problem",permalink:"/en/docs/basic/aotgeneric"},next:{title:"Memory and GC",permalink:"/en/docs/basic/memory"}},d={},p=[{value:"Bridge function signature",id:"bridge-function-signature",level:2},{value:"Signature rules for Universal32",id:"signature-rules-for-universal32",level:3},{value:"Sharing rules for Universal64",id:"sharing-rules-for-universal64",level:3},{value:"Sharing Rules for Arm64",id:"sharing-rules-for-arm64",level:3},{value:"Generate bridge function",id:"generate-bridge-function",level:2}],u={toc:p},m="wrapper";function g(t){let{components:e,...n}=t;return(0,r.kt)(m,(0,a.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"method-bridge"},"Method Bridge"),(0,r.kt)("p",null,"Two-way function calls are required between the Interpreter of HybridCLR and AOT. For example, the interpreter calls the AOT function, or the AOT calls back the interpreter through the interface interface or delegate."),(0,r.kt)("p",null,"The parameter passing and storage methods of the AOT part and the interpreter part are different. The interpreter part calls the AOT function, and the parameters of the interpreter are all on the interpreter stack, and the function parameters of the interpreter must be passed to the AOT function by means of a suitable method. Similarly, the interpreter cannot directly obtain the parameters of the AOT callback function. Corresponding bridge functions must be generated for each type of signature function to realize the two-way function parameter transfer between the interpreter and the aot part. Calling in the direction of ",(0,r.kt)("inlineCode",{parentName:"p"},"interpreter -> AOT")," can be done through libraries like ffi, but the cost of function calls is too high. The most reasonable way is to generate this bidirectional bridge function in advance. The internal calls of the interpreter go directly to the interpreter stack, no bridge function is needed."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"According to the principle of bridge functions, for a fixed AOT part, the set of bridge functions is determined, and no new additional bridge functions will be needed no matter any subsequent hot updates. ",(0,r.kt)("strong",{parentName:"p"},"Therefore, there is no need to worry about the problem that the bridge function is missing suddenly after the hot update goes online. "))),(0,r.kt)("h2",{id:"bridge-function-signature"},"Bridge function signature"),(0,r.kt)("p",null,"The bridge function must be generated in the AOT part in advance, which is similar to the principle of lua's wrapper function."),(0,r.kt)("p",null,"In order to find the corresponding bridge function for each function called between ",(0,r.kt)("inlineCode",{parentName:"p"},"AOT <-> interpreter"),", there must be a way to calculate the function signature. In addition, functions with completely equivalent parameter types and return value types can sharing the same bridge function, which greatly reduces the number of bridge functions. For the following example, for x64 and arm64 platforms, long and class types sharing the same signature. So they can all sharing a bridge function with ",(0,r.kt)("inlineCode",{parentName:"p"},"long (long, long)")," signature."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"object Fun1(object a, long b);\nlong Fun2(long a, long b);\nobject Fun3(object a, object b);\n")),(0,r.kt)("p",null,"There are some differences in how the ABIs of different operating systems and architectures handle function parameter passing and return values. Considering that both Android v8 and iOS are arm64, in order to maximize the performance of these two common platforms and balance the cost of maintaining too many platforms, we simply designed the most stringent signature calculation rules for 32 and 64 bits respectively, called Universal32 and Universal64, as well as the Arm64 family bridge signature calculation rules are designed for the mobile game arm 64-bit platform."),(0,r.kt)("p",null,"-Arm64"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Universal32 uses the abi intersection of all 32-bit platforms to calculate the signature"),(0,r.kt)("li",{parentName:"ul"},"Universal64 calculates the signature using the abi intersection method other than the arm64 platform")),(0,r.kt)("h3",{id:"signature-rules-for-universal32"},"Signature rules for Universal32"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Signature"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bool, byte"),(0,r.kt)("td",{parentName:"tr",align:null},"u1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sbyte"),(0,r.kt)("td",{parentName:"tr",align:null},"i1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"short"),(0,r.kt)("td",{parentName:"tr",align:null},"i2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ushort, char"),(0,r.kt)("td",{parentName:"tr",align:null},"u2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"int"),(0,r.kt)("td",{parentName:"tr",align:null},"i4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uint"),(0,r.kt)("td",{parentName:"tr",align:null},"u4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"long"),(0,r.kt)("td",{parentName:"tr",align:null},"i8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ulong"),(0,r.kt)("td",{parentName:"tr",align:null},"u8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"float"),(0,r.kt)("td",{parentName:"tr",align:null},"r4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"double"),(0,r.kt)("td",{parentName:"tr",align:null},"r8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"IntPtr"),(0,r.kt)("td",{parentName:"tr",align:null},"i4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UintPtr"),(0,r.kt)("td",{parentName:"tr",align:null},"u4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Universal32 signature corresponding to"),(0,r.kt)("td",{parentName:"tr",align:null},"enum")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Value type reference and class type"),(0,r.kt)("td",{parentName:"tr",align:null},"i4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"value type"),(0,r.kt)("td",{parentName:"tr",align:null},"{S,C}{size}")))),(0,r.kt)("p",null,"S and C correspond to the value types of aligment=1 and 8 respectively. For example, the signature of UnityEngine.Vector3 is S12."),(0,r.kt)("h3",{id:"sharing-rules-for-universal64"},"Sharing rules for Universal64"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Signature"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bool, byte"),(0,r.kt)("td",{parentName:"tr",align:null},"u1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sbyte"),(0,r.kt)("td",{parentName:"tr",align:null},"i1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"short"),(0,r.kt)("td",{parentName:"tr",align:null},"i2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ushort, char"),(0,r.kt)("td",{parentName:"tr",align:null},"u2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"int"),(0,r.kt)("td",{parentName:"tr",align:null},"i4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uint"),(0,r.kt)("td",{parentName:"tr",align:null},"u4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"long"),(0,r.kt)("td",{parentName:"tr",align:null},"i8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ulong"),(0,r.kt)("td",{parentName:"tr",align:null},"u8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"float"),(0,r.kt)("td",{parentName:"tr",align:null},"r4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"double"),(0,r.kt)("td",{parentName:"tr",align:null},"r8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"IntPtr"),(0,r.kt)("td",{parentName:"tr",align:null},"i4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UintPtr"),(0,r.kt)("td",{parentName:"tr",align:null},"u4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Universal32 signature corresponding to"),(0,r.kt)("td",{parentName:"tr",align:null},"enum")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"value type"),(0,r.kt)("td",{parentName:"tr",align:null},"S{size}")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Vector2f"),(0,r.kt)("td",{parentName:"tr",align:null},"v2f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Vector3f"),(0,r.kt)("td",{parentName:"tr",align:null},"v3f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Vector4f"),(0,r.kt)("td",{parentName:"tr",align:null},"v4f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Vector2d"),(0,r.kt)("td",{parentName:"tr",align:null},"v2d")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Vector3d"),(0,r.kt)("td",{parentName:"tr",align:null},"v3d")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Vector4d"),(0,r.kt)("td",{parentName:"tr",align:null},"v4d")))),(0,r.kt)("p",null,"Compared with Univeral32, the value type does not distinguish alignment, all use S."),(0,r.kt)("h3",{id:"sharing-rules-for-arm64"},"Sharing Rules for Arm64"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Signature"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bool, byte"),(0,r.kt)("td",{parentName:"tr",align:null},"u1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"sbyte"),(0,r.kt)("td",{parentName:"tr",align:null},"i1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"short"),(0,r.kt)("td",{parentName:"tr",align:null},"i2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ushort, char"),(0,r.kt)("td",{parentName:"tr",align:null},"u2")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"int"),(0,r.kt)("td",{parentName:"tr",align:null},"i4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"uint"),(0,r.kt)("td",{parentName:"tr",align:null},"u4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"long"),(0,r.kt)("td",{parentName:"tr",align:null},"i8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ulong"),(0,r.kt)("td",{parentName:"tr",align:null},"u8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"float"),(0,r.kt)("td",{parentName:"tr",align:null},"r4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"double"),(0,r.kt)("td",{parentName:"tr",align:null},"r8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"IntPtr"),(0,r.kt)("td",{parentName:"tr",align:null},"i4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UintPtr"),(0,r.kt)("td",{parentName:"tr",align:null},"u4")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Universal32 signature corresponding to"),(0,r.kt)("td",{parentName:"tr",align:null},"enum")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Value type reference and class type"),(0,r.kt)("td",{parentName:"tr",align:null},"i8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Value type as parameter (size<=16)"),(0,r.kt)("td",{parentName:"tr",align:null},"S16")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Value type as parameter (size>16)"),(0,r.kt)("td",{parentName:"tr",align:null},"sr")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"The value type of the return value"),(0,r.kt)("td",{parentName:"tr",align:null},"S{size}")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Vector2f"),(0,r.kt)("td",{parentName:"tr",align:null},"v2f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Vector3f"),(0,r.kt)("td",{parentName:"tr",align:null},"v3f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Vector4f"),(0,r.kt)("td",{parentName:"tr",align:null},"v4f")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Vector2d"),(0,r.kt)("td",{parentName:"tr",align:null},"v2d")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Vector3d"),(0,r.kt)("td",{parentName:"tr",align:null},"v3d")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Vector4d"),(0,r.kt)("td",{parentName:"tr",align:null},"v4d")))),(0,r.kt)("h2",{id:"generate-bridge-function"},"Generate bridge function"),(0,r.kt)("p",null,"The tool script is provided in the com.code-philosophy.hybridclr package, and it is recommended to use the menu command ",(0,r.kt)("inlineCode",{parentName:"p"},"HybridCLR/Generate/All")," to automatically generate all bridge functions. You can also use ",(0,r.kt)("inlineCode",{parentName:"p"},"HybridCLR/Generate/MethodBridge")," directly\nGenerate bridge functions, but the command depends on ",(0,r.kt)("inlineCode",{parentName:"p"},"Cropped AOT dll")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Hot Update dll"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"Cropped AOT dll")," depends on ",(0,r.kt)("inlineCode",{parentName:"p"},"Generate LinkXml")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Generate Il2CppDef"),". Therefore, if you do not use the ",(0,r.kt)("inlineCode",{parentName:"p"},"HybridCLR/Generate/All")," command, you must first run in order:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"HybridCLR/Generate/Il2CppDef")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"HybridCLR/Generate/LinkXml")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"HybridCLR/CompileDll/ActiveBuildTarget")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"HybridCLR/Generate/AotDlls")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"HybridCLR/Generate/MethodBridge"))))}g.isMDXComponent=!0}}]);