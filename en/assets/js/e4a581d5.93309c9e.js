"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3378],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>g});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=r.createContext({}),u=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},s=function(e){var t=u(e.components);return r.createElement(c.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),d=u(n),m=i,g=d["".concat(c,".").concat(m)]||d[m]||p[m]||o;return n?r.createElement(g,a(a({ref:t},s),{},{components:n})):r.createElement(g,a({ref:t},s))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=m;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[d]="string"==typeof e?e:i,a[1]=l;for(var u=2;u<o;u++)a[u]=n[u];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2899:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var r=n(7462),i=(n(7294),n(3905));const o={},a="Source and Debug",l={unversionedId:"basic/sourceinspect",id:"basic/sourceinspect",title:"Source and Debug",description:"HybridCLR module introduction",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/basic/sourceinspect.md",sourceDirName:"basic",slug:"/basic/sourceinspect",permalink:"/en/docs/basic/sourceinspect",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Code Architecture And Version",permalink:"/en/docs/basic/architecture"},next:{title:"il2cpp bug log",permalink:"/en/docs/basic/il2cppbugs"}},c={},u=[{value:"HybridCLR module introduction",id:"hybridclr-module-introduction",level:2},{value:"Transform Implementation Introduction",id:"transform-implementation-introduction",level:3},{value:"Interpreter Implementation Introduction",id:"interpreter-implementation-introduction",level:3},{value:"debug",id:"debug",level:2},{value:"PC, MAC create debugging project",id:"pc-mac-create-debugging-project",level:3},{value:"Android create debug project",id:"android-create-debug-project",level:3}],s={toc:u},d="wrapper";function p(e){let{components:t,...o}=e;return(0,i.kt)(d,(0,r.Z)({},s,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"source-and-debug"},"Source and Debug"),(0,i.kt)("h2",{id:"hybridclr-module-introduction"},"HybridCLR module introduction"),(0,i.kt)("p",null,"HybridCLR implements the following functions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"dll parsing library implemented by c++"),(0,i.kt)("li",{parentName:"ul"},"Metadata registration. Since il2cpp is a static AOT, the original code does not support dynamic registration, because a small amount of modification (hundreds of lines)"),(0,i.kt)("li",{parentName:"ul"},"Instruction set conversion. Convert raw IL instructions into more efficient register instructions"),(0,i.kt)("li",{parentName:"ul"},"Register interpreter. Implemented an efficient interpreter.")),(0,i.kt)("p",null,"In terms of directory structure, it corresponds to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"HybridCLR's own source code",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"interpreter module"),(0,i.kt)("li",{parentName:"ul"},"metadata metadata parsing and registration module"),(0,i.kt)("li",{parentName:"ul"},"transform instruction set conversion module"))),(0,i.kt)("li",{parentName:"ul"},"Minor modifications to il2cpp source code. HybridCLR mainly modifies the il2cpp source code to support dynamic registration of metadata. In most places, only hook processing is inserted, and the original implementation is not modified. For example:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"const char* il2cpp::vm::GlobalMetadata::GetStringFromIndex(StringIndex index)\n{\n     // ==={{ hybridclr\n     if (hybridclr::metadata::IsInterpreterIndex(index))\n     {\n         return hybridclr::metadata::MetadataModule::GetStringFromEncodeIndex(index);\n     }\n     // ===}} hybridclr\n\n     IL2CPP_ASSERT(index <= s_GlobalMetadataHeader->stringCount);\n     const char* strings = ((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->stringOffset) + index;\n     return strings;\n}\n")),(0,i.kt)("h3",{id:"transform-implementation-introduction"},"Transform Implementation Introduction"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The core code is the ",(0,i.kt)("inlineCode",{parentName:"p"},"HiTransform::Transform")," function in ",(0,i.kt)("inlineCode",{parentName:"p"},"hybridclr/transform/Transform.cpp"),".")),(0,i.kt)("p",null,"Very similar to regular instruction tree analysis. divided into parts"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"BasicBlock division. Divide the original IL instruction into multiple BasicBlocks, each BasicBlock does not contain any jump function. Doing so can be more efficient to avoid accidental merging of instructions across jump blocks"),(0,i.kt)("li",{parentName:"ul"},"Simulate the execution of all logical branches, including jumps and exception branches, and convert each IL instruction into a corresponding register instruction."),(0,i.kt)("li",{parentName:"ul"},"Instruction optimization (to be done). Development is expected to begin next month. At that time, most instructions can get 100-300% performance improvement.")),(0,i.kt)("h3",{id:"interpreter-implementation-introduction"},"Interpreter Implementation Introduction"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The core code is in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Interpreter::Execute")," function in ",(0,i.kt)("inlineCode",{parentName:"p"},"hybridclr/interpreter/Interpreter_Execute.cpp"),".")),(0,i.kt)("p",null,"More directly, it is a huge switch statement that interprets and executes instructions."),(0,i.kt)("h2",{id:"debug"},"debug"),(0,i.kt)("p",null,"The core work of the HybridCLR interpreter consists of two parts:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Instruction set conversion. Convert stack-based IL instructions to register-based versions. HiTransform::Transform function in HybridCLR/transform/transform.cpp."),(0,i.kt)("li",{parentName:"ul"},"Interpreted execution of register instructions. Interpreter::Execute function in HybridCLR/interpreter/interpreter_Execute.cpp.")),(0,i.kt)("p",null,"As long as the breakpoints are to these two functions, it is easy to follow the entire process from the conversion of the IL function to the solution execution step by step."),(0,i.kt)("h3",{id:"pc-mac-create-debugging-project"},"PC, MAC create debugging project"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Project Settings")," settings",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Modify ",(0,i.kt)("inlineCode",{parentName:"li"},"C++ Compiler Configuration")," to Debug."))),(0,i.kt)("li",{parentName:"ul"},'Check "Create VisualStudio Solution" in ',(0,i.kt)("inlineCode",{parentName:"li"},"Building Settings"),".")),(0,i.kt)("p",null,"After the Build is completed, a debuggable project will be generated. For more information, please refer to ",(0,i.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/2020.3/Documentation/Manual/windowsstore-debugging-il2cpp.html"},"Unity Official Documentation")),(0,i.kt)("h3",{id:"android-create-debug-project"},"Android create debug project"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Project Settings")," settings",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Modify ",(0,i.kt)("inlineCode",{parentName:"li"},"C++ Compiler Configuration")," to Debug."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Building Settings")," check ",(0,i.kt)("inlineCode",{parentName:"li"},"Export Project"),"."),(0,i.kt)("li",{parentName:"ul"},"After the build is complete, use Android Studio to open the project."),(0,i.kt)("li",{parentName:"ul"},"Assuming that the packaging output path is build_android, select Build->Make Module 'build_android.unityLibrary' in Android Studio, compile unityLibrary, and wait for the compilation to complete"),(0,i.kt)("li",{parentName:"ul"},"Select ",(0,i.kt)("inlineCode",{parentName:"li"},"Run->Edit Configurations...")," and set as shown below.")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"android studio debug",src:n(2352).Z,width:"868",height:"562"})),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Normal debugging is fine.")))}p.isMDXComponent=!0},2352:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/android_studio_debug-4143b523ff6dd01331cc10f276a1ab5e.png"}}]);