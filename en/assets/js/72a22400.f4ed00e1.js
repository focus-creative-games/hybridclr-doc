"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6410],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>f});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),u=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=u(e.components);return i.createElement(l.Provider,{value:t},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=u(n),d=a,f=c["".concat(l,".").concat(d)]||c[d]||p[d]||o;return n?i.createElement(f,r(r({ref:t},m),{},{components:n})):i.createElement(f,r({ref:t},m))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:a,r[1]=s;for(var u=2;u<o;u++)r[u]=n[u];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},10690:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>u});var i=n(87462),a=(n(67294),n(3905));const o={},r="Hotfix Dynamic Hot Repair",s={unversionedId:"business/hotfix",id:"business/hotfix",title:"Hotfix Dynamic Hot Repair",description:"Some updates are just a few lines of bug fixes, and some developers might want to dynamically fix them while the game is running, rather than forcing players to restart the current game app.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/business/hotfix.md",sourceDirName:"business",slug:"/business/hotfix",permalink:"/en/docs/business/hotfix",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Metadata Optimization",permalink:"/en/docs/business/metadataoptimization"},next:{title:"Assembly::Load Loading Optimization",permalink:"/en/docs/business/assemblyloadoptimization"}},l={},u=[{value:"Advantages",id:"advantages",level:2},{value:"Limitations and Drawbacks",id:"limitations-and-drawbacks",level:2},{value:"Usage",id:"usage",level:2}],m={toc:u},c="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,i.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"hotfix-dynamic-hot-repair"},"Hotfix Dynamic Hot Repair"),(0,a.kt)("p",null,"Some updates are just a few lines of bug fixes, and some developers might want to dynamically fix them while the game is running, rather than forcing players to restart the current game app.\nCurrently, versions other than the ",(0,a.kt)("a",{parentName:"p",href:"./reload/intro"},"Hot Reload Edition")," don't support reloading hot update assemblies.\nEven the hot reload version, despite supporting complete unloading of assemblies and reloading of entirely new assemblies, has many ",(0,a.kt)("a",{parentName:"p",href:"./reload/hotreloadassembly#unsupported-features-and-special-requirements"},"limitations and requirements")," for code, making it highly intrusive to business code."),(0,a.kt)("p",null,"Hotfix technology is specifically designed to solve such dynamic bug fixing scenarios. It can fix bugs in hot update modules at runtime without affecting the user experience, and it's non-intrusive to business code."),(0,a.kt)("h2",{id:"advantages"},"Advantages"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Dynamically fixes code bugs without needing to restart the game app"),(0,a.kt)("li",{parentName:"ul"},"Can fix any code in hot update assemblies (including DHE assemblies in Ultimate Edition), including static member functions, generic functions, async functions, etc."),(0,a.kt)("li",{parentName:"ul"},"Simple to use, non-intrusive to business code, requires no modification of any business code"),(0,a.kt)("li",{parentName:"ul"},"No limit on the number of fixes; can be applied multiple times during app runtime. For example, after releasing v1 fix, other bugs are discovered and v2 fix can be released immediately")),(0,a.kt)("h2",{id:"limitations-and-drawbacks"},"Limitations and Drawbacks"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Can only fix function bodies, cannot modify type definitions (such as changing class names, adding/removing fields, adding/removing functions, modifying function signatures, etc.)"),(0,a.kt)("li",{parentName:"ul"},"Each fix loads a hot update assembly once; previously loaded assembly memory cannot be released, causing some memory leakage"),(0,a.kt)("li",{parentName:"ul"},"Incompatible with function inline optimization; function inlining must be disabled. Call ",(0,a.kt)("inlineCode",{parentName:"li"},"RuntimeApi.SetRuntimeOption(RuntimeOptionId.MaxMethodInlineDepth, 0);")," before hot update loading or at the hot update entry point")),(0,a.kt)("h2",{id:"usage"},"Usage"),(0,a.kt)("p",null,"Call the ",(0,a.kt)("inlineCode",{parentName:"p"},"RuntimeApi::HotfixAssembly")," function to complete hot repair. Example code as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'\npublic static void ApplyHotfix()\n{\n    byte[] hotfixDllBytes = LoadFromXXX("Hotfix");\n    var hotfixTypes = new List<HotfixType>\n    {\n        // Full name of the class to fix, including namespace (if any)\n        name = "TestHotfixMethods",\n        // List of functions to fix\n        methods = new List<HotfixMethod>\n        {\n            new HotfixMethod\n            {\n                // By function name; if there are multiple functions with the same name, all will be fixed\n                name = "Foo1",\n            },\n            new HotfixMethod\n            {\n                // By function signature. Only one of name or signature can be provided, otherwise an error will occur\n                signature = "Int32 Foo2(Int32, Int32)",\n            },\n        }\n    };\n    RuntimeApi.HotfixAssembly("Hotfix", hotfixDllBytes, hotfixTypes);\n}\n')),(0,a.kt)("p",null,"When there are many dlls and functions to fix, this operation is tedious and error-prone. It's recommended to first create a hotfix.manifest.xml configuration file, then convert it to a HotfixManifest class, and use ",(0,a.kt)("inlineCode",{parentName:"p"},"RuntimeApi.HotfixAssemblies")," to apply all fixes at once. The code would look like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'\npublic static void ApplyHotfix()\n{\n    string hotfixXmlStr = @"\n<manifest>\n    <assembly fullname=""Hotfix"">\n        <type fullname=""TestHotfixMethods"">\n            <method name=""Foo1"" />\n            <method signature=""Int32 Foo2(Int32, Int32)"" />\n            <method name=""Bar1"" />\n            <method signature=""Int32 Bar2(Int32, Int32)"" />\n        </type>\n        <type fullname=""TestHotfixCtors"">\n            <method name="".ctor"" />\n            <method signature="".ctor(Int32)"" />\n        </type>\n        <type fullname=""TestHotfixStaticCtors"">\n            <method name="".cctor"" />\n        </type>\n        <type fullname=""TestHotfixGenericClass`1"">\n            <method name=""Foo1"" />\n            <method name=""Foo2"" />\n        </type>\n        <type fullname=""TestHotfixGenericMethods"">\n            <method name=""Foo1"" />\n        </type>\n    </assembly>\n</manifest>\n";\n\n    RuntimeApi.HotfixAssemblies(HotfixManifest.LoadFrom(s_fixXmlStr, assName => LoadDll.GetDllBytes(assName + ".dll")));\n}\n\n')))}p.isMDXComponent=!0}}]);