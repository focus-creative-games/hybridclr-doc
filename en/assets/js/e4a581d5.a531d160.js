"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7015],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>g});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=r.createContext({}),u=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},s=function(e){var t=u(e.components);return r.createElement(c.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),p=u(n),m=i,g=p["".concat(c,".").concat(m)]||p[m]||d[m]||o;return n?r.createElement(g,a(a({ref:t},s),{},{components:n})):r.createElement(g,a({ref:t},s))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=m;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[p]="string"==typeof e?e:i,a[1]=l;for(var u=2;u<o;u++)a[u]=n[u];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},96651:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var r=n(87462),i=(n(67294),n(3905));const o={},a="HybridCLR Source Code Structure and Debugging",l={unversionedId:"basic/sourceinspect",id:"basic/sourceinspect",title:"HybridCLR Source Code Structure and Debugging",description:"HybridCLR Module Introduction",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/basic/sourceinspect.md",sourceDirName:"basic",slug:"/basic/sourceinspect",permalink:"/en/docs/basic/sourceinspect",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Code Structure and Versioning",permalink:"/en/docs/basic/architecture"},next:{title:"il2cpp Bug Record",permalink:"/en/docs/basic/il2cppbugs"}},c={},u=[{value:"HybridCLR Module Introduction",id:"hybridclr-module-introduction",level:2},{value:"Transform Implementation Overview",id:"transform-implementation-overview",level:3},{value:"Interpreter Implementation Overview",id:"interpreter-implementation-overview",level:3},{value:"Debugging",id:"debugging",level:2},{value:"Creating Win, Mac Standalone Debug Project",id:"creating-win-mac-standalone-debug-project",level:3},{value:"Creating Android Debug Project",id:"creating-android-debug-project",level:3},{value:"Creating iOS Debug Project",id:"creating-ios-debug-project",level:3}],s={toc:u},p="wrapper";function d(e){let{components:t,...o}=e;return(0,i.kt)(p,(0,r.Z)({},s,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"hybridclr-source-code-structure-and-debugging"},"HybridCLR Source Code Structure and Debugging"),(0,i.kt)("h2",{id:"hybridclr-module-introduction"},"HybridCLR Module Introduction"),(0,i.kt)("p",null,"HybridCLR implements the following functionality:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"C++ implemented DLL parsing library"),(0,i.kt)("li",{parentName:"ul"},"Metadata registration. Since il2cpp is static AOT, the original code doesn't support dynamic registration, so we made minor modifications (a few hundred lines)"),(0,i.kt)("li",{parentName:"ul"},"Instruction set transformation. Converts original IL instructions to more efficient register instructions"),(0,i.kt)("li",{parentName:"ul"},"Register interpreter. Implements an efficient interpreter.")),(0,i.kt)("p",null,"In terms of directory structure, these correspond to:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"HybridCLR's own source code",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"interpreter - interpreter module"),(0,i.kt)("li",{parentName:"ul"},"metadata - metadata parsing and registration module"),(0,i.kt)("li",{parentName:"ul"},"transform - instruction set transformation module"))),(0,i.kt)("li",{parentName:"ul"},"Minor modifications to il2cpp source code. HybridCLR's modifications to il2cpp source code are mainly to support dynamic metadata registration. Most places just insert hook handling without modifying the original implementation. For example:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"const char* il2cpp::vm::GlobalMetadata::GetStringFromIndex(StringIndex index)\n{\n    // ==={{ hybridclr\n    if (hybridclr::metadata::IsInterpreterIndex(index))\n    {\n        return hybridclr::metadata::MetadataModule::GetStringFromEncodeIndex(index);\n    }\n    // ===}} hybridclr\n\n    IL2CPP_ASSERT(index <= s_GlobalMetadataHeader->stringCount);\n    const char* strings = ((const char*)s_GlobalMetadata + s_GlobalMetadataHeader->stringOffset) + index;\n    return strings;\n}\n")),(0,i.kt)("h3",{id:"transform-implementation-overview"},"Transform Implementation Overview"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The core code is in the ",(0,i.kt)("inlineCode",{parentName:"p"},"HiTransform::Transform")," function in ",(0,i.kt)("inlineCode",{parentName:"p"},"hybridclr/transform/Transform.cpp"),".")),(0,i.kt)("p",null,"Very similar to conventional instruction tree analysis. It consists of several parts:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"BasicBlock division. Splits original IL instructions into multiple BasicBlocks, each containing no jump functions. This efficiently avoids accidental instruction merging across jump blocks"),(0,i.kt)("li",{parentName:"ul"},"Simulates execution of all logical branches, including jump and exception branches, converting each IL instruction to corresponding register instructions."),(0,i.kt)("li",{parentName:"ul"},"Instruction optimization (TODO). Expected to start development in next month's version. Most instructions are expected to achieve 100-300% performance improvement.")),(0,i.kt)("h3",{id:"interpreter-implementation-overview"},"Interpreter Implementation Overview"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The core code is in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Interpreter::Execute")," function in ",(0,i.kt)("inlineCode",{parentName:"p"},"hybridclr/interpreter/Interpreter_Execute.cpp"),".")),(0,i.kt)("p",null,"Quite straightforward, just a huge switch statement that interprets and executes instructions."),(0,i.kt)("h2",{id:"debugging"},"Debugging"),(0,i.kt)("p",null,"HybridCLR interpreter's core work includes two parts:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Instruction set transformation. Converts stack-based IL instructions to register-based versions. In the HiTransform::Transform function in HybridCLR/transform/transform.cpp."),(0,i.kt)("li",{parentName:"ul"},"Interpretive execution of register instructions. In the Interpreter::Execute function in HybridCLR/interpreter/interpreter_Execute.cpp.")),(0,i.kt)("p",null,"By setting breakpoints in these two functions, you can easily trace the entire flow from IL function transformation to execution step by step."),(0,i.kt)("h3",{id:"creating-win-mac-standalone-debug-project"},"Creating Win, Mac Standalone Debug Project"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Project Settings")," configuration",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Change ",(0,i.kt)("inlineCode",{parentName:"li"},"C++ Compiler Configuration")," to Debug"))),(0,i.kt)("li",{parentName:"ul"},'Check "Create VisualStudio Solution" in ',(0,i.kt)("inlineCode",{parentName:"li"},"Building Settings"))),(0,i.kt)("p",null,"After building, a debuggable project is generated. For more information, refer to ",(0,i.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/Manual/uwp-debug-generated-cpp.html"},"Unity's official documentation")),(0,i.kt)("h3",{id:"creating-android-debug-project"},"Creating Android Debug Project"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Project Settings")," configuration",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Change ",(0,i.kt)("inlineCode",{parentName:"li"},"C++ Compiler Configuration")," to Debug"))),(0,i.kt)("li",{parentName:"ul"},"Check ",(0,i.kt)("inlineCode",{parentName:"li"},"Export Project")," in ",(0,i.kt)("inlineCode",{parentName:"li"},"Building Settings")),(0,i.kt)("li",{parentName:"ul"},"After building, open the project with Android Studio."),(0,i.kt)("li",{parentName:"ul"},"Assuming the build output path is build_android, in Android Studio select Build->Make Module 'build_android.unityLibrary', compile unityLibrary, and wait for compilation to complete"),(0,i.kt)("li",{parentName:"ul"},"Select ",(0,i.kt)("inlineCode",{parentName:"li"},"Run->Edit Configurations...")," and configure as shown in the image below.")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"android studio debug",src:n(2352).Z,width:"868",height:"562"})),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Debug normally.")),(0,i.kt)("h3",{id:"creating-ios-debug-project"},"Creating iOS Debug Project"),(0,i.kt)("p",null,"You must use ",(0,i.kt)("inlineCode",{parentName:"p"},"com.code-philosophy.hybridclr")," v3.2.0 or higher to directly debug source code. Lower versions use independently compiled release version libil2cpp.a, which cannot be debugged."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Project Settings")," configuration",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Change ",(0,i.kt)("inlineCode",{parentName:"li"},"C++ Compiler Configuration")," to Debug"))),(0,i.kt)("li",{parentName:"ul"},"Click ",(0,i.kt)("inlineCode",{parentName:"li"},"Build")," to generate Xcode project"),(0,i.kt)("li",{parentName:"ul"},"Debug within the Xcode project")))}d.isMDXComponent=!0},2352:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/android_studio_debug-4143b523ff6dd01331cc10f276a1ab5e.png"}}]);