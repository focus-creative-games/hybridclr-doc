"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3814],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),c=u(n),p=i,h=c["".concat(s,".").concat(p)]||c[p]||m[p]||l;return n?a.createElement(h,r(r({ref:t},d),{},{components:n})):a.createElement(h,r({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=p;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[c]="string"==typeof e?e:i,r[1]=o;for(var u=2;u<l;u++)r[u]=n[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},18432:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>u});var a=n(87462),i=(n(67294),n(3905));const l={},r="Function Injection Strategy",o={unversionedId:"business/ultimate/injectrules",id:"business/ultimate/injectrules",title:"Function Injection Strategy",description:"To avoid dirty function contamination, by default a small section of check and jump code is injected at the beginning of all functions. This injection code has a significant impact on short function performance and the length of the finally generated code (increasing code by about 30%).",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/business/ultimate/injectrules.md",sourceDirName:"business/ultimate",slug:"/business/ultimate/injectrules",permalink:"/en/docs/business/ultimate/injectrules",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"User Manual",permalink:"/en/docs/business/ultimate/manual"},next:{title:"Retarget Metadata",permalink:"/en/docs/business/ultimate/retargetmetadata"}},s={},u=[{value:"Dirty Function Contamination",id:"dirty-function-contamination",level:2},{value:"Indirect Function Optimization Technology",id:"indirect-function-optimization-technology",level:2},{value:"Injection Strategy Files",id:"injection-strategy-files",level:2},{value:"HybridCLR Settings Configuration",id:"hybridclr-settings-configuration",level:3},{value:"Configuration Rules",id:"configuration-rules",level:3},{value:"rules",id:"rules",level:4},{value:"assembly",id:"assembly",level:4},{value:"type",id:"type",level:4},{value:"method",id:"method",level:4},{value:"property",id:"property",level:4},{value:"event",id:"event",level:4},{value:"Code Generation Injection Rules",id:"code-generation-injection-rules",level:2},{value:"Build Workflow Related",id:"build-workflow-related",level:3}],d={toc:u},c="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"function-injection-strategy"},"Function Injection Strategy"),(0,i.kt)("p",null,"To avoid dirty function contamination, by default a small section of check and jump code is injected at the beginning of all functions. This injection code has a significant impact on short function performance and the length of the finally generated code (increasing code by about 30%).\nAlthough in most cases injection code has negligible impact on overall performance, in rare special occasions, this performance degradation can be observed.\nStarting from version v4.5.9, custom configuration of this injection behavior is allowed."),(0,i.kt)("h2",{id:"dirty-function-contamination"},"Dirty Function Contamination"),(0,i.kt)("p",null,"We call changed functions dirty functions. If no modifications are made to the original code generated by il2cpp, for non-virtual function calls, there is a problem of dirty function chain contamination. For example: function A calls function B,\nfunction B calls function C. If function C changes, then A, B, and C will all be marked as dirty functions. In practice, changes to some commonly used basic functions may cause massive amounts of code to be marked as dirty functions,\nwhich is obviously not what we expect."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"class Foo\n{\n\n    public static void A()\n    {\n        B();\n    }\n\n    public static void B()\n    {\n        C();\n    }\n\n    public static void C()\n    {\n        // Old code was new object();\n        // After modification, causes A, B, C to all be marked as dirty functions\n        new List<int>();\n    }\n}\n\n")),(0,i.kt)("h2",{id:"indirect-function-optimization-technology"},"Indirect Function Optimization Technology"),(0,i.kt)("p",null,"We use indirect function optimization technology to overcome this problem. When il2cpp generates code, it inserts a section of check code at the beginning of DHE functions. If the function hasn't changed, it continues execution; otherwise, it jumps to interpreted function execution."),(0,i.kt)("p",null,"Taking the following C# code as an example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"    public class IndirectChangedNotInjectMethod\n    {\n        public static int ChangeMethod10(int x)\n        {\n            return ChangeMethod0(x);\n        }\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"    public static int ChangeMethod100(int x)\n    {\n        return ChangeMethod10(x);\n    }\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"\nThe original il2cpp code generated by the `ChangeMethod100` function is as follows:\n\n```cpp\n IL2CPP_EXTERN_C IL2CPP_METHOD_ATTR int32_t IndirectChangedNotInjectMethod_ChangeMethod100_mFE65234D8ACE343677581C1D96E05E9DFC7C2D1A (int32_t ___0_x, const RuntimeMethod* method) \n{\n    {\n        // return ChangeMethod10(x);\n        int32_t L_0 = ___0_x;\n        int32_t L_1;\n        L_1 = IndirectChangedNotInjectMethod_ChangeMethod10_m1CFE86C6F8D9E11116BA0F8CACB72A31D4F8401E(L_0, NULL);\n        return L_1;\n    }\n}\n")),(0,i.kt)("p",null,"After inserting check and jump code, it becomes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"\nIL2CPP_EXTERN_C IL2CPP_METHOD_ATTR int32_t IndirectChangedNotInjectMethod_ChangeMethod100_mFE65234D8ACE343677581C1D96E05E9DFC7C2D1A (int32_t ___0_x, const RuntimeMethod* method) \n{\n    static bool s_Il2CppMethodInitialized;\n    if (!s_Il2CppMethodInitialized)\n    {\n        il2cpp_codegen_initialize_runtime_metadata((uintptr_t*)&IndirectChangedNotInjectMethod_ChangeMethod100_mFE65234D8ACE343677581C1D96E05E9DFC7C2D1A_RuntimeMethod_var);\n        s_Il2CppMethodInitialized = true;\n    }\n    method = IndirectChangedNotInjectMethod_ChangeMethod100_mFE65234D8ACE343677581C1D96E05E9DFC7C2D1A_RuntimeMethod_var;\n    if (method->isInterpterImpl)\n    {\n        typedef int32_t (*RedirectFunc)(int32_t, const RuntimeMethod*);\n        return ((RedirectFunc)method->methodPointerCallByInterp)(___0_x, method);\n    }\n    {\n        // return ChangeMethod10(x);\n        int32_t L_0 = ___0_x;\n        int32_t L_1;\n        L_1 = IndirectChangedNotInjectMethod_ChangeMethod10_m1CFE86C6F8D9E11116BA0F8CACB72A31D4F8401E(L_0, NULL);\n        return L_1;\n    }\n}\n\n")),(0,i.kt)("p",null," The injected code includes the following content:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The metadata initialization block at the beginning adds initialization code for the metadata corresponding to the current function. If the function originally had no metadata that needed initialization, the entire metadata initialization code block is added"),(0,i.kt)("li",{parentName:"ul"},"A new branch check code is added. If the current function is replaced with interpretation execution, it jumps to interpretation execution")),(0,i.kt)("p",null,"For most cases, the injected code only adds one additional check ",(0,i.kt)("inlineCode",{parentName:"p"},"if (method->isInterpterImpl)"),", which has negligible impact on overall performance. But for short functions (such as ",(0,i.kt)("inlineCode",{parentName:"p"},"int GetValue() { return value; }"),"),\nsince short functions themselves have brief code and often have no metadata that needs initialization, this introduces two additional checks and may prevent function inlining, causing observable performance degradation (10% or more) and significant code bloat (adding two code blocks)."),(0,i.kt)("p",null,"Even for non-short functions, injected code causes the overall size of code files generated by DHE assemblies to increase by 30%, which has a non-negligible impact on package size."),(0,i.kt)("p",null,"In fact, many short functions will not change, so injected code is unnecessary. Avoiding injection can significantly improve their performance and also reduce the size of the finally generated cpp code to some extent. For this reason, we introduced injection strategy files to configure this behavior."),(0,i.kt)("h2",{id:"injection-strategy-files"},"Injection Strategy Files"),(0,i.kt)("p",null,"We optimize the performance degradation and code bloat problems caused by indirect function optimization by configuring some or all functions (use with caution, not recommended!) not to inject. Function Injection Strategy (InjectRules) files are used to\nachieve this purpose."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Even if a function is marked as non-injectable, modifying this function in subsequent hot updates will not cause runtime errors or execution of old logic, it will only cause dirty function contamination problems, i.e., all functions that directly call this function will be marked as dirty functions.")),(0,i.kt)("h3",{id:"hybridclr-settings-configuration"},"HybridCLR Settings Configuration"),(0,i.kt)("p",null,"In the ",(0,i.kt)("inlineCode",{parentName:"p"},"InjectRuleFiles")," field in ",(0,i.kt)("inlineCode",{parentName:"p"},"HybridCLR Settings"),", fill in the injection strategy file path. The file's relative path is from the project root directory (such as ",(0,i.kt)("inlineCode",{parentName:"p"},"Assets/InjectRules/DefaultInjectRules.xml"),")."),(0,i.kt)("p",null,"You can provide 0-N configuration strategy files. If there are no configuration strategy files, injection is performed by default for all functions in DHE assemblies."),(0,i.kt)("h3",{id:"configuration-rules"},"Configuration Rules"),(0,i.kt)("p",null,"The configuration syntax is very similar to link.xml. For a function, if it matches multiple rules, the last rule takes precedence."),(0,i.kt)("p",null,"A typical injection strategy file is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},'<rules>\n    <assembly fullname="*">\n        <type fullname="*">\n            <property name="*"/> \x3c!-- All properties do not inject --\x3e\n        </type>\n    </assembly>\n    <assembly fullname="AssemblyA">\n        <type fullname="Type1">\n            <method name="*"/>\n        </type>\n        <type fullname="Type2">\n            <property name="Age*"/>\n            <property name="Age_3" mode="proxy"/>\n            <property name="Count" mode="none"/>\n            <property signature="System.String Name"/>\n            <method name="Run*"/>\n            <method name="Run_3" mode="proxy"/>\n            <method name="Foo"/>\n            <method signature="System.Int32 Sum(System.Int32,System.Int32)"/>\n            <method signature="System.Int32 Sum2(System.Int32,System.Int32)"/>\n            <event name="OnEvent*"/>\n            <event name="OnEvent_3" mode="proxy"/>\n            <event name="OnHello"/>\n        </type>\n    </assembly>\n    <assembly fullname="AssemblyB">\n        <type fullname="*">\n            <method name="*"/>\n        </type>\n    </assembly>\n</rules>\n')),(0,i.kt)("h4",{id:"rules"},"rules"),(0,i.kt)("p",null,"The top-level tag is rules, which can contain 0-n assembly rules."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Nullable"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"assembly"),(0,i.kt)("td",{parentName:"tr",align:null},"Child element"),(0,i.kt)("td",{parentName:"tr",align:null},"No"),(0,i.kt)("td",{parentName:"tr",align:null},"Assembly rule")))),(0,i.kt)("h4",{id:"assembly"},"assembly"),(0,i.kt)("p",null,"Configure rules for a specific assembly or a class of assemblies."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Nullable"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"fullname"),(0,i.kt)("td",{parentName:"tr",align:null},"Attribute"),(0,i.kt)("td",{parentName:"tr",align:null},"No"),(0,i.kt)("td",{parentName:"tr",align:null},"Assembly name, without '.dll' suffix. Supports wildcards, such as '",(0,i.kt)("em",{parentName:"td"},"', 'Unity."),"', 'MyCustom*', etc.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"type"),(0,i.kt)("td",{parentName:"tr",align:null},"Child element"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes"),(0,i.kt)("td",{parentName:"tr",align:null},"Type rule. Can contain 0-N")))),(0,i.kt)("h4",{id:"type"},"type"),(0,i.kt)("p",null,"Configure injection rules for a specific type or a class of types. Note that it supports injection rules for generic original types, but does not support configuring injection rules for generic instance classes. For example, you can configure injection rules for ",(0,i.kt)("strong",{parentName:"p"},"List","`","1"),",\nbut cannot configure injection rules for ",(0,i.kt)("strong",{parentName:"p"},"List","<","int",">"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If a function satisfies multiple rules, the last rule takes precedence"),(0,i.kt)("li",{parentName:"ul"},"property is treated as two functions ",(0,i.kt)("inlineCode",{parentName:"li"},"get_{name}")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"set_{name}"),", so ",(0,i.kt)("inlineCode",{parentName:"li"},"int Count")," can also be matched by ",(0,i.kt)("inlineCode",{parentName:"li"},'&lt;method name="get_Count"&gt;'))),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Nullable"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"fullname"),(0,i.kt)("td",{parentName:"tr",align:null},"Attribute"),(0,i.kt)("td",{parentName:"tr",align:null},"No"),(0,i.kt)("td",{parentName:"tr",align:null},"Type full name. Supports wildcards, such as '",(0,i.kt)("em",{parentName:"td"},"', 'Unity."),"', 'MyCustom.*.TestType', etc.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"method"),(0,i.kt)("td",{parentName:"tr",align:null},"Child element"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes"),(0,i.kt)("td",{parentName:"tr",align:null},"Function rule")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"property"),(0,i.kt)("td",{parentName:"tr",align:null},"Child element"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes"),(0,i.kt)("td",{parentName:"tr",align:null},"Property rule")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"event"),(0,i.kt)("td",{parentName:"tr",align:null},"Child element"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes"),(0,i.kt)("td",{parentName:"tr",align:null},"Event rule")))),(0,i.kt)("h4",{id:"method"},"method"),(0,i.kt)("p",null,"Configure function injection rules."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Nullable"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"name"),(0,i.kt)("td",{parentName:"tr",align:null},"Attribute"),(0,i.kt)("td",{parentName:"tr",align:null},"No"),(0,i.kt)("td",{parentName:"tr",align:null},"Function name. Supports wildcards, such as '",(0,i.kt)("em",{parentName:"td"},"', 'Run"),"', etc.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"signature"),(0,i.kt)("td",{parentName:"tr",align:null},"Attribute"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes"),(0,i.kt)("td",{parentName:"tr",align:null},"Function signature. Supports wildcards, such as '*', 'System.Int32 ","*","(System.Int32)'")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"mode"),(0,i.kt)("td",{parentName:"tr",align:null},"Child element"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes"),(0,i.kt)("td",{parentName:"tr",align:null},"Injection type, valid values are 'none' or 'proxy'. If not filled or empty, defaults to 'none'")))),(0,i.kt)("h4",{id:"property"},"property"),(0,i.kt)("p",null,"Configure property injection rules. Note that property is treated as two functions ",(0,i.kt)("inlineCode",{parentName:"p"},"get_{name}")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"set_{name}"),", so the getter function ",(0,i.kt)("inlineCode",{parentName:"p"},"get_Count")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"int Count")," can also be matched by ",(0,i.kt)("inlineCode",{parentName:"p"},'&lt;method name="get_Count"&gt;'),"."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Nullable"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"name"),(0,i.kt)("td",{parentName:"tr",align:null},"Attribute"),(0,i.kt)("td",{parentName:"tr",align:null},"No"),(0,i.kt)("td",{parentName:"tr",align:null},"Function name. Supports wildcards, such as '",(0,i.kt)("em",{parentName:"td"},"', 'Run"),"', etc.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"signature"),(0,i.kt)("td",{parentName:"tr",align:null},"Attribute"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes"),(0,i.kt)("td",{parentName:"tr",align:null},"Function signature. Supports wildcards, such as '*', 'System.Int32 ","*","'")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"mode"),(0,i.kt)("td",{parentName:"tr",align:null},"Child element"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes"),(0,i.kt)("td",{parentName:"tr",align:null},"Injection type, valid values are 'none' or 'proxy'. If not filled or empty, defaults to 'none'")))),(0,i.kt)("h4",{id:"event"},"event"),(0,i.kt)("p",null,"Configure event injection rules. Note that event is treated as two functions ",(0,i.kt)("inlineCode",{parentName:"p"},"add_{name}")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"remove_{name}"),", so the add function ",(0,i.kt)("inlineCode",{parentName:"p"},"add_OnDone")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"Action OnDone")," can also be matched by ",(0,i.kt)("inlineCode",{parentName:"p"},'&lt;method name="add_OnDone"&gt;'),"."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Type"),(0,i.kt)("th",{parentName:"tr",align:null},"Nullable"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"name"),(0,i.kt)("td",{parentName:"tr",align:null},"Attribute"),(0,i.kt)("td",{parentName:"tr",align:null},"No"),(0,i.kt)("td",{parentName:"tr",align:null},"Function name. Supports wildcards, such as '",(0,i.kt)("em",{parentName:"td"},"', 'Run"),"', etc.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"signature"),(0,i.kt)("td",{parentName:"tr",align:null},"Attribute"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes"),(0,i.kt)("td",{parentName:"tr",align:null},"Function signature. Supports wildcards, such as '*', 'Action","<","System.Int32",">"," On","*","'")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"mode"),(0,i.kt)("td",{parentName:"tr",align:null},"Child element"),(0,i.kt)("td",{parentName:"tr",align:null},"Yes"),(0,i.kt)("td",{parentName:"tr",align:null},"Injection type, valid values are 'none' or 'proxy'. If not filled or empty, defaults to 'none'")))),(0,i.kt)("h2",{id:"code-generation-injection-rules"},"Code Generation Injection Rules"),(0,i.kt)("p",null,"Manually adding injection rules can be a tedious task. When wildcard matching by name cannot meet requirements, for example when you want to not inject short functions with less than 10 instructions, code generation of corresponding injection rules can greatly simplify\nthe workload of constructing injection rules."),(0,i.kt)("p",null,"The code implementation for generating injection rules is not complex, basically iterating through each DHE assembly, and if a function satisfies a certain rule, adding the corresponding injection rule. Example code is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'\npublic static void GenerateInjectRule(List<string> dheAssemblyNames, string outputInjectRuleFile)\n{\n    int minInjectMethodInstructions = 10;\n\n    foreach (string dheDllPath in dheAssemblyNames)\n    {\n        using (var dheMod = ModuleDefMD.Load(dheDllPath))\n        {\n            // Add injection rule  <assembly fullname="{dheMod.Assembly.Name}" />\n            for (uint i = 1, n = dheMod.Metadata.TablesStream.MethodTable.Rows; i <= n; i++)\n            {\n                MethodDef methodDef = dheMod.ResolveMethod(i);\n                if (methodDef.HasBody && methodDef.Body.Instructions.Count < minInjectMethodInstructions)\n                {\n                    // Add injection rule\n                    // <type name="{methodDef.DeclaringType.Name}">\n                    // <method name="{methodDef.Name}" />\n                    // </type>\n                }\n            }\n        }\n    }\n}\n\n')),(0,i.kt)("h3",{id:"build-workflow-related"},"Build Workflow Related"),(0,i.kt)("p",null,"Injection strategy files need to be consistent with the built main package, i.e., each independently released main package must backup the injection strategy files used at that time. Just as each time dhao files are generated, the AOT dll generated when building the main package must be used,\nwhen generating dhao files, the injection strategy files backed up when building the main package must be used. If incorrect injection strategy files are used, it will cause incorrect dhao files to be generated, which may cause wrong logic to run or even crashes!"))}m.isMDXComponent=!0}}]);