"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1693],{3905:(n,e,t)=>{t.d(e,{Zo:()=>s,kt:()=>p});var a=t(67294);function i(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function r(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?r(Object(t),!0).forEach((function(e){i(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function c(n,e){if(null==n)return{};var t,a,i=function(n,e){if(null==n)return{};var t,a,i={},r=Object.keys(n);for(a=0;a<r.length;a++)t=r[a],e.indexOf(t)>=0||(i[t]=n[t]);return i}(n,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(a=0;a<r.length;a++)t=r[a],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(i[t]=n[t])}return i}var d=a.createContext({}),l=function(n){var e=a.useContext(d),t=e;return n&&(t="function"==typeof n?n(e):o(o({},e),n)),t},s=function(n){var e=l(n.components);return a.createElement(d.Provider,{value:e},n.children)},u="mdxType",m={inlineCode:"code",wrapper:function(n){var e=n.children;return a.createElement(a.Fragment,{},e)}},b=a.forwardRef((function(n,e){var t=n.components,i=n.mdxType,r=n.originalType,d=n.parentName,s=c(n,["components","mdxType","originalType","parentName"]),u=l(t),b=i,p=u["".concat(d,".").concat(b)]||u[b]||m[b]||r;return t?a.createElement(p,o(o({ref:e},s),{},{components:t})):a.createElement(p,o({ref:e},s))}));function p(n,e){var t=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var r=t.length,o=new Array(r);o[0]=b;var c={};for(var d in e)hasOwnProperty.call(e,d)&&(c[d]=e[d]);c.originalType=n,c[u]="string"==typeof n?n:i,o[1]=c;for(var l=2;l<r;l++)o[l]=t[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}b.displayName="MDXCreateElement"},85162:(n,e,t)=>{t.d(e,{Z:()=>o});var a=t(67294),i=t(86010);const r={tabItem:"tabItem_Ymn6"};function o(n){let{children:e,hidden:t,className:o}=n;return a.createElement("div",{role:"tabpanel",className:(0,i.Z)(r.tabItem,o),hidden:t},e)}},74866:(n,e,t)=>{t.d(e,{Z:()=>C});var a=t(87462),i=t(67294),r=t(86010),o=t(12466),c=t(16550),d=t(91980),l=t(67392),s=t(50012);function u(n){return function(n){return i.Children.map(n,(n=>{if(!n||(0,i.isValidElement)(n)&&function(n){const{props:e}=n;return!!e&&"object"==typeof e&&"value"in e}(n))return n;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof n.type?n.type:n.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(n).map((n=>{let{props:{value:e,label:t,attributes:a,default:i}}=n;return{value:e,label:t,attributes:a,default:i}}))}function m(n){const{values:e,children:t}=n;return(0,i.useMemo)((()=>{const n=e??u(t);return function(n){const e=(0,l.l)(n,((n,e)=>n.value===e.value));if(e.length>0)throw new Error(`Docusaurus error: Duplicate values "${e.map((n=>n.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(n),n}),[e,t])}function b(n){let{value:e,tabValues:t}=n;return t.some((n=>n.value===e))}function p(n){let{queryString:e=!1,groupId:t}=n;const a=(0,c.k6)(),r=function(n){let{queryString:e=!1,groupId:t}=n;if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return t??null}({queryString:e,groupId:t});return[(0,d._X)(r),(0,i.useCallback)((n=>{if(!r)return;const e=new URLSearchParams(a.location.search);e.set(r,n),a.replace({...a.location,search:e.toString()})}),[r,a])]}function f(n){const{defaultValue:e,queryString:t=!1,groupId:a}=n,r=m(n),[o,c]=(0,i.useState)((()=>function(n){let{defaultValue:e,tabValues:t}=n;if(0===t.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!b({value:e,tabValues:t}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${t.map((n=>n.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const a=t.find((n=>n.default))??t[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:e,tabValues:r}))),[d,l]=p({queryString:t,groupId:a}),[u,f]=function(n){let{groupId:e}=n;const t=function(n){return n?`docusaurus.tab.${n}`:null}(e),[a,r]=(0,s.Nk)(t);return[a,(0,i.useCallback)((n=>{t&&r.set(n)}),[t,r])]}({groupId:a}),v=(()=>{const n=d??u;return b({value:n,tabValues:r})?n:null})();(0,i.useLayoutEffect)((()=>{v&&c(v)}),[v]);return{selectedValue:o,selectValue:(0,i.useCallback)((n=>{if(!b({value:n,tabValues:r}))throw new Error(`Can't select invalid tab value=${n}`);c(n),l(n),f(n)}),[l,f,r]),tabValues:r}}var v=t(72389);const h={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function g(n){let{className:e,block:t,selectedValue:c,selectValue:d,tabValues:l}=n;const s=[],{blockElementScrollPositionUntilNextRender:u}=(0,o.o5)(),m=n=>{const e=n.currentTarget,t=s.indexOf(e),a=l[t].value;a!==c&&(u(e),d(a))},b=n=>{let e=null;switch(n.key){case"Enter":m(n);break;case"ArrowRight":{const t=s.indexOf(n.currentTarget)+1;e=s[t]??s[0];break}case"ArrowLeft":{const t=s.indexOf(n.currentTarget)-1;e=s[t]??s[s.length-1];break}}e?.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":t},e)},l.map((n=>{let{value:e,label:t,attributes:o}=n;return i.createElement("li",(0,a.Z)({role:"tab",tabIndex:c===e?0:-1,"aria-selected":c===e,key:e,ref:n=>s.push(n),onKeyDown:b,onClick:m},o,{className:(0,r.Z)("tabs__item",h.tabItem,o?.className,{"tabs__item--active":c===e})}),t??e)})))}function y(n){let{lazy:e,children:t,selectedValue:a}=n;const r=(Array.isArray(t)?t:[t]).filter(Boolean);if(e){const n=r.find((n=>n.props.value===a));return n?(0,i.cloneElement)(n,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},r.map(((n,e)=>(0,i.cloneElement)(n,{key:e,hidden:n.props.value!==a}))))}function k(n){const e=f(n);return i.createElement("div",{className:(0,r.Z)("tabs-container",h.tabList)},i.createElement(g,(0,a.Z)({},n,e)),i.createElement(y,(0,a.Z)({},n,e)))}function C(n){const e=(0,v.Z)();return i.createElement(k,(0,a.Z)({key:String(e)},n))}},82752:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>s,contentTitle:()=>d,default:()=>p,frontMatter:()=>c,metadata:()=>l,toc:()=>u});var a=t(87462),i=(t(67294),t(3905)),r=t(74866),o=t(85162);const c={},d="Execution Performance",l={unversionedId:"basic/performance",id:"basic/performance",title:"Execution Performance",description:"Although HybridCLR also uses interpretation execution, both theoretical principles and real device testing data show that HybridCLR has dramatically improved performance (multiple times or even dozens of times) compared to popular hot update solutions like Lua and ILRuntime.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/basic/performance.md",sourceDirName:"basic",slug:"/basic/performance",permalink:"/en/docs/basic/performance",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Memory and GC",permalink:"/en/docs/basic/memory"},next:{title:"Impact on App Package Size",permalink:"/en/docs/basic/impactonappsize"}},s={},u=[{value:"Test Report",id:"test-report",level:2},{value:"HybridCLR Commercial Version Time vs Mono Time",id:"hybridclr-commercial-version-time-vs-mono-time",level:3},{value:"HybridCLR Commercial Version/Mono Performance Ratio",id:"hybridclr-commercial-versionmono-performance-ratio",level:3},{value:"HybridCLR Commercial Version Time vs xlua Time",id:"hybridclr-commercial-version-time-vs-xlua-time",level:3},{value:"HybridCLR Commercial Version/xlua Performance Ratio",id:"hybridclr-commercial-versionxlua-performance-ratio",level:3},{value:"AOT Time vs Commercial Version Time vs Community Version Time (Lower is Better)",id:"aot-time-vs-commercial-version-time-vs-community-version-time-lower-is-better",level:3},{value:"Commercial Version Time/AOT Time vs Community Version Time/AOT Time (Lower is Better)",id:"commercial-version-timeaot-time-vs-community-version-timeaot-time-lower-is-better",level:3},{value:"Commercial Version Performance/Community Version Performance (Higher is Better)",id:"commercial-version-performancecommunity-version-performance-higher-is-better",level:3},{value:"Commercial Version Time/AOT Version Time (Lower is Better)",id:"commercial-version-timeaot-version-time-lower-is-better",level:3},{value:"Principles",id:"principles",level:2},{value:"Rewritten Streamlined and Efficient Metadata Parsing Library",id:"rewritten-streamlined-and-efficient-metadata-parsing-library",level:3},{value:"Using Register Instruction Set",id:"using-register-instruction-set",level:3},{value:"Direct Access to Data Stack and Execution Stack",id:"direct-access-to-data-stack-and-execution-stack",level:3},{value:"Static Instruction Specialization",id:"static-instruction-specialization",level:3},{value:"Pre-calculating Runtime Metadata that Needs to be Resolved",id:"pre-calculating-runtime-metadata-that-needs-to-be-resolved",level:3},{value:"Simple and Efficient Implementation of Object Member Access Instructions",id:"simple-and-efficient-implementation-of-object-member-access-instructions",level:3},{value:"Direct Support for Reference and Pointer Operations Without Indirect Methods",id:"direct-support-for-reference-and-pointer-operations-without-indirect-methods",level:3},{value:"Unified Metadata, More Efficient Object Creation, and Smaller Memory Usage",id:"unified-metadata-more-efficient-object-creation-and-smaller-memory-usage",level:3},{value:"Unified Metadata, Unified Function Call Methods, and No Additional PInvoke and ReversePInvoke Overhead",id:"unified-metadata-unified-function-call-methods-and-no-additional-pinvoke-and-reversepinvoke-overhead",level:3},{value:"Additional Provision of Numerous Intrinsic Functions",id:"additional-provision-of-numerous-intrinsic-functions",level:3},{value:"Strict Compliance with Specifications, No Unnecessary Additional Costs",id:"strict-compliance-with-specifications-no-unnecessary-additional-costs",level:3},{value:"Other Instruction Optimization Techniques",id:"other-instruction-optimization-techniques",level:3},{value:"Appendix: Test Case Code",id:"appendix-test-case-code",level:2},{value:"Commercial Version vs xlua",id:"commercial-version-vs-xlua",level:3},{value:"AOT vs Community Edition vs Commercial Edition vs Mono",id:"aot-vs-community-edition-vs-commercial-edition-vs-mono",level:3}],m={toc:u},b="wrapper";function p(n){let{components:e,...c}=n;return(0,i.kt)(b,(0,a.Z)({},m,c,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"execution-performance"},"Execution Performance"),(0,i.kt)("p",null,"Although HybridCLR also uses interpretation execution, both theoretical principles and real device testing data show that HybridCLR has dramatically improved performance (multiple times or even dozens of times) compared to popular hot update solutions like Lua and ILRuntime."),(0,i.kt)("h2",{id:"test-report"},"Test Report"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"HybridCLR is currently the highest-performing CLR interpreter implementation and the most performant among all hot update solutions, with comprehensive performance exceeding other solutions by more than an order of magnitude.")),(0,i.kt)("p",null,"The comprehensive performance of HybridCLR's commercial version significantly outperforms Mono's mint implementation, with numerical computation instruction performance ranging from 140%-330% of Mono's performance."),(0,i.kt)("p",null,"HybridCLR's commercial version ",(0,i.kt)("strong",{parentName:"p"},"completely dominates")," the xlua solution, with numerical computation instruction performance at 651%-720% of xlua's performance, and being dozens or even hundreds of times faster than xlua in other aspects."),(0,i.kt)("p",null,"The community version of HybridCLR has a noticeable gap with AOT only in ",(0,i.kt)("strong",{parentName:"p"},"numerical computation"),", while other aspects show minimal differences. Therefore, for most projects, the overall game performance is not significantly different from a fully native version."),(0,i.kt)("p",null,"The ",(0,i.kt)("strong",{parentName:"p"},"commercial version")," of HybridCLR dramatically optimizes numerical computation performance, achieving 280%-735% of the community version's performance. Developers with strict performance requirements can contact us for ",(0,i.kt)("a",{parentName:"p",href:"/en/docs/business/intro"},"commercial services"),"."),(0,i.kt)("p",null,"The following is a test report from OnePlus 9R ArmV8 real device testing, with test code provided in the appendix."),(0,i.kt)("h3",{id:"hybridclr-commercial-version-time-vs-mono-time"},"HybridCLR Commercial Version Time vs Mono Time"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"data",src:t(67355).Z,width:"880",height:"478"})),(0,i.kt)("h3",{id:"hybridclr-commercial-versionmono-performance-ratio"},"HybridCLR Commercial Version/Mono Performance Ratio"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"data",src:t(31332).Z,width:"915",height:"551"})),(0,i.kt)("h3",{id:"hybridclr-commercial-version-time-vs-xlua-time"},"HybridCLR Commercial Version Time vs xlua Time"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"data",src:t(87860).Z,width:"972",height:"558"})),(0,i.kt)("h3",{id:"hybridclr-commercial-versionxlua-performance-ratio"},"HybridCLR Commercial Version/xlua Performance Ratio"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"data",src:t(71024).Z,width:"972",height:"527"})),(0,i.kt)("h3",{id:"aot-time-vs-commercial-version-time-vs-community-version-time-lower-is-better"},"AOT Time vs Commercial Version Time vs Community Version Time (Lower is Better)"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"data",src:t(5108).Z,width:"1361",height:"628"})),(0,i.kt)("h3",{id:"commercial-version-timeaot-time-vs-community-version-timeaot-time-lower-is-better"},"Commercial Version Time/AOT Time vs Community Version Time/AOT Time (Lower is Better)"),(0,i.kt)("p",null,"AOT version performance is ",(0,i.kt)("inlineCode",{parentName:"p"},"4.1 - 90")," times that of the community version, and ",(0,i.kt)("inlineCode",{parentName:"p"},"1.30 - 12.9")," times that of the commercial version."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"data",src:t(39446).Z,width:"1283",height:"647"})),(0,i.kt)("h3",{id:"commercial-version-performancecommunity-version-performance-higher-is-better"},"Commercial Version Performance/Community Version Performance (Higher is Better)"),(0,i.kt)("p",null,"Commercial version performance is ",(0,i.kt)("inlineCode",{parentName:"p"},"2.87-7.35")," times that of the community version."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"data",src:t(59672).Z,width:"1280",height:"527"})),(0,i.kt)("h3",{id:"commercial-version-timeaot-version-time-lower-is-better"},"Commercial Version Time/AOT Version Time (Lower is Better)"),(0,i.kt)("p",null,"AOT version performance is ",(0,i.kt)("inlineCode",{parentName:"p"},"1.30 - 12.9")," times that of the commercial version."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"data",src:t(69999).Z,width:"1280",height:"640"})),(0,i.kt)("h2",{id:"principles"},"Principles"),(0,i.kt)("p",null,"Since HybridCLR is implemented in C++ and directly integrates seamlessly with the il2cpp runtime, it can directly access low-level runtime data and various interfaces. Compared to ILRuntime and xlua, it eliminates additional costs at the C# layer, significantly reducing interaction costs."),(0,i.kt)("p",null,"HybridCLR's excellent performance mainly comes from the following aspects:"),(0,i.kt)("h3",{id:"rewritten-streamlined-and-efficient-metadata-parsing-library"},"Rewritten Streamlined and Efficient Metadata Parsing Library"),(0,i.kt)("p",null,"We didn't use existing metadata parsing libraries but implemented a streamlined and efficient C++ metadata parsing library according to HybridCLR's requirements. Other C# hot update or hotfix solutions all use C# libraries like Cecil, resulting in huge differences in memory and loading efficiency!"),(0,i.kt)("h3",{id:"using-register-instruction-set"},"Using Register Instruction Set"),(0,i.kt)("p",null,"Original IL bytecode is a stack-based instruction set. HybridCLR converts it to a register instruction set, reducing stack maintenance overhead."),(0,i.kt)("h3",{id:"direct-access-to-data-stack-and-execution-stack"},"Direct Access to Data Stack and Execution Stack"),(0,i.kt)("p",null,"Stack operations are the most common operations in CLI, with almost all instructions involving stack operations. Since the interpreter stack is self-maintained heap memory, CLI has limitations on struct pointer operations. If implementing an interpreter in C#, you cannot directly operate data types on the interpreter stack and must use various techniques to achieve this indirectly. HybridCLR, being implemented in C++, can operate directly."),(0,i.kt)("p",null,"Operating struct types has several to dozens of times improvement in efficiency compared to other interpreters."),(0,i.kt)("h3",{id:"static-instruction-specialization"},"Static Instruction Specialization"),(0,i.kt)("p",null,"Some instructions like the ",(0,i.kt)("inlineCode",{parentName:"p"},"add")," instruction are multi-functional instructions that decide the final operation based on the operand types on the current stack. HybridCLR designs ",(0,i.kt)("inlineCode",{parentName:"p"},"add_i4, add_i8, add_r4, add_r8")," - these 4 instructions. When translating instructions, it calculates the current stack data types and translates to corresponding specialized instructions. This saves runtime type judgment overhead and runtime data type maintenance overhead."),(0,i.kt)("h3",{id:"pre-calculating-runtime-metadata-that-needs-to-be-resolved"},"Pre-calculating Runtime Metadata that Needs to be Resolved"),(0,i.kt)("p",null,"Some instructions like ldtoken and ldstr need to convert instruction data to actual runtime data at runtime. HybridCLR directly calculates the corresponding runtime data during translation and saves it to the converted instructions, greatly improving performance."),(0,i.kt)("h3",{id:"simple-and-efficient-implementation-of-object-member-access-instructions"},"Simple and Efficient Implementation of Object Member Access Instructions"),(0,i.kt)("p",null,"Object member access instructions like ",(0,i.kt)("inlineCode",{parentName:"p"},"v.x = b;")," are very common. Solutions like ILRuntime and xlua, due to C# language limitations, must operate through wrap function calls. HybridCLR, being implemented in C++, can directly access object memory data. By pre-calculating field offsets in objects, it can complete this access operation directly with ",(0,i.kt)("inlineCode",{parentName:"p"},"*(int32_t*)(obj + offset) = b;"),"."),(0,i.kt)("p",null,"This provides dozens of times efficiency improvement compared to other hot update solutions."),(0,i.kt)("h3",{id:"direct-support-for-reference-and-pointer-operations-without-indirect-methods"},"Direct Support for Reference and Pointer Operations Without Indirect Methods"),(0,i.kt)("p",null,"Due to CLI specification limitations, references in C# can only be placed on the managed stack, not stored on the interpreter stack (because it's heap memory). To handle code like ",(0,i.kt)("inlineCode",{parentName:"p"},"ref int a = ref b; a = 5;"),", very complex techniques must be used to indirectly maintain this reference. HybridCLR, implemented in C++, can directly save and operate on this data."),(0,i.kt)("p",null,"Efficiency is greatly improved compared to other hot update solutions."),(0,i.kt)("h3",{id:"unified-metadata-more-efficient-object-creation-and-smaller-memory-usage"},"Unified Metadata, More Efficient Object Creation, and Smaller Memory Usage"),(0,i.kt)("p",null,"Due to unified metadata, il2cpp::vm::Object::New can be called directly to create objects, with efficiency very close to native and identical memory usage. In contrast, other hot update solutions use fake types with bloated objects and more complex object creation processes."),(0,i.kt)("p",null,"Efficiency is greatly improved compared to other hot update solutions."),(0,i.kt)("h3",{id:"unified-metadata-unified-function-call-methods-and-no-additional-pinvoke-and-reversepinvoke-overhead"},"Unified Metadata, Unified Function Call Methods, and No Additional PInvoke and ReversePInvoke Overhead"),(0,i.kt)("p",null,"HybridCLR can directly call C++ functions translated from IL functions without any intermediate steps, while ILRuntime and xlua require various complex determinations and parameter conversions, plus additional overhead from PInvoke and ReversePInvoke between C#."),(0,i.kt)("p",null,"HybridCLR's interaction with il2cpp AOT parts is extremely lightweight and efficient. Performance issues are no longer a concern."),(0,i.kt)("h3",{id:"additional-provision-of-numerous-intrinsic-functions"},"Additional Provision of Numerous Intrinsic Functions"),(0,i.kt)("p",null,"For common operations like ",(0,i.kt)("inlineCode",{parentName:"p"},"new Vector{2,3,4}"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"new string()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Nullable<T>.Value"),", etc., we directly provide corresponding instructions with runtime overhead even lower than AOT implementations."),(0,i.kt)("p",null,"This provides dozens of times efficiency improvement compared to other hot update solutions."),(0,i.kt)("h3",{id:"strict-compliance-with-specifications-no-unnecessary-additional-costs"},"Strict Compliance with Specifications, No Unnecessary Additional Costs"),(0,i.kt)("p",null,"Through careful design and optimization, HybridCLR avoids various unnecessary overhead. For example, GC during execution is completely identical to native il2cpp and mono."),(0,i.kt)("h3",{id:"other-instruction-optimization-techniques"},"Other Instruction Optimization Techniques"),(0,i.kt)("p",null,"Other optimization techniques"),(0,i.kt)("h2",{id:"appendix-test-case-code"},"Appendix: Test Case Code"),(0,i.kt)("h3",{id:"commercial-version-vs-xlua"},"Commercial Version vs xlua"),(0,i.kt)(r.Z,{mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"HybridCLR",label:"HybridCLR",default:!0,mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'\n    public class AOTForCallFunctions\n    {\n        public void Empty()\n        {\n\n        }\n\n        public int ReturnInt()\n        {\n            return 0;\n        }\n\n        public Vector3 ReturnVector3()\n        {\n            return default;\n        }\n\n        public void Func1(int a, int b, int c, int d, int e)\n        {\n        }\n\n        public void Func2(Vector3 a, Vector3 b, Vector3 c, Vector3 d)\n        {\n\n        }\n    }\n\npublic class BenchmarkTestCases\n{\n    public const int kTestCount = 10000;\n\n    /// <summary>\n    /// Test simple numerical computation\n    /// </summary>\n    /// <param name="n"></param>\n    /// <returns></returns>\n    [Benchmark]\n    [Params(kTestCount * 100)]\n    public int BinOpAdd(int n)\n    {\n        int a = 1;\n        int b = n;\n        int c = 2;\n        int d = n;\n\n        for (int i = 0; i < n; i++)\n        {\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n        }\n        return a + b + c + d;\n    }\n\n    /// <summary>\n    /// Test complex numerical computation\n    /// </summary>\n    /// <param name="cnt"></param>\n    [Benchmark]\n    [Params(kTestCount * 100)]\n    public void BinOpComplex(int cnt)\n    {\n        int total = 0;\n        for (int i = 0; i < cnt; i++)\n        {\n            total = total + i - (i - 2) * (i + 3);\n            total = total + i - (i - 2) * (i + 3);\n            total = total + i - (i - 2) * (i + 3);\n            total = total + i - (i - 2) * (i + 3);\n            total = total + i - (i - 2) * (i + 3);\n\n            total = total + i - (i - 2) * (i + 3);\n            total = total + i - (i - 2) * (i + 3);\n            total = total + i - (i - 2) * (i + 3);\n            total = total + i - (i - 2) * (i + 3);\n            total = total + i - (i - 2) * (i + 3);\n        }\n    }\n\n    /// <summary>\n    /// Test array operations\n    /// </summary>\n    /// <param name="cnt"></param>\n    [Benchmark]\n    [Params(kTestCount * 100)]\n    public int ArrayOp(int cnt)\n    {\n        var arr = new int[100];\n        int k = cnt % 100 + 1;\n        for (int i = 0; i < cnt; i++)\n        {\n            arr[k] = arr[k] + i;\n            arr[k] = arr[k] + i;\n            arr[k] = arr[k] + i;\n            arr[k] = arr[k] + i;\n            arr[k] = arr[k] + i;\n            arr[k] = arr[k] + i;\n            arr[k] = arr[k] + i;\n            arr[k] = arr[k] + i;\n            arr[k] = arr[k] + i;\n            arr[k] = arr[k] + i;\n        }\n        return arr[0];\n    }\n\n    /// <summary>\n    /// Test Vector3 operations\n    /// </summary>\n    /// <param name="cnt"></param>\n    /// <returns></returns>\n    [Benchmark]\n    [Params(kTestCount * 10)]\n    public int VectorOp1(int cnt)\n    {\n        float m = 0f;\n        var v = Vector3.one;\n        for (var i = 0; i < cnt; i++)\n        {\n            m = v.sqrMagnitude;\n            m = v.sqrMagnitude;\n            m = v.sqrMagnitude;\n            m = v.sqrMagnitude;\n            m = v.sqrMagnitude;\n\n            m = v.sqrMagnitude;\n            m = v.sqrMagnitude;\n            m = v.sqrMagnitude;\n            m = v.sqrMagnitude;\n            m = v.sqrMagnitude;\n        }\n        return (int)m;\n    }\n\n    [Benchmark]\n    [Params(kTestCount * 10)]\n    public int VectorOp2(int cnt)\n    {\n        Vector3 c = default;\n        var a = new Vector3(1, 2, 3);\n        var b = new Vector3(4, 5, 6);\n        for (var i = 0; i < cnt; i++)\n        {\n            c = c + a;\n            c = c + b;\n            c = c + a;\n            c = c + b;\n            c = c + a;\n\n            c = c + b;\n            c = c + a;\n            c = c + b;\n            c = c + a;\n            c = c + b;\n        }\n        return (int)c.x;\n    }\n\n    /// <summary>\n    /// Test Quaternion operations\n    /// </summary>\n    /// <param name="cnt"></param>\n    /// <returns></returns>\n    [Benchmark]\n    [Params(kTestCount * 10)]\n    public int QuaternionOp(int cnt)\n    {\n        for (var i = 0; i < cnt; i++)\n        {\n            var q1 = Quaternion.Euler(i, i, i);\n            var q2 = Quaternion.Slerp(Quaternion.identity, q1, 0.5f);\n            var q3 = q2.normalized;\n            var q4 = Quaternion.Lerp(q3, q2, 0.5f);\n        }\n        return 0;\n    }\n\n    /// <summary>\n    /// Test calling AOT static member function\n    /// </summary>\n    /// <param name="cnt"></param>\n    /// <returns></returns>\n    [Benchmark]\n    [Params(kTestCount * 10)]\n    public int CallAOTStaticMethod(int cnt)\n    {\n        float t = 0f;\n        for (var i = 0; i < cnt; i++)\n        {\n            t = Time.deltaTime;\n            t = Time.deltaTime;\n            t = Time.deltaTime;\n            t = Time.deltaTime;\n            t = Time.deltaTime;\n\n            t = Time.deltaTime;\n            t = Time.deltaTime;\n            t = Time.deltaTime;\n            t = Time.deltaTime;\n            t = Time.deltaTime;\n        }\n\n        return (int)t;\n    }\n\n    /// <summary>\n    /// Test calling AOT instance member function with int type parameter\n    /// </summary>\n    /// <param name="cnt"></param>\n    /// <returns></returns>\n    [Benchmark]\n    [Params(kTestCount * 10)]\n    public int CallAOTInstanceMethodParamInt(int cnt)\n    {\n        var o = new AOTForCallFunctions();\n        int x = 0;\n        for (var i = 0; i < cnt; i++)\n        {\n            o.Func1(1, 2, 3, 4, 5);\n            o.Func1(1, 2, 3, 4, 5);\n            o.Func1(1, 2, 3, 4, 5);\n            o.Func1(1, 2, 3, 4, 5);\n            o.Func1(1, 2, 3, 4, 5);\n            o.Func1(1, 2, 3, 4, 5);\n            o.Func1(1, 2, 3, 4, 5);\n            o.Func1(1, 2, 3, 4, 5);\n            o.Func1(1, 2, 3, 4, 5);\n            o.Func1(1, 2, 3, 4, 5);\n        }\n        return x + 1;\n    }\n\n    /// <summary>\n    /// Test calling AOT instance member function with Vector3 type parameter\n    /// </summary>\n    /// <param name="cnt"></param>\n    /// <returns></returns>\n    [Benchmark]\n    [Params(kTestCount * 10)]\n    public int CallAOTInstanceMethodParamVector3(int cnt)\n    {\n        var o = new AOTForCallFunctions();\n        Vector3 a = Vector3.one;\n        Vector3 b = Vector3.one;\n        for (var i = 0; i < cnt; i++)\n        {\n            o.Func2(a, b, a, b);\n            o.Func2(a, b, a, b);\n            o.Func2(a, b, a, b);\n            o.Func2(a, b, a, b);\n            o.Func2(a, b, a, b);\n            o.Func2(a, b, a, b);\n            o.Func2(a, b, a, b);\n            o.Func2(a, b, a, b);\n            o.Func2(a, b, a, b);\n            o.Func2(a, b, a, b);\n        }\n        return 0;\n    }\n\n    /// <summary>\n    /// Test calling AOT instance member function, return type is int\n    /// </summary>\n    /// <param name="cnt"></param>\n    /// <returns></returns>\n    [Benchmark]\n    [Params(kTestCount * 10)]\n    public int CallAOTInstanceMethodReturn1(int cnt)\n    {\n        var o = new AOTForCallFunctions();\n        int x = 0;\n        for (var i = 0; i < cnt; i++)\n        {\n            x = o.ReturnInt();\n            x = o.ReturnInt();\n            x = o.ReturnInt();\n            x = o.ReturnInt();\n            x = o.ReturnInt();\n\n            x = o.ReturnInt();\n            x = o.ReturnInt();\n            x = o.ReturnInt();\n            x = o.ReturnInt();\n            x = o.ReturnInt();\n        }\n        return x + 1;\n    }\n\n    /// <summary>\n    /// Test calling AOT instance member function, return type is Vector3\n    /// </summary>\n    /// <param name="cnt"></param>\n    /// <returns></returns>\n    [Benchmark]\n    [Params(kTestCount * 10)]\n    public int CallAOTInstanceMethodReturnVector3(int cnt)\n    {\n        var o = new AOTForCallFunctions();\n        Vector3 x = default;\n        for (var i = 0; i < cnt; i++)\n        {\n            x = o.ReturnVector3();\n            x = o.ReturnVector3();\n            x = o.ReturnVector3();\n            x = o.ReturnVector3();\n            x = o.ReturnVector3();\n\n            x = o.ReturnVector3();\n            x = o.ReturnVector3();\n            x = o.ReturnVector3();\n            x = o.ReturnVector3();\n            x = o.ReturnVector3();\n        }\n        return (int)x.x;\n    }\n\n    /// <summary>\n    /// Test GameObject creation and destruction operations\n    /// </summary>\n    /// <param name="cnt"></param>\n    [Benchmark]\n    [Params(kTestCount)]\n    public void GameObjectCreateAndDestroy(int cnt)\n    {\n        for (var i = 0; i < cnt; i++)\n        {\n            var go = new GameObject("t");\n            Object.Destroy(go);\n        }\n    }\n\n    /// <summary>\n    /// Test Transform operations\n    /// </summary>\n    /// <param name="cnt"></param>\n    [Benchmark]\n    [Params(kTestCount * 10)]\n    public void SetTransformPosition(int cnt)\n    {\n        var go = new GameObject();\n        Vector3 v = Vector3.one;\n        for (var i = 0; i < cnt; i++)\n        {\n            go.transform.position = v;\n            go.transform.position = v;\n            go.transform.position = v;\n            go.transform.position = v;\n            go.transform.position = v;\n\n            go.transform.position = v;\n            go.transform.position = v;\n            go.transform.position = v;\n            go.transform.position = v;\n            go.transform.position = v;\n        }\n        Object.Destroy(go);\n    }\n}\n'))),(0,i.kt)(o.Z,{value:"xlua",label:"xlua",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'\nfunction BinOpAdd(cnt)\n    local a = 1;\n    local b = cnt;\n    local c = cnt;\n    local d = cnt;\n\n    for i = 1, cnt do\n        a = b + c;\n        b = c + d;\n        c = d + a;\n        d = a + b;\n        a = b + c;\n        b = c + d;\n        c = d + a;\n        d = a + b;\n        a = b + c;\n        b = c + d;\n        c = d + a;\n        d = a + b;\n        a = b + c;\n        b = c + d;\n        c = d + a;\n        d = a + b;\n        a = b + c;\n        b = c + d;\n        c = d + a;\n        d = a + b;\n    end\n    return a + b + c + d\nend\n\nfunction BinOpComplex(cnt)\n    local total = 0;\n    for i = 1, cnt do \n \n        total = total + i - (i - 2) * (i + 3);\n        total = total + i - (i - 2) * (i + 3);\n        total = total + i - (i - 2) * (i + 3);\n        total = total + i - (i - 2) * (i + 3);\n        total = total + i - (i - 2) * (i + 3);\n\n        total = total + i - (i - 2) * (i + 3);\n        total = total + i - (i - 2) * (i + 3);\n        total = total + i - (i - 2) * (i + 3);\n        total = total + i - (i - 2) * (i + 3);\n        total = total + i - (i - 2) * (i + 3);\n    end\n    return total\nend\n\nfunction ArrayOp(cnt)\n    local arr = {}\n    for i = 0, 100 do \n        arr[i] = 0\n    end\n    local k = cnt % 100 + 1;\n\n    for i = 1, cnt do\n        arr[k] = arr[k] + i;\n        arr[k] = arr[k] + i;\n        arr[k] = arr[k] + i;\n        arr[k] = arr[k] + i;\n        arr[k] = arr[k] + i;\n        arr[k] = arr[k] + i;\n        arr[k] = arr[k] + i;\n        arr[k] = arr[k] + i;\n        arr[k] = arr[k] + i;\n        arr[k] = arr[k] + i;\n    end\n    return arr[0]\nend\n\nfunction VectorOp1(cnt)\n    local m = 0\n    local v = CS.UnityEngine.Vector3.one;\n    for i = 1, cnt do\n        m = v.sqrMagnitude;\n        m = v.sqrMagnitude;\n        m = v.sqrMagnitude;\n        m = v.sqrMagnitude;\n        m = v.sqrMagnitude;\n\n        m = v.sqrMagnitude;\n        m = v.sqrMagnitude;\n        m = v.sqrMagnitude;\n        m = v.sqrMagnitude;\n        m = v.sqrMagnitude;\n    end\n    return m;\nend\n\nfunction VectorOp2(cnt)\n    local c = CS.UnityEngine.Vector3.one;\n    local a = CS.UnityEngine.Vector3(1, 2, 3);\n    local b = CS.UnityEngine.Vector3(4, 5, 6);\n    for i = 1, cnt do\n        c = c + a;\n        c = c + b;\n        c = c + a;\n        c = c + b;\n        c = c + a;\n\n        c = c + b;\n        c = c + a;\n        c = c + b;\n        c = c + a;\n        c = c + b;\n    end\n    return c.x\nend\n\nlocal Quaternion = CS.UnityEngine.Quaternion\n\nfunction QuaternionOp(cnt)\n    for i = 1, cnt do\n        local q1 = Quaternion.Euler(i, i, i);\n        local q2 = Quaternion.Slerp(Quaternion.identity, q1, 0.5);\n        local q3 = q2.normalized;\n        local q4 = Quaternion.Lerp(q3, q2, 0.5);\n    end\n    return 0;\nend\n\nfunction CallAOTStaticMethod(cnt)\n    local Time = CS.UnityEngine.Time\n    local t \n    for i = 1, cnt do \n        t = Time.deltaTime\n    end\n    return t\nend\n\nfunction CallAOTInstanceMethodParamInt(cnt)\n    local o = CS.AOTTypes.AOTForCallFunctions();\n    for i = 1, cnt do\n        o:Func1(1, 2, 3, 4, 5);\n        o:Func1(1, 2, 3, 4, 5);\n        o:Func1(1, 2, 3, 4, 5);\n        o:Func1(1, 2, 3, 4, 5);\n        o:Func1(1, 2, 3, 4, 5);\n        \n        o:Func1(1, 2, 3, 4, 5);\n        o:Func1(1, 2, 3, 4, 5);\n        o:Func1(1, 2, 3, 4, 5);\n        o:Func1(1, 2, 3, 4, 5);\n        o:Func1(1, 2, 3, 4, 5);\n    end\nend\n\nfunction CallAOTInstanceMethodParamVector3(cnt)\n    local o = CS.AOTTypes.AOTForCallFunctions();\n    local a = CS.UnityEngine.Vector3.one;\n    local b = CS.UnityEngine.Vector3.one;\n    for i = 1, cnt do\n        o:Func2(a, b, a, b)\n        o:Func2(a, b, a, b)\n        o:Func2(a, b, a, b)\n        o:Func2(a, b, a, b)\n        o:Func2(a, b, a, b)\n\n        o:Func2(a, b, a, b)\n        o:Func2(a, b, a, b)\n        o:Func2(a, b, a, b)\n        o:Func2(a, b, a, b)\n        o:Func2(a, b, a, b)\n    end\nend\n\nfunction CallAOTInstanceMethodReturn1(cnt)\n    local o = CS.AOTTypes.AOTForCallFunctions();\n    local x = 0;\n    for i = 1, cnt do \n        x = o:ReturnInt();\n        x = o:ReturnInt();\n        x = o:ReturnInt();\n        x = o:ReturnInt();\n        x = o:ReturnInt();\n\n        x = o:ReturnInt();\n        x = o:ReturnInt();\n        x = o:ReturnInt();\n        x = o:ReturnInt();\n        x = o:ReturnInt();\n    end\n    return x + 1;\nend\n\nfunction CallAOTInstanceMethodReturnVector3(cnt)\n    local o = CS.AOTTypes.AOTForCallFunctions();\n    local x \n    for i = 1, cnt do \n        x = o:ReturnVector3();\n        x = o:ReturnVector3();\n        x = o:ReturnVector3();\n        x = o:ReturnVector3();\n        x = o:ReturnVector3();\n\n        x = o:ReturnVector3();\n        x = o:ReturnVector3();\n        x = o:ReturnVector3();\n        x = o:ReturnVector3();\n        x = o:ReturnVector3();\n    end\n    return x;\nend\n\nfunction GameObjectCreateAndDestroy(cnt)\n    for i = 1, cnt do \n        local go = CS.UnityEngine.GameObject("t")\n        CS.UnityEngine.Object.Destroy(go)\n    end\nend\n\nfunction SetTransformPosition(cnt)\n    local go = CS.UnityEngine.GameObject("t")\n    local v = CS.UnityEngine.Vector3.one;\n    for i = 1, cnt do \n        go.transform.position = v;\n        go.transform.position = v;\n        go.transform.position = v;\n        go.transform.position = v;\n        go.transform.position = v;\n\n        go.transform.position = v;\n        go.transform.position = v;\n        go.transform.position = v;\n        go.transform.position = v;\n        go.transform.position = v;\n    end\n    CS.UnityEngine.Object.Destroy(go)\nend\n\n')))),(0,i.kt)("h3",{id:"aot-vs-community-edition-vs-commercial-edition-vs-mono"},"AOT vs Community Edition vs Commercial Edition vs Mono"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public class LongArithmetics\n{\n    [Benchmark]\n    [Params(1000000)]\n    public long add_1(long n)\n    {\n        long a = 1;\n        long b = n;\n        long c = 2;\n        long d = n;\n        \n        for(long i = 0; i < n; i++)\n        {\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n        }\n        return a + b + c + d;\n    }\n\n\n    [Benchmark]\n    [Params(1000000)]\n    public long add_2(long n)\n    {\n        long a = 1;\n        long b = n;\n        long c = 2;\n        long d = n;\n        long e = 3;\n\n        for (long i = 0; i < n; i++)\n        {\n            a = b + c + d + e;\n            b = c + d + e + a;\n            c = d + e + a + b;\n            d = e + a + b + c;\n            e = a + b + c + d;\n            a = b + c + d + e;\n            b = c + d + e + a;\n            c = d + e + a + b;\n            d = e + a + b + c;\n            e = a + b + c + d;\n            a = b + c + d + e;\n            b = c + d + e + a;\n            c = d + e + a + b;\n            d = e + a + b + c;\n            e = a + b + c + d;\n            a = b + c + d + e;\n            b = c + d + e + a;\n            c = d + e + a + b;\n            d = e + a + b + c;\n            e = a + b + c + d;\n        }\n        return a + b + c + d;\n    }\n\n\n    [Benchmark]\n    [Params(1000000)]\n    public long mul_1(long n)\n    {\n        long a = 1;\n        long b = n;\n        long c = 2;\n        long d = n;\n\n        for (long i = 0; i < n; i++)\n        {\n            a = b * c;\n            b = c * d;\n            c = d * a;\n            d = a * b;\n            a = b * c;\n            b = c * d;\n            c = d * a;\n            d = a * b;\n            a = b * c;\n            b = c * d;\n            c = d * a;\n            d = a * b;\n            a = b * c;\n            b = c * d;\n            c = d * a;\n            d = a * b;\n            a = b * c;\n            b = c * d;\n            c = d * a;\n            d = a * b;\n        }\n        return a + b + c + d;\n    }\n\n\n    [Benchmark]\n    [Params(1000000)]\n    public long mul_2(long n)\n    {\n        long a = 1;\n        long b = n;\n        long c = 2;\n        long d = n;\n        long e = 3;\n\n        for (long i = 0; i < n; i++)\n        {\n            a = b * c * d * e;\n            b = c * d * e * a;\n            c = d * e * a * b;\n            d = e * a * b * c;\n            e = a * b * c * d;\n            a = b * c * d * e;\n            b = c * d * e * a;\n            c = d * e * a * b;\n            d = e * a * b * c;\n            e = a * b * c * d;\n            a = b * c * d * e;\n            b = c * d * e * a;\n            c = d * e * a * b;\n            d = e * a * b * c;\n            e = a * b * c * d;\n            a = b * c * d * e;\n            b = c * d * e * a;\n            c = d * e * a * b;\n            d = e * a * b * c;\n            e = a * b * c * d;\n        }\n        return a + b + c + d;\n    }\n\n\n    [Benchmark]\n    [Params(1000000)]\n    public long div_1(long n)\n    {\n        long a = 1;\n        long b = n;\n        long c = 2;\n        long d = n;\n\n        for (long i = 0; i < n; i++)\n        {\n            b = c / a;\n            c = d / a;\n            d = b / a;\n\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            a = a / n + 1;\n        }\n        return a + b + c + d;\n    }\n\n\n    public class IntArithmetics\n{\n    [Benchmark]\n    [Params(1000000)]\n    public int add_1(int n)\n    {\n        int a = 1;\n        int b = n;\n        int c = 2;\n        int d = n;\n        \n        for(int i = 0; i < n; i++)\n        {\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n        }\n        return a + b + c + d;\n    }\n\n\n    [Benchmark]\n    [Params(1000000)]\n    public int add_2(int n)\n    {\n        int a = 1;\n        int b = n;\n        int c = 2;\n        int d = n;\n        int e = 3;\n\n        for (int i = 0; i < n; i++)\n        {\n            a = b + c + d + e;\n            b = c + d + e + a;\n            c = d + e + a + b;\n            d = e + a + b + c;\n            e = a + b + c + d;\n            a = b + c + d + e;\n            b = c + d + e + a;\n            c = d + e + a + b;\n            d = e + a + b + c;\n            e = a + b + c + d;\n            a = b + c + d + e;\n            b = c + d + e + a;\n            c = d + e + a + b;\n            d = e + a + b + c;\n            e = a + b + c + d;\n            a = b + c + d + e;\n            b = c + d + e + a;\n            c = d + e + a + b;\n            d = e + a + b + c;\n            e = a + b + c + d;\n        }\n        return a + b + c + d;\n    }\n\n\n    [Benchmark]\n    [Params(1000000)]\n    public int mul_1(int n)\n    {\n        int a = 1;\n        int b = n;\n        int c = 2;\n        int d = n;\n\n        for (int i = 0; i < n; i++)\n        {\n            a = b * c;\n            b = c * d;\n            c = d * a;\n            d = a * b;\n            a = b * c;\n            b = c * d;\n            c = d * a;\n            d = a * b;\n            a = b * c;\n            b = c * d;\n            c = d * a;\n            d = a * b;\n            a = b * c;\n            b = c * d;\n            c = d * a;\n            d = a * b;\n            a = b * c;\n            b = c * d;\n            c = d * a;\n            d = a * b;\n        }\n        return a + b + c + d;\n    }\n\n\n    [Benchmark]\n    [Params(1000000)]\n    public int mul_2(int n)\n    {\n        int a = 1;\n        int b = n;\n        int c = 2;\n        int d = n;\n        int e = 3;\n\n        for (int i = 0; i < n; i++)\n        {\n            a = b * c * d * e;\n            b = c * d * e * a;\n            c = d * e * a * b;\n            d = e * a * b * c;\n            e = a * b * c * d;\n            a = b * c * d * e;\n            b = c * d * e * a;\n            c = d * e * a * b;\n            d = e * a * b * c;\n            e = a * b * c * d;\n            a = b * c * d * e;\n            b = c * d * e * a;\n            c = d * e * a * b;\n            d = e * a * b * c;\n            e = a * b * c * d;\n            a = b * c * d * e;\n            b = c * d * e * a;\n            c = d * e * a * b;\n            d = e * a * b * c;\n            e = a * b * c * d;\n        }\n        return a + b + c + d;\n    }\n\n\n    [Benchmark]\n    [Params(1000000)]\n    public int div_1(int n)\n    {\n        int a = 1;\n        int b = n;\n        int c = 2;\n        int d = n;\n\n        for (int i = 0; i < n; i++)\n        {\n            b = c / a;\n            c = d / a;\n            d = b / a;\n\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            a = a / n + 1;\n        }\n        return a + b + c + d;\n    }\n}\n\npublic class FloatArithmetics\n{\n    [Benchmark]\n    [Params(1000000)]\n    public float add_1(int n)\n    {\n        float a = 1;\n        float b = n;\n        float c = 2;\n        float d = n;\n        \n        for(int i = 0; i < n; i++)\n        {\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n        }\n        return a + b + c + d;\n    }\n\n\n    [Benchmark]\n    [Params(1000000)]\n    public float add_2(int n)\n    {\n        float a = 1;\n        float b = n;\n        float c = 2;\n        float d = n;\n        float e = 3;\n\n        for (int i = 0; i < n; i++)\n        {\n            a = b + c + d + e;\n            b = c + d + e + a;\n            c = d + e + a + b;\n            d = e + a + b + c;\n            e = a + b + c + d;\n            a = b + c + d + e;\n            b = c + d + e + a;\n            c = d + e + a + b;\n            d = e + a + b + c;\n            e = a + b + c + d;\n            a = b + c + d + e;\n            b = c + d + e + a;\n            c = d + e + a + b;\n            d = e + a + b + c;\n            e = a + b + c + d;\n            a = b + c + d + e;\n            b = c + d + e + a;\n            c = d + e + a + b;\n            d = e + a + b + c;\n            e = a + b + c + d;\n        }\n        return a + b + c + d;\n    }\n\n\n    [Benchmark]\n    [Params(1000000)]\n    public float mul_1(int n)\n    {\n        float a = 1;\n        float b = n;\n        float c = 2;\n        float d = n;\n\n        for (int i = 0; i < n; i++)\n        {\n            a = b * c;\n            b = c * d;\n            c = d * a;\n            d = a * b;\n            a = b * c;\n            b = c * d;\n            c = d * a;\n            d = a * b;\n            a = b * c;\n            b = c * d;\n            c = d * a;\n            d = a * b;\n            a = b * c;\n            b = c * d;\n            c = d * a;\n            d = a * b;\n            a = b * c;\n            b = c * d;\n            c = d * a;\n            d = a * b;\n        }\n        return a + b + c + d;\n    }\n\n\n    [Benchmark]\n    [Params(1000000)]\n    public float mul_2(int n)\n    {\n        float a = 1;\n        float b = n;\n        float c = 2;\n        float d = n;\n        float e = 3;\n\n        for (int i = 0; i < n; i++)\n        {\n            a = b * c * d * e;\n            b = c * d * e * a;\n            c = d * e * a * b;\n            d = e * a * b * c;\n            e = a * b * c * d;\n            a = b * c * d * e;\n            b = c * d * e * a;\n            c = d * e * a * b;\n            d = e * a * b * c;\n            e = a * b * c * d;\n            a = b * c * d * e;\n            b = c * d * e * a;\n            c = d * e * a * b;\n            d = e * a * b * c;\n            e = a * b * c * d;\n            a = b * c * d * e;\n            b = c * d * e * a;\n            c = d * e * a * b;\n            d = e * a * b * c;\n            e = a * b * c * d;\n        }\n        return a + b + c + d;\n    }\n\n\n    [Benchmark]\n    [Params(1000000)]\n    public float div_1(int n)\n    {\n        float a = 1;\n        float b = n;\n        float c = 2;\n        float d = n;\n\n        for (int i = 0; i < n; i++)\n        {\n            b = c / a;\n            c = d / a;\n            d = b / a;\n\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            a = a / n + 1;\n        }\n        return a + b + c + d;\n    }\n}\n\npublic class DoubleArithmetics\n{\n    [Benchmark]\n    [Params(1000000)]\n    public double add_1(int n)\n    {\n        double a = 1;\n        double b = n;\n        double c = 2;\n        double d = n;\n\n        for (int i = 0; i < n; i++)\n        {\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n            a = b + c;\n            b = c + d;\n            c = d + a;\n            d = a + b;\n        }\n        return a + b + c + d;\n    }\n\n\n    [Benchmark]\n    [Params(1000000)]\n    public double add_2(int n)\n    {\n        double a = 1;\n        double b = n;\n        double c = 2;\n        double d = n;\n        double e = 3;\n\n        for (int i = 0; i < n; i++)\n        {\n            a = b + c + d + e;\n            b = c + d + e + a;\n            c = d + e + a + b;\n            d = e + a + b + c;\n            e = a + b + c + d;\n            a = b + c + d + e;\n            b = c + d + e + a;\n            c = d + e + a + b;\n            d = e + a + b + c;\n            e = a + b + c + d;\n            a = b + c + d + e;\n            b = c + d + e + a;\n            c = d + e + a + b;\n            d = e + a + b + c;\n            e = a + b + c + d;\n            a = b + c + d + e;\n            b = c + d + e + a;\n            c = d + e + a + b;\n            d = e + a + b + c;\n            e = a + b + c + d;\n        }\n        return a + b + c + d;\n    }\n\n\n    [Benchmark]\n    [Params(1000000)]\n    public double mul_1(int n)\n    {\n        double a = 1;\n        double b = n;\n        double c = 2;\n        double d = n;\n\n        for (int i = 0; i < n; i++)\n        {\n            a = b * c;\n            b = c * d;\n            c = d * a;\n            d = a * b;\n            a = b * c;\n            b = c * d;\n            c = d * a;\n            d = a * b;\n            a = b * c;\n            b = c * d;\n            c = d * a;\n            d = a * b;\n            a = b * c;\n            b = c * d;\n            c = d * a;\n            d = a * b;\n            a = b * c;\n            b = c * d;\n            c = d * a;\n            d = a * b;\n        }\n        return a + b + c + d;\n    }\n\n\n    [Benchmark]\n    [Params(1000000)]\n    public double mul_2(int n)\n    {\n        double a = 1;\n        double b = n;\n        double c = 2;\n        double d = n;\n        double e = 3;\n\n        for (int i = 0; i < n; i++)\n        {\n            a = b * c * d * e;\n            b = c * d * e * a;\n            c = d * e * a * b;\n            d = e * a * b * c;\n            e = a * b * c * d;\n            a = b * c * d * e;\n            b = c * d * e * a;\n            c = d * e * a * b;\n            d = e * a * b * c;\n            e = a * b * c * d;\n            a = b * c * d * e;\n            b = c * d * e * a;\n            c = d * e * a * b;\n            d = e * a * b * c;\n            e = a * b * c * d;\n            a = b * c * d * e;\n            b = c * d * e * a;\n            c = d * e * a * b;\n            d = e * a * b * c;\n            e = a * b * c * d;\n        }\n        return a + b + c + d;\n    }\n\n\n    [Benchmark]\n    [Params(1000000)]\n    public double div_1(int n)\n    {\n        double a = 1;\n        double b = n;\n        double c = 2;\n        double d = n;\n\n        for (int i = 0; i < n; i++)\n        {\n            b = c / a;\n            c = d / a;\n            d = b / a;\n\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            b = c / a;\n            c = d / a;\n            d = b / a;\n            a = a / n + 1;\n        }\n        return a + b + c + d;\n    }\n}\n\n")))}p.isMDXComponent=!0},71024:(n,e,t)=>{t.d(e,{Z:()=>a});const a=t.p+"assets/images/full_hybridclr_div_xlua-143177a79ae1387193eb9ccfb6b3cd86.jpg"},87860:(n,e,t)=>{t.d(e,{Z:()=>a});const a=t.p+"assets/images/full_hybridclr_vs_xlua-9d0605aaf28538ae1823e04d7723bd70.jpg"},31332:(n,e,t)=>{t.d(e,{Z:()=>a});const a=t.p+"assets/images/hybridclr_div_mono-1a9330b1df4890c97c1c78d1ad98095f.png"},67355:(n,e,t)=>{t.d(e,{Z:()=>a});const a=t.p+"assets/images/hybridclr_vs_mono-ee3f541d15750f28d09fb5a8c752b5cb.png"},39446:(n,e,t)=>{t.d(e,{Z:()=>a});const a=t.p+"assets/images/numeric_business_vs_aot_div_aot-5f9d5d52b2dd791d61ef588be2f6e1e4.jpg"},5108:(n,e,t)=>{t.d(e,{Z:()=>a});const a=t.p+"assets/images/numeric_datas-c7e623fb0136033a877678da6376da41.jpg"},69999:(n,e,t)=>{t.d(e,{Z:()=>a});const a=t.p+"assets/images/numeric_dialog_business_div_aot-44e9b55446d50bceb8b332085d55387f.jpg"},59672:(n,e,t)=>{t.d(e,{Z:()=>a});const a=t.p+"assets/images/numeric_dialog_business_div_community-e02edc41129f5859b800a362c8b91bc8.jpg"}}]);