"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5677],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),u=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(p.Provider,{value:t},e.children)},s="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),s=u(n),h=a,m=s["".concat(p,".").concat(h)]||s[h]||d[h]||o;return n?r.createElement(m,i(i({ref:t},c),{},{components:n})):r.createElement(m,i({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=h;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[s]="string"==typeof e?e:a,i[1]=l;for(var u=2;u<o;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},4571:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var r=n(7462),a=(n(7294),n(3905));const o={},i="HybridCLR+lua/js/python",l={unversionedId:"advanced/workwithscriptlanguage",id:"advanced/workwithscriptlanguage",title:"HybridCLR+lua/js/python",description:"Some projects have already been launched, and most of their codes have been implemented in lua; or some new projects have been developed in lua, and they cannot completely switch to full C# development, but hope",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/advanced/workwithscriptlanguage.md",sourceDirName:"advanced",slug:"/advanced/workwithscriptlanguage",permalink:"/en/docs/advanced/workwithscriptlanguage",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Differential Hybrid Execution",permalink:"/en/docs/advanced/differentialhybridexecution"},next:{title:"HotReload hot reload technology",permalink:"/en/docs/advanced/hotreloadassembly"}},p={},u=[{value:"xlua",id:"xlua",level:2},{value:"tolua, slua, puerts",id:"tolua-slua-puerts",level:2},{value:"MonoPInvokeCallbackAttribute support",id:"monopinvokecallbackattribute-support",level:2},{value:"Reserved ReversePInvokeWrapper function",id:"reserved-reversepinvokewrapper-function",level:2},{value:"limit",id:"limit",level:2}],c={toc:u},s="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(s,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"hybridclrluajspython"},"HybridCLR+lua/js/python"),(0,a.kt)("p",null,"Some projects have already been launched, and most of their codes have been implemented in lua; or some new projects have been developed in lua, and they cannot completely switch to full C# development, but hope\nIt can be connected to HybridCLR at the same time, helping to gradually transition to all native C# hot updates. Since HybridCLR is a native C# hot update technology, native support works with these scripting languages."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"What you need to do is to generate the hot update wrapper files to the hot update module, and reserve enough ReversePInvoke functions in advance.")),(0,a.kt)("h2",{id:"xlua"},"xlua"),(0,a.kt)("p",null,"xlua has not considered modularization. The generated code is all in the global Assembly-CSharp, and even made into a partial class associated with the Runtime code. Therefore, you may need to make a small adjustment to the generated code of these hot update solutions to cooperate with the hot update. Work."),(0,a.kt)("p",null,"A group of friends have already produced the ",(0,a.kt)("inlineCode",{parentName:"p"},"HybridCLR+xlua")," project ",(0,a.kt)("a",{parentName:"p",href:"https://gitee.com/ldr123/HybridCLRXlua"},"HybridCLRXlua"),", which has run through and improved the workflow. Recommended reference."),(0,a.kt)("h2",{id:"tolua-slua-puerts"},"tolua, slua, puerts"),(0,a.kt)("p",null,"Make sure that enough ReversePInvokeWrapper functions are reserved and the generated wrapper code can be placed in the hot update module and registered correctly."),(0,a.kt)("h2",{id:"monopinvokecallbackattribute-support"},"MonoPInvokeCallbackAttribute support"),(0,a.kt)("p",null,"HybridCLR supports ",(0,a.kt)("inlineCode",{parentName:"p"},"[MonoPInvokeCallbackAttribute]")," exactly as natively. Since each function marked ",(0,a.kt)("inlineCode",{parentName:"p"},"[MonoPInvokeCallbackAttribute]")," must have a unique corresponding c++ function, and AOT restrictions make it impossible to add functions at runtime,\nTherefore, it is necessary to generate a ",(0,a.kt)("inlineCode",{parentName:"p"},"c++ wrapper function")," for each ",(0,a.kt)("inlineCode",{parentName:"p"},"[MonoPInvokeCallbackAttribute]")," function in advance for binding with it. These wrapper functions are in ",(0,a.kt)("inlineCode",{parentName:"p"},"hybridclr/generated/ReversePInvokeMethodStub_{abi}.cpp")," file."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/en/docs/basic/com.code-philosophy.hybridclr"},"com.code-philosophy.hybridclr")," has provided scripts to help automatically generate these wrapper functions, just run the menu command ",(0,a.kt)("inlineCode",{parentName:"p"},"HybridCLR/Generate/ReversePInvokeWrapper"),"."),(0,a.kt)("h2",{id:"reserved-reversepinvokewrapper-function"},"Reserved ReversePInvokeWrapper function"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"HybridCLR/Generate/ReversePInvokeWrapper")," generates a wrapper function for each function with ",(0,a.kt)("inlineCode",{parentName:"p"},"[MonoPInvokeCallbackAttribute]")," by default.\nHowever, if you only generate the same number of wrapper functions as the current functions with the ",(0,a.kt)("inlineCode",{parentName:"p"},"[MonoPInvokeCallbackAttribute]")," feature, the new hot update function will be\nThe problem of insufficient wrapper functions will occur. The solution is to use ",(0,a.kt)("inlineCode",{parentName:"p"},"HybridCLR.ReversePInvokeWrapperGenerationAttribute")," for reserved operations."),(0,a.kt)("p",null,"Add a feature ",(0,a.kt)("inlineCode",{parentName:"p"},"[ReversePInvokeWrapperGeneration(int preserveCount)]")," to the function with ",(0,a.kt)("inlineCode",{parentName:"p"},"MonoPInvokeCallbackAttribute"),", then generate preserveCount wrapper functions for functions with ",(0,a.kt)("strong",{parentName:"p"},"this signature"),". If this attribute is not included, it will only be generated for this function\nA wrapper function. If the ",(0,a.kt)("inlineCode",{parentName:"p"},"[ReversePInvokeWrapperGeneration(xx)]")," attribute is added to multiple functions with the same signature, the total number of wrapper functions is ",(0,a.kt)("inlineCode",{parentName:"p"},"the sum of all preserveCount + the number of functions that do not contain the ReversePInvokeWrapperGenerationAttribute attribute"),"."),(0,a.kt)("p",null,"As shown below, there are 10 wrappers of type ",(0,a.kt)("inlineCode",{parentName:"p"},"LuaFunction"),", 101 wrappers of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Func<int, int, int>"),", and 1 wrapper of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Func<int, int>"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"\ndelegate int LuaFunction(IntPtr luaState);\n\npublic class MonoPInvokeWrapperPreserves\n{\n     [ReversePInvokeWrapperGeneration(10)]\n     [MonoPInvokeCallback(typeof(LuaFunction))]\n     public static int LuaCallback(IntPtr luaState)\n     {\n         return 0;\n     }\n\n     [ReversePInvokeWrapperGeneration(100)]\n     [MonoPInvokeCallback(typeof(Func<int, int, int>))]\n     public static int Sum(int a, int b)\n     {\n         return a + b;\n     }\n\n     [MonoPInvokeCallback(typeof(Func<int, int, int>))]\n     public static int Sum2(int a, int b)\n     {\n         return a + b;\n     }\n\n     [MonoPInvokeCallback(typeof(Func<int, int>))]\n     public static int Inc(int a)\n     {\n         return a + 1;\n     }\n}\n\n")),(0,a.kt)("h2",{id:"limit"},"limit"),(0,a.kt)("p",null,"!> Please make sure that the function parameters are simple primitive types such as int, float and so on."),(0,a.kt)("p",null,"At present, there is no marshal processing for reference type parameters. Reference type parameters such as string are directly passed as parameters, which will inevitably lead to a crash after use!\nIf there is such a need, you can put the callback function in the AOT, and call back the hot update in the AOT\nfunction."))}d.isMDXComponent=!0}}]);