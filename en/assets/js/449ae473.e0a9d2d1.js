"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7333],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>f});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),c=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=c(e.components);return r.createElement(p.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),u=c(n),m=a,f=u["".concat(p,".").concat(m)]||u[m]||d[m]||o;return n?r.createElement(f,i(i({ref:t},s),{},{components:n})):r.createElement(f,i({ref:t},s))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[u]="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},34104:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var r=n(87462),a=(n(67294),n(3905));const o={},i="MonoPInvokeCallback Support",l={unversionedId:"basic/monopinvokecallback",id:"basic/monopinvokecallback",title:"MonoPInvokeCallback Support",description:"When interacting with third-party languages \u200b\u200bsuch as Lua, you need to call C# functions from these third-party languages. Two problems must be solved:",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/basic/monopinvokecallback.md",sourceDirName:"basic",slug:"/basic/monopinvokecallback",permalink:"/en/docs/basic/monopinvokecallback",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"PInvoke support",permalink:"/en/docs/basic/pinvoke"},next:{title:"AOT Generic",permalink:"/en/docs/basic/aotgeneric"}},p={},c=[{value:"Reserve ReversePInvokeWrapper Function",id:"reserve-reversepinvokewrapper-function",level:2},{value:"Limitations",id:"limitations",level:2}],s={toc:c},u="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"monopinvokecallback-support"},"MonoPInvokeCallback Support"),(0,a.kt)("p",null,"When interacting with third-party languages \u200b\u200bsuch as Lua, you need to call C# functions from these third-party languages. Two problems must be solved:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"How to get the native function pointer corresponding to the C# function")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"How to handle the problem of complex type parameter passing and return value such as string"))),(0,a.kt)("p",null,"mono and il2cpp use ",(0,a.kt)("inlineCode",{parentName:"p"},"[MonoPInvokeCallbackAttribute]")," to solve these problems. When a static managed function is added with this attribute, a separate C++ Wrapper function will be generated for it, and the function pointer can be obtained by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"Marshal.GetFunctionPointerForDelegate"),". In addition, the Wrapper function will handle complex parameters or return values \u200b\u200bsuch as string in parameters and return values. Taking the ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),"\ntype as an example, the Wrapper function will convert the native ",(0,a.kt)("inlineCode",{parentName:"p"},"const char*")," type data to the managed ",(0,a.kt)("inlineCode",{parentName:"p"},"string")," object in C#, and convert the return value of the ",(0,a.kt)("inlineCode",{parentName:"p"},"string")," type to ",(0,a.kt)("inlineCode",{parentName:"p"},"const char*")," before returning to native."),(0,a.kt)("p",null,"Similarly, hybridclr also needs to generate a corresponding wrapper function for each function marked with ",(0,a.kt)("inlineCode",{parentName:"p"},"[MonoPInvokeCallback]"),". However, for platforms such as iOS that have disabled jit, it is obviously impossible to dynamically generate these wrapper functions at runtime. Therefore, it is necessary to reserve the corresponding wrapper functions for such functions that may be used in the future."),(0,a.kt)("h2",{id:"reserve-reversepinvokewrapper-function"},"Reserve ReversePInvokeWrapper Function"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"HybridCLR/Generate/ReversePInvokeWrapper")," generates a wrapper function for each function with the ",(0,a.kt)("inlineCode",{parentName:"p"},"[MonoPInvokeCallbackAttribute]")," attribute by default.\nHowever, if only the same number of wrapper functions as the current function with the ",(0,a.kt)("inlineCode",{parentName:"p"},"[MonoPInvokeCallbackAttribute]")," attribute is generated, the problem of insufficient wrapper functions will occur when adding hot update functions later. The solution is to use ",(0,a.kt)("inlineCode",{parentName:"p"},"HybridCLR.ReversePInvokeWrapperGenerationAttribute")," for reservation operation."),(0,a.kt)("p",null,"Add a new attribute ",(0,a.kt)("inlineCode",{parentName:"p"},"[ReversePInvokeWrapperGeneration(int preserveCount)]")," to the function with ",(0,a.kt)("inlineCode",{parentName:"p"},"MonoPInvokeCallbackAttribute"),", and preserveCount wrapper functions will be generated for the function with ",(0,a.kt)("strong",{parentName:"p"},"this signature"),". If this attribute is not included, only one wrapper function will be generated for this function. If the ",(0,a.kt)("inlineCode",{parentName:"p"},"[ReversePInvokeWrapperGeneration(xx)]")," attribute is added to multiple functions with the same signature, the total number of wrapper functions is ",(0,a.kt)("inlineCode",{parentName:"p"},"the sum of all preserveCount + the number of functions without the ReversePInvokeWrapperGenerationAttribute attribute"),"."),(0,a.kt)("p",null,"As shown below, there are 10 wrappers of type ",(0,a.kt)("inlineCode",{parentName:"p"},"LuaFunction"),", 101 wrappers of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Func<int, int, int>"),", and 1 wrapper of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Func<int, int>"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"\n[UnmanagedFunctionPointer(CallingConvention.Cdecl)]\ndelegate int LuaFunction(IntPtr luaState);\n\npublic class MonoPInvokeWrapperPreserves\n{ \n    [ReversePInvokeWrapperGeneration(10)] \n    [MonoPInvokeCallback(typeof(LuaFunction))] \n    public static int LuaCallback(IntPtr luaState) \n    { \n        return 0; \n    } \n\n    [ReversePInvokeWrapperGeneration(100)] \n    [MonoPInvokeCallback(typeof(Func<int, int, int>))] \n    public static int Sum(int a, int b) \n    { \n        return a + b; \n    } \n\n    [MonoPInvokeCallback(typeof(Func<int, int, int>))] \n    public static int Sum2(int a, int b)\n    {\n        return a + b;\n    }\n\n    [MonoPInvokeCallback(typeof(Func<int, int>))]\n    public static int Inc(int a)\n    {\n        return a + 1;\n    }\n}\n\n")),(0,a.kt)("h2",{id:"limitations"},"Limitations"),(0,a.kt)("p",null,"Currently, when calling MonoPInvokeCallback type functions, the parameters are not marshaled. Ordinary int and float types work fine, but parameters like string will crash if they are used directly because the native layer passes 'char*' and is not marshaled to string!"),(0,a.kt)("p",null,"If you encounter string type parameters, there are two solutions:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"You can put the callback function in AOT and call back the hot update function in AOT.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Change the parameter to IntPtr type, and then call Marshal.PtrToStringUTF8 to convert the original char* type data of IntPtr type into string. The sample code is as follows."))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"[MonoPInvokeCallback(typeof(Func<Intptr, int>))]\npublic static int Inc(IntPtr ptr)\n{\nstring s = Marshal.PtrToStringUTF8(ptr);\nreturn s.Length;\n}\n\n")),(0,a.kt)("p",null,"Other non-primitive type parameters that need Marshal can be processed in the same way."))}d.isMDXComponent=!0}}]);