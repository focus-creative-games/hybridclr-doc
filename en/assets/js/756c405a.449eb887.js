"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1904],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>y});var l=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);t&&(l=l.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,l)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,l,n=function(e,t){if(null==e)return{};var a,l,n={},s=Object.keys(e);for(l=0;l<s.length;l++)a=s[l],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(l=0;l<s.length;l++)a=s[l],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var c=l.createContext({}),o=function(e){var t=l.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},p=function(e){var t=o(e.components);return l.createElement(c.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return l.createElement(l.Fragment,{},t)}},d=l.forwardRef((function(e,t){var a=e.components,n=e.mdxType,s=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=o(a),d=n,y=u["".concat(c,".").concat(d)]||u[d]||m[d]||s;return a?l.createElement(y,r(r({ref:t},p),{},{components:a})):l.createElement(y,r({ref:t},p))}));function y(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var s=a.length,r=new Array(s);r[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[u]="string"==typeof e?e:n,r[1]=i;for(var o=2;o<s;o++)r[o]=a[o];return l.createElement.apply(null,r)}return l.createElement.apply(null,a)}d.displayName="MDXCreateElement"},3786:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>o});var l=a(7462),n=(a(7294),a(3905));const s={},r="Access Control Policy",i={unversionedId:"business/accesspolicy",id:"business/accesspolicy",title:"Access Control Policy",description:"For some platform-based applications, they may load and execute code developed by third parties. If these third-party codes are not restricted, security risks may arise.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/business/accesspolicy.md",sourceDirName:"business",slug:"/business/accesspolicy",permalink:"/en/docs/business/accesspolicy",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"IL interpreter",permalink:"/en/docs/business/ilinterpreter"},next:{title:"Commercial Project Cases",permalink:"/en/docs/business/businesscase"}},c={},o=[{value:"Access policy file",id:"access-policy-file",level:2},{value:"Configuration rules",id:"configuration-rules",level:2},{value:"Rule",id:"rule",level:3},{value:"assembly",id:"assembly",level:3},{value:"type",id:"type",level:3},{value:"Target",id:"target",level:3},{value:"XmlAccessPolicyReader and BinaryAccessPolicyWriter",id:"xmlaccesspolicyreader-and-binaryaccesspolicywriter",level:2},{value:"Verify the legality of AccessPolicy configuration",id:"verify-the-legality-of-accesspolicy-configuration",level:2},{value:"Pre-verify whether the assembly meets AccessPolicy",id:"pre-verify-whether-the-assembly-meets-accesspolicy",level:2},{value:"Set access policy at runtime",id:"set-access-policy-at-runtime",level:2}],p={toc:o},u="wrapper";function m(e){let{components:t,...a}=e;return(0,n.kt)(u,(0,l.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"access-control-policy"},"Access Control Policy"),(0,n.kt)("p",null,"For some platform-based applications, they may load and execute code developed by third parties. If these third-party codes are not restricted, security risks may arise.\nAccess control mechanisms are used to control the set of functions that these third-party code can access."),(0,n.kt)("h2",{id:"access-policy-file"},"Access policy file"),(0,n.kt)("p",null,"We use access policy files to easily configure control information. Currently only class-level access control is supported (function-granular access control may be supported in the future), that is, if a class does not allow access,\nThen you cannot call any function of that type, including class constructors (functions from the parent class can still be called if they are not in the restricted scope). A typical policy configuration file is as follows:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-xml"},'<AccessPolicy>\n\n    <Rule id="DisableIO">\n        <assembly fullname="mscorlib">\n            <type fullname="System.IO.*"/> disable\n            <type fullname="System.IO.File" access="1"/> enable\n        </assembly>\n    </Rule>\n\n    <Rule id="DisableReflection">\n        <assembly fullname="mscorlib">\n            <type fullname="System.Reflection.*"/>\n        </assembly>\n    </Rule>\n\n    <Rule id="DisableHybridCLR">\n        <assembly fullname="HybridCLR.Runtime">\n            <type fullname="*"/>\n        </assembly>\n    </Rule>\n\n    <Target assembly="Tests2" accessAssemblyNotInRules="0" rules="DisableReflection,DisableIO,DisableHybridCLR"/>\n\n</AccessPolicy>\n\n')),(0,n.kt)("h2",{id:"configuration-rules"},"Configuration rules"),(0,n.kt)("p",null,"The top-level tag is AccessPolicy, which contains 0-N Rule and Target configuration items."),(0,n.kt)("h3",{id:"rule"},"Rule"),(0,n.kt)("p",null,"Each Rule contains access control rules for multiple assemblies. Each Rule will calculate a set of types that restrict access. The final set of restricted access is the union of all Rules. That is, as long as a Rule restricts access to a certain type,\nThen access to this type is ultimately not allowed."),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Attribute or element"),(0,n.kt)("th",{parentName:"tr",align:null},"Type"),(0,n.kt)("th",{parentName:"tr",align:null},"Nullable"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"id"),(0,n.kt)("td",{parentName:"tr",align:null},"Attribute"),(0,n.kt)("td",{parentName:"tr",align:null},"No"),(0,n.kt)("td",{parentName:"tr",align:null},"The id of the Rule. String type, cannot be empty, must be globally unique")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"assembly"),(0,n.kt)("td",{parentName:"tr",align:null},"Sub-element"),(0,n.kt)("td",{parentName:"tr",align:null}),(0,n.kt)("td",{parentName:"tr",align:null},"For the restricted set of a single assembly, a Rule can contain 0-N assemblies. There cannot be an assembly with the same name under the same Rule, but there can be an assembly with the same name between different Rules")))),(0,n.kt)("h3",{id:"assembly"},"assembly"),(0,n.kt)("p",null,"A set of restriction rules for a single assembly configures which types of access to that assembly are prohibited."),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Attribute or element"),(0,n.kt)("th",{parentName:"tr",align:null},"Type"),(0,n.kt)("th",{parentName:"tr",align:null},"Nullable"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"fullname"),(0,n.kt)("td",{parentName:"tr",align:null},"property"),(0,n.kt)("td",{parentName:"tr",align:null},"no"),(0,n.kt)("td",{parentName:"tr",align:null},"assembly name. String type, cannot be empty. Assembly name does not contain '.dll' (e.g. mscorlib)")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"type"),(0,n.kt)("td",{parentName:"tr",align:null},"Sub-element"),(0,n.kt)("td",{parentName:"tr",align:null}),(0,n.kt)("td",{parentName:"tr",align:null},"Restriction rules for a single or a group of types. There can be 0-N elements")))),(0,n.kt)("p",null,"In the same assembly, if there are multiple rules related to a certain type, the last rule that takes effect will prevail. For example:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-xml"},'<assembly fullname="mscorlib">\n    <type fullname="System.IO.*"/> disable\n    <type fullname="System.IO.File" access="1"/> enable\n</assembly>\n')),(0,n.kt)("p",null,"In the above example, although ",(0,n.kt)("inlineCode",{parentName:"p"},'<type fullname="System.IO.*"/>')," prohibits access to all types under the ",(0,n.kt)("inlineCode",{parentName:"p"},"System.IO")," namespace, including ",(0,n.kt)("inlineCode",{parentName:"p"},"System.IO.File"),", the following\n",(0,n.kt)("inlineCode",{parentName:"p"},'<type fullname="System.IO.File" access="1"/>')," has separately canceled the access restrictions on ",(0,n.kt)("inlineCode",{parentName:"p"},"System.IO.File"),"."),(0,n.kt)("h3",{id:"type"},"type"),(0,n.kt)("p",null,"Restrictive rules for one or a group of types."),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Attribute or element"),(0,n.kt)("th",{parentName:"tr",align:null},"Type"),(0,n.kt)("th",{parentName:"tr",align:null},"Nullable"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"fullname"),(0,n.kt)("td",{parentName:"tr",align:null},"Attribute"),(0,n.kt)("td",{parentName:"tr",align:null},"No"),(0,n.kt)("td",{parentName:"tr",align:null},"The full name of the type or the type wildcard. If it is a type wildcard, only ",(0,n.kt)("inlineCode",{parentName:"td"},"*")," full matching or ",(0,n.kt)("inlineCode",{parentName:"td"},"xx.yy.zz.*")," namespace wildcarding is supported. Prefix wildcarding such as ",(0,n.kt)("inlineCode",{parentName:"td"},"xx.yy*")," or ",(0,n.kt)("inlineCode",{parentName:"td"},"xx.*.yy")," is not supported. Any kind of wildcard")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"access"),(0,n.kt)("td",{parentName:"tr",align:null},"Attribute"),(0,n.kt)("td",{parentName:"tr",align:null},"Yes"),(0,n.kt)("td",{parentName:"tr",align:null},"Whether it is accessible, the default is false. It is true when ",(0,n.kt)("inlineCode",{parentName:"td"},"true, yes, 1")," is taken and false when ",(0,n.kt)("inlineCode",{parentName:"td"},"false, no, 0")," is taken")))),(0,n.kt)("h3",{id:"target"},"Target"),(0,n.kt)("p",null,"Target configures access restriction rules that are imposed on the code in the assembly."),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Attribute or element"),(0,n.kt)("th",{parentName:"tr",align:null},"Type"),(0,n.kt)("th",{parentName:"tr",align:null},"Nullable"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"assembly"),(0,n.kt)("td",{parentName:"tr",align:null},"Attributes"),(0,n.kt)("td",{parentName:"tr",align:null},"No"),(0,n.kt)("td",{parentName:"tr",align:null},"The role of access restrictions is the target assembly, that is, the functions accessed by the code in the assembly must meet the access restriction rules specified in rules")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"The"),(0,n.kt)("td",{parentName:"tr",align:null},"accessAssemblyNotInRules"),(0,n.kt)("td",{parentName:"tr",align:null},"property"),(0,n.kt)("td",{parentName:"tr",align:null},"is")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"rules"),(0,n.kt)("td",{parentName:"tr",align:null},"Attribute"),(0,n.kt)("td",{parentName:"tr",align:null},"No"),(0,n.kt)("td",{parentName:"tr",align:null},"Rule id list, separated by ",(0,n.kt)("inlineCode",{parentName:"td"},","),". The functions accessed by the code in the assembly must not be in any of the restricted sets of Rule")))),(0,n.kt)("h2",{id:"xmlaccesspolicyreader-and-binaryaccesspolicywriter"},"XmlAccessPolicyReader and BinaryAccessPolicyWriter"),(0,n.kt)("p",null,"The access policy file is in xml format, which is complex to parse and requires a certain amount of overhead to load at runtime. Therefore, it is necessary to convert AccessPolicy.xml to AccessPolicy.bin file in advance when packaging, and load the AccessPolicy.bin file during runtime."),(0,n.kt)("p",null,"The ",(0,n.kt)("inlineCode",{parentName:"p"},"HybridCLR.Editor.Security.AccessPolicyUtil")," class implements the ConvertXmlAccessPolicyToBinaryAccessPolicy function, which is used to convert xml format to bin format.\nThe sample code is as follows:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp"},'[MenuItem("Test/ConvertXmlAccessPolicyToBinary")]\npublic static void ConvertXmlAccessPolicyToBinary()\n{\n    string accessPolicyDir = Application.dataPath + "/AccessPolicy";\n    AccessPolicyUtil.ConvertXmlAccessPolicyToBinaryAccessPolicy($"{accessPolicyDir}/AccessPolicy.xml",\n        $"{accessPolicyDir}/AccessPolicy.bytes");\n}\n')),(0,n.kt)("h2",{id:"verify-the-legality-of-accesspolicy-configuration"},"Verify the legality of AccessPolicy configuration"),(0,n.kt)("p",null,"In practice, it is easy to incorrectly fill in names such as ",(0,n.kt)("inlineCode",{parentName:"p"},"assembly.fullname")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"type.fullname"),", resulting in the expected access control policy not being correctly implemented.\n",(0,n.kt)("inlineCode",{parentName:"p"},"HybridCLR.Editor.Security.AccessPolicyConfigValidator")," is used to check the validity of AccessPolicy to avoid this error."),(0,n.kt)("table",null,(0,n.kt)("thead",{parentName:"table"},(0,n.kt)("tr",{parentName:"thead"},(0,n.kt)("th",{parentName:"tr",align:null},"Function"),(0,n.kt)("th",{parentName:"tr",align:null},"Description"))),(0,n.kt)("tbody",{parentName:"table"},(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"ValidateRules"),(0,n.kt)("td",{parentName:"tr",align:null},"Check the legality of Rule rules")),(0,n.kt)("tr",{parentName:"tbody"},(0,n.kt)("td",{parentName:"tr",align:null},"ValidateTargets"),(0,n.kt)("td",{parentName:"tr",align:null},"Check the legality of Target rules")))),(0,n.kt)("p",null,"The sample code is as follows:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp"},'public static void ValidateAccessPolicy()\n{\n    var reader = new XmlAccessPolicyReader();\n    reader.LoadXmlFile("Assets/AccessPolicy/AccessPolicy.xml");\n    List<string> hotUpdateDllNames = SettingsUtil.HotUpdateAssemblyNamesExcludePreserved;\n    var assemblyCache = new AssemblyCache(MetaUtil.CreateHotUpdateAndAOTAssemblyResolver(EditorUserBuildSettings.activeBuildTarget, hotUpdateDllNames));\n    var validator = new AccessPolicyConfigValidator(assemblyCache);\n\n    var accessPolicy = reader.GetAccessPolicy();\n    validator.ValidateRules(accessPolicy);\n    validator.ValidateTargets(accessPolicy, new List<string> { "Tests2" });\n}\n')),(0,n.kt)("h2",{id:"pre-verify-whether-the-assembly-meets-accesspolicy"},"Pre-verify whether the assembly meets AccessPolicy"),(0,n.kt)("p",null,(0,n.kt)("inlineCode",{parentName:"p"},"Assembly.Load")," does not check whether there are illegal calls in the assembly when loading the assembly. During the running process, it only checks whether the calling function complies with the AccessPolicy when a function is called for the first time, which causes inconvenience.\n",(0,n.kt)("inlineCode",{parentName:"p"},"HybridCLR.Editor.Security.AssemblyValidator")," is used to offline pre-verify whether all calls in the assembly comply with AccessPolicy."),(0,n.kt)("p",null,"The sample code is as follows:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp"},'public static void ValidateAssembly()\n{\n    var reader = new XmlAccessPolicyReader();\n    reader.LoadXmlFile("Assets/AccessPolicy/AccessPolicy.xml");\n    var validator = new AssemblyValidator(reader.GetAccessPolicy());\n    string test2DllPath = $"{SettingsUtil.GetHotUpdateDllsOutputDirByTarget(EditorUserBuildSettings.activeBuildTarget)}/Tests2.dll";\n    var mod = ModuleDefMD.Load(test2DllPath);\n    validator.ValidateAssembly(mod);\n}\n\n')),(0,n.kt)("h2",{id:"set-access-policy-at-runtime"},"Set access policy at runtime"),(0,n.kt)("p",null,"The RuntimeApi class provides the LoadAccessPolicy function for setting access policies. This function can be called multiple times during operation to update the access policy."),(0,n.kt)("p",null,"The sample code is as follows:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-csharp"},'\nvoid LoadAccessPolicy()\n{\n    byte[] accessPolicyData = File.ReadAllBytes($"{Application.streamingAssetsPath}/AccessPolicy.bin");\n    RuntimeApi.LoadAccessPolicy(accessPolicyData);\n}\n\n')))}m.isMDXComponent=!0}}]);