"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[439],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),d=p(n),u=i,h=d["".concat(s,".").concat(u)]||d[u]||m[u]||l;return n?a.createElement(h,o(o({ref:t},c),{},{components:n})):a.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,o=new Array(l);o[0]=u;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r[d]="string"==typeof e?e:i,o[1]=r;for(var p=2;p<l;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},62111:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>l,metadata:()=>r,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const l={},o="AOT Generics",r={unversionedId:"basic/aotgeneric",id:"basic/aotgeneric",title:"AOT Generics",description:"CLR has two types of generic features: generic types and generic functions. Generics are an extremely widely used feature in C#. Even code that doesn't obviously contain generic usage may implicitly include generic-related definitions or operations.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/basic/aotgeneric.md",sourceDirName:"basic",slug:"/basic/aotgeneric",permalink:"/en/docs/basic/aotgeneric",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"MonoPInvokeCallback Support",permalink:"/en/docs/basic/monopinvokecallback"},next:{title:"Bridge Functions",permalink:"/en/docs/basic/methodbridge"}},s={},p=[{value:"AOT Generic Problems",id:"aot-generic-problems",level:2},{value:"il2cpp&#39;s Generic Sharing Mechanism",id:"il2cpps-generic-sharing-mechanism",level:2},{value:"Shared Type Calculation Rules",id:"shared-type-calculation-rules",level:2},{value:"Non-enum Value Types",id:"non-enum-value-types",level:3},{value:"Enum Types",id:"enum-types",level:3},{value:"Class Reference Types",id:"class-reference-types",level:3},{value:"Generic Types",id:"generic-types",level:3},{value:"Shared Generic Function Calculation Rules for Generic Functions",id:"shared-generic-function-calculation-rules-for-generic-functions",level:3},{value:"Why Value Types Don&#39;t Support Generic Sharing in il2cpp",id:"why-value-types-dont-support-generic-sharing-in-il2cpp",level:2},{value:"Problems Caused by Memory Alignment",id:"problems-caused-by-memory-alignment",level:3},{value:"ABI Issues",id:"abi-issues",level:3},{value:"Limitations of Generic Sharing Mechanism",id:"limitations-of-generic-sharing-mechanism",level:2},{value:"Generic Function Instantiation Technology Based on Supplemental Metadata (HybridCLR&#39;s Patented Technology)",id:"generic-function-instantiation-technology-based-on-supplemental-metadata-hybridclrs-patented-technology",level:2},{value:"Obtaining Supplemental Metadata DLL",id:"obtaining-supplemental-metadata-dll",level:3},{value:"Assembly List That Should Supplement Metadata",id:"assembly-list-that-should-supplement-metadata",level:3},{value:"Metadata Mode HomologousImageMode",id:"metadata-mode-homologousimagemode",level:3},{value:"Sample Code for Loading Supplemental Metadata",id:"sample-code-for-loading-supplemental-metadata",level:3},{value:"Optimizing Supplemental Metadata DLL Size",id:"optimizing-supplemental-metadata-dll-size",level:2},{value:"Full Generic Sharing Technology",id:"full-generic-sharing-technology",level:2},{value:"Appendix: Shared Generic Instantiation Examples for AOT Generics",id:"appendix-shared-generic-instantiation-examples-for-aot-generics",level:2},{value:"Example 1",id:"example-1",level:3},{value:"Example 2",id:"example-2",level:3},{value:"Example 3",id:"example-3",level:3}],c={toc:p},d="wrapper";function m(e){let{components:t,...n}=e;return(0,i.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"aot-generics"},"AOT Generics"),(0,i.kt)("p",null,"CLR has two types of generic features: generic types and generic functions. Generics are an extremely widely used feature in C#. Even code that doesn't obviously contain generic usage may implicitly include generic-related definitions or operations."),(0,i.kt)("h2",{id:"aot-generic-problems"},"AOT Generic Problems"),(0,i.kt)("p",null,"For generic classes ",(0,i.kt)("strong",{parentName:"p"},"defined in hot update code"),", they can be used freely without restrictions. However, for ",(0,i.kt)("strong",{parentName:"p"},"AOT generics"),", some problems are encountered."),(0,i.kt)("p",null,"il2cpp is an AOT runtime, and almost all types used at runtime (why not all?) are statically determined at compile time. If you only instantiated ",(0,i.kt)("inlineCode",{parentName:"p"},"List<int>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"List<string>")," in AOT, you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"new List<int>()")," in hot update code,\nbut you cannot use ",(0,i.kt)("inlineCode",{parentName:"p"},"new List<float>()"),". This is because although il2cpp can create most metadata for the ",(0,i.kt)("inlineCode",{parentName:"p"},"List<float>")," type in memory, it cannot create implementations for its member functions.\nFor example, you can get ",(0,i.kt)("inlineCode",{parentName:"p"},"typeof(List<float>)")," through reflection, but you cannot call any of its member functions, including constructors."),(0,i.kt)("p",null,"Additionally, some special C# mechanisms also cause AOT generic problems, such as the compiler potentially generating implicit AOT generic references for complex syntax sugar like async. Therefore, to make these mechanisms work properly, the AOT generic instantiation problems they cause must also be resolved.\nTaking async as an example, the compiler generates several classes, state machines, and some code for async. These hidden generated code contains calls to multiple AOT generic functions. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"void AsyncTaskMethodBuilder::Start<TStateMachine>(ref TStateMachine stateMachine)"),"."),(0,i.kt)("p",null,"Generic classes, especially generic containers like List and Dictionary, are so widely used in code that if AOT limitations prevented things like ",(0,i.kt)("inlineCode",{parentName:"p"},"List<HotUpdateType>")," from running, the code restrictions for game hot updates would be too severe. Fortunately, HybridCLR uses several technologies to completely solve this problem:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Based on il2cpp's ",(0,i.kt)("inlineCode",{parentName:"li"},"generic sharing")," technology."),(0,i.kt)("li",{parentName:"ul"},"Based on ",(0,i.kt)("inlineCode",{parentName:"li"},"supplemental metadata")," technology. This is also HybridCLR's patented technology. This technology is also available in the community version."),(0,i.kt)("li",{parentName:"ul"},"Based on ",(0,i.kt)("inlineCode",{parentName:"li"},"full generic sharing")," complete generic sharing technology. This technology is currently only available in commercial versions.")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Due to the significant limitations of il2cpp generic sharing technology, it is strongly recommended to use ",(0,i.kt)("inlineCode",{parentName:"p"},"supplemental metadata")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"full generic sharing")," technology to solve generic problems.")),(0,i.kt)("h2",{id:"il2cpps-generic-sharing-mechanism"},"il2cpp's Generic Sharing Mechanism"),(0,i.kt)("p",null,"To avoid generic code bloat and save memory, il2cpp only generates one copy of code for code that can be shared while ensuring code logic correctness. This introduces a concept called ",(0,i.kt)("strong",{parentName:"p"},"Generic Code Sharing")," ",(0,i.kt)("a",{parentName:"p",href:"https://blog.unity.com/technology/il2cpp-internals-generic-sharing-implementation"},"Generic Sharing"),".\nSimply put, as long as you ",(0,i.kt)("strong",{parentName:"p"},"instantiate a shared instance of a generic class or generic function in AOT"),", you can use it in hot update code."),(0,i.kt)("p",null,"Taking List","<","T",">"," as an example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"You can use any List instantiation type used in AOT. For example, if you used List","<","vector3",">"," in AOT, you can also use it in hot updates"),(0,i.kt)("li",{parentName:"ul"},"You can use any List","<","HotUpdateEnum",">",". You just need to instantiate a List","<","enum type with the same underlying type",">"," in AOT."),(0,i.kt)("li",{parentName:"ul"},"You can use generic parameters of any reference type List","<","HotUpdateClass",">",". You just need to have instantiated List","<","object",">"," (or any reference generic parameter like List","<","string",">",") in AOT")),(0,i.kt)("h2",{id:"shared-type-calculation-rules"},"Shared Type Calculation Rules"),(0,i.kt)("p",null,"Assume the shared type of generic class T is sharing type, calculated as follows."),(0,i.kt)("h3",{id:"non-enum-value-types"},"Non-enum Value Types"),(0,i.kt)("p",null,"sharing type is itself. For example, int's share type is int"),(0,i.kt)("h3",{id:"enum-types"},"Enum Types"),(0,i.kt)("p",null,"sharing type is an enum with the same underlying type. For example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"enum MyEnumA\n{\n    A = 1,\n}\nenum MyEnumB\n{\n    A = 10,\n}\n\nenum MyEnumC : short\n{\n    A = 1,\n}\n\nenum MyEnumD : short\n{\n    A = 1,\n}\n\n")),(0,i.kt)("p",null,"MyEnumA and MyEnumB have the same shared type, MyEnumC and MyEnumD have the same shared type."),(0,i.kt)("h3",{id:"class-reference-types"},"Class Reference Types"),(0,i.kt)("p",null,"sharing type is object"),(0,i.kt)("h3",{id:"generic-types"},"Generic Types"),(0,i.kt)("p",null,"For ",(0,i.kt)("inlineCode",{parentName:"p"},"GenericType<T1, T2, ...>"),", if GenericType is a class type, then share type is object, otherwise share type is ",(0,i.kt)("inlineCode",{parentName:"p"},"GenericType<shareType<T1>, shareType<T2>, ...>"),". For example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The share type of ",(0,i.kt)("inlineCode",{parentName:"li"},"Dictionary<int, string>")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"object")),(0,i.kt)("li",{parentName:"ul"},"The share type of ",(0,i.kt)("inlineCode",{parentName:"li"},"ValueTuple<int, string>")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"ValueTuple<int, object>"))),(0,i.kt)("h3",{id:"shared-generic-function-calculation-rules-for-generic-functions"},"Shared Generic Function Calculation Rules for Generic Functions"),(0,i.kt)("p",null,"The AOT generic function for ",(0,i.kt)("inlineCode",{parentName:"p"},"Class<C1, C2, ...>.Method<M1, M2, ...>(A1, A2, ...)")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"Class<sharing(C1), sharing(C2), ...>.Method<sharing(M1), sharing(M2), ...>(sharing(A1), sharing(A2), ...>"),". For example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The shared function for ",(0,i.kt)("inlineCode",{parentName:"li"},"List<string>.ctor")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"List<object>.ctor")),(0,i.kt)("li",{parentName:"ul"},"The shared function for ",(0,i.kt)("inlineCode",{parentName:"li"},"List<int>.Add(int)")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"List<int>.Add(int)")),(0,i.kt)("li",{parentName:"ul"},"The shared function for ",(0,i.kt)("inlineCode",{parentName:"li"},"YourGenericClass<string, int, List<int>>.Show<string, List<int>, int>(ValueTuple<int, string>, string, int)")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"YourGenericClass<object, int, object>.Show<object, object, int>(ValueTuple<int, object>, object, int)"))),(0,i.kt)("h2",{id:"why-value-types-dont-support-generic-sharing-in-il2cpp"},"Why Value Types Don't Support Generic Sharing in il2cpp"),(0,i.kt)("p",null,"It's easy to understand that value types of different sizes cannot be shared, but why can't value types of the same size support generic sharing like classes? There are mainly two reasons."),(0,i.kt)("h3",{id:"problems-caused-by-memory-alignment"},"Problems Caused by Memory Alignment"),(0,i.kt)("p",null,"Even if value types have the same size, if their alignment methods are different, when they are subfields of other classes, the final memory size and layout of the containing class may be different."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"struct A // size = 4, alignment = 2\n{\n    short x;\n    short y;\n};\n\nstruct B // size = 4\uff0calignment = 4\n{\n    int x;\n};\n\nstruct GenericDemo<T>\n{\n    short x;\n    T v;\n\n    public T GetValue() => v;\n};\n\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"GenericDemo<A>")," size=6, alignment=2, field v has offset 2 in the class; while ",(0,i.kt)("inlineCode",{parentName:"p"},"GenericDemo<B>")," size=8, alignment=4, field v has offset 4 in the class. Obviously for the GetValue function, due to different v offsets, it's impossible to use the same C++ code to work correctly for both classes."),(0,i.kt)("h3",{id:"abi-issues"},"ABI Issues"),(0,i.kt)("p",null,"Structs with the same size and alignment are equivalent in ",(0,i.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/cpp/build/x64-software-conventions?redirectedfrom=MSDN&view=msvc-170"},"x64 ABI")," and can use structs of the same size as shared generic instantiations. However, this is not possible in ",(0,i.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/cpp/build/arm64-windows-abi-conventions?view=msvc-170"},"arm64 ABI"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"struct IntVec3 { int32_t x, y, z; }")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"struct FloatVec3 { float x, y, z}")," although both have size 12, they have different parameter passing methods when passed as function arguments:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"IntVec3 is passed by reference"),(0,i.kt)("li",{parentName:"ul"},"FloatVec3's three fields are placed in three separate floating-point registers")),(0,i.kt)("p",null,"This is another key reason why structs cannot support generic sharing."),(0,i.kt)("h2",{id:"limitations-of-generic-sharing-mechanism"},"Limitations of Generic Sharing Mechanism"),(0,i.kt)("p",null,"Since value types cannot support generic sharing, if value types appear in the generic parameters of generic instances (classes or functions), these generic instances must be instantiated in advance in AOT. If your generic parameter type is a value type defined in hot update code, since hot update types obviously cannot be generically instantiated in advance in AOT, you cannot use code like ",(0,i.kt)("inlineCode",{parentName:"p"},"List<HotUpdateValueType>")," in hot update code. This not only brings great inconvenience to development, but re-releasing the main package in the short term after going online is also unrealistic."),(0,i.kt)("p",null,"In addition, syntax sugar like async generates state machines that are value types when compiled in non-Development mode, which cannot support generic sharing. You must compile the dll in Development mode to utilize the generic sharing mechanism. This is not only troublesome but also reduces the performance of interpretation execution to some extent."),(0,i.kt)("p",null,"Fortunately, we have innovatively proposed the patented ",(0,i.kt)("inlineCode",{parentName:"p"},"supplemental metadata")," technology and the ",(0,i.kt)("inlineCode",{parentName:"p"},"full generic sharing")," technology supporting il2cpp, which completely solves this problem."),(0,i.kt)("h2",{id:"generic-function-instantiation-technology-based-on-supplemental-metadata-hybridclrs-patented-technology"},"Generic Function Instantiation Technology Based on Supplemental Metadata (HybridCLR's Patented Technology)"),(0,i.kt)("p",null,"All metadata in AOT generic metadata except functions can be instantiated in memory through Inflate technology, but functions cannot be instantiated. The problem that AOT generic functions cannot be instantiated is essentially because il2cpp loses the original function body IL metadata during the ",(0,i.kt)("inlineCode",{parentName:"p"},"IL -> C++")," translation process.\nTaking the ",(0,i.kt)("inlineCode",{parentName:"p"},"List<T>.Add")," function as an example, without the original IL function information, it's impossible to get the correct implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"List<long>.Add")," from existing ",(0,i.kt)("inlineCode",{parentName:"p"},"List<int>.Add")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"List<object>.Add"),". Our solution is ingenious\u2014supplementing the missing original generic function body metadata."),(0,i.kt)("p",null,"Use the ",(0,i.kt)("inlineCode",{parentName:"p"},"HybridCLR.RuntimeApi.LoadMetadataForAOTAssembly")," function in the com.code-philosophy.hybridclr package to supplement corresponding metadata for AOT assemblies.\nThe LoadMetadataForAOTAssembly function can be called at any time, and can be called both in AOT and hot update code. You just need to call it before using AOT generics (only need to call once).\nTheoretically, the earlier the loading the better. In practice, a reasonable timing is after hot update completion, or after hot update dll loading but before executing any code. If the supplemental metadata dll is also packaged into the main package as additional data files (e.g., placed in StreamingAssets), loading during main project startup is better."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Supplemental metadata has no loading order requirements"),"."),(0,i.kt)("p",null,"After supplemental metadata is loaded, it will occupy approximately 6 times the dll size in memory, and this memory cannot be reclaimed. For applications with high memory requirements, please use the commercial version's full generic sharing technology, which no longer requires supplemental metadata and saves this memory."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"It's the generic functions that lose IL function body metadata, not the generic parameter types that lose metadata. Taking ",(0,i.kt)("inlineCode",{parentName:"p"},"List<YourValueType>.Add")," as an example,\nit's the ",(0,i.kt)("inlineCode",{parentName:"p"},"List<T>.Add")," function that lacks original IL function body metadata, not ",(0,i.kt)("inlineCode",{parentName:"p"},"YourValueType")," that loses metadata. Therefore,\nyou should supplement the metadata of ",(0,i.kt)("inlineCode",{parentName:"p"},"mscorlib.dll")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"List<T>.Add")," is located, not the metadata of the dll where ",(0,i.kt)("inlineCode",{parentName:"p"},"YourValueType")," is located.")),(0,i.kt)("p",null,"If AOT generics have supplemental corresponding generic metadata and il2cpp generic sharing instantiation also exists, to maximize performance, HybridCLR will prioritize trying il2cpp generic sharing."),(0,i.kt)("p",null,"Although the generic function instantiation technology based on supplemental metadata is quite perfect, the instantiated functions are executed in interpretation mode after all. If they can be generically instantiated in advance in AOT, performance can be significantly improved.\nSo for commonly used and especially performance-sensitive generic classes and functions, they can be instantiated in advance in AOT. We provide tools to help automatically scan and collect corresponding generic instances. You can run the menu command ",(0,i.kt)("inlineCode",{parentName:"p"},"HybridCLR/Generate/AOTGenericReference"),"."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"This command only collects AOT generic instances used in hot updates, and all generated code is in comment form. You need to refer to this file yourself and explicitly instantiate some generics elsewhere according to actual needs.")),(0,i.kt)("h3",{id:"obtaining-supplemental-metadata-dll"},"Obtaining Supplemental Metadata DLL"),(0,i.kt)("p",null,"The trimmed AOT dll generated during the ",(0,i.kt)("strong",{parentName:"p"},"packaging process")," can be used for supplemental metadata. The com.code-philosophy.hybridclr plugin will automatically copy them to ",(0,i.kt)("inlineCode",{parentName:"p"},"{project}/HybridCLRData/AssembliesPostIl2CppStrip/{target}"),". Note that trimmed AOT dlls from different BuildTargets cannot be reused."),(0,i.kt)("p",null,"You can also use the ",(0,i.kt)("inlineCode",{parentName:"p"},"HybridCLR/Generate/AotDlls")," command to immediately generate trimmed AOT dlls. Its working principle is to obtain trimmed AOT dlls by exporting a Temp project."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Please save the trimmed AOT dlls generated during packaging (usually in the ",(0,i.kt)("inlineCode",{parentName:"p"},"{project}/HybridCLRData/AssembliesPostIl2CppStrip/{target}")," directory). Use these saved AOT dlls when supplemental metadata is needed."),(0,i.kt)("p",{parentName:"admonition"},"After packaging is complete, supplemental metadata dlls will not change. Please ",(0,i.kt)("strong",{parentName:"p"},"do not use the latest generated AOT dlls for every hot update"),".")),(0,i.kt)("h3",{id:"assembly-list-that-should-supplement-metadata"},"Assembly List That Should Supplement Metadata"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"AOTGenericReferences.cs")," file generated by the ",(0,i.kt)("inlineCode",{parentName:"p"},"HybridCLR/generate/AOTGenericReference")," command contains the assembly list that should supplement metadata, as shown in the example below. You can quickly know which metadata should be supplemented without running the game."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The calculation result of the PatchedAOTAssemblyList is conservative, and in practice you may not need to supplement so many. If there's no obvious memory pressure, supplementing all according to the list is more convenient. If optimization is needed, you can only supplement the most common dlls (like mscorlib), and add corresponding dlls later when encountering AOT generic errors."),(0,i.kt)("p",{parentName:"admonition"},"Supplemental metadata dlls can be hot updated, so you don't need to worry about suddenly encountering generic errors in a version after release.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'using System.Collections.Generic;\npublic class AOTGenericReferences : UnityEngine.MonoBehaviour\n{\n\n    // {{ AOT assemblies\n    public static readonly IReadOnlyList<string> PatchedAOTAssemblyList = new List<string>\n    {\n        "Main.dll",\n        "System.Core.dll",\n        "UnityEngine.CoreModule.dll",\n        "mscorlib.dll",\n    };\n\n        // {{ constraint implement type\n    // }} \n\n    // {{ AOT generic types\n    // AOTDefs.HierarchyGeneric2<int>\n    // IBar<object>\n    // IRun<object>\n    // System.Action<UnityEngine.RaycastHit>\n}\n')),(0,i.kt)("h3",{id:"metadata-mode-homologousimagemode"},"Metadata Mode HomologousImageMode"),(0,i.kt)("p",null,"Currently supports two metadata modes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"HomologousImageMode::Consistent")," mode, which means the supplemented dll is exactly the same as the trimmed dll during packaging. Therefore, you must use the trimmed dll generated during the build process, and cannot directly copy the original dll."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"HomologousImageMode::SuperSet")," mode, which means the supplemented dll is a superset of the trimmed dll during packaging. This mode relaxes the requirements for AOT dlls, allowing you to use either trimmed AOT dlls or original AOT dlls.")),(0,i.kt)("h3",{id:"sample-code-for-loading-supplemental-metadata"},"Sample Code for Loading Supplemental Metadata"),(0,i.kt)("p",null,"The method for loading supplemental metadata dlls in code is shown in the following sample code. You can also refer to ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/focus-creative-games/hybridclr_trial"},"hybridclr_trial"),"."),(0,i.kt)("p",null,"When executing ",(0,i.kt)("inlineCode",{parentName:"p"},"HybridCLR.RuntimeApi.LoadMetadataForAOTAssembly"),", a copy of the passed dllBytes will be made internally. After calling this interface, ",(0,i.kt)("strong",{parentName:"p"},"please do not save dllBytes"),", otherwise it will cause memory waste."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"If RuntimeApi.LoadMetadataForAOTAssembly takes too much time and causes lag, you can load it asynchronously in another thread.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'    public static unsafe void LoadMetadataForAOTAssembly()\n    {\n        List<string> aotDllList = new List<string>\n        {\n            "mscorlib.dll",\n            "System.dll",\n            "System.Core.dll", // If using Linq, this is needed\n            // "Newtonsoft.Json.dll",\n            // "protobuf-net.dll",\n        };\n\n        AssetBundle dllAB = LoadDll.AssemblyAssetBundle;\n        foreach (var aotDllName in aotDllList)\n        {\n            byte[] dllBytes = dllAB.LoadAsset<TextAsset>(aotDllName).bytes;\n            // When executing supplemental metadata, dllBytes will be automatically copied internally. Please do not save dllBytes after calling to avoid unnecessary memory waste\n            int err = HybridCLR.RuntimeApi.LoadMetadataForAOTAssembly(dllBytes, HomologousImageMode.SuperSet);\n              Debug.Log($"LoadMetadataForAOTAssembly:{aotDllName}. ret:{err}");\n        }\n    }\n')),(0,i.kt)("h2",{id:"optimizing-supplemental-metadata-dll-size"},"Optimizing Supplemental Metadata DLL Size"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Whether to optimize supplemental metadata does not affect the normal operation of the supplemental metadata mechanism. It is recommended for projects with package size or memory optimization pressure to perform this operation.")),(0,i.kt)("p",null,"Loading supplemental metadata dlls not only increases package size or hot update resource size, but also consumes considerable memory space at runtime. For details, see the ",(0,i.kt)("a",{parentName:"p",href:"./memory"},"Memory and GC")," documentation. Optimizing supplemental metadata dll size has positive significance for memory-sensitive scenarios."),(0,i.kt)("p",null,"Supplemental metadata technology only uses the metadata information of generic functions in supplemental metadata dlls. The metadata of non-generic functions contained in supplemental metadata dlls is redundant, and completely removing them will not affect the normal operation of the supplemental metadata mechanism. Therefore, starting from v4.0.16, ",(0,i.kt)("inlineCode",{parentName:"p"},"com.code-philosophy.hybridclr")," provides the supplemental metadata optimization tool class ",(0,i.kt)("inlineCode",{parentName:"p"},"HybridCLR.Editor.AOT.AOTAssemblyMetadataStripper")," to implement this removal optimization work."),(0,i.kt)("p",null,"The removal effect varies by assembly, with significant differences. The following are our test results on a unit test project:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Assembly Name"),(0,i.kt)("th",{parentName:"tr",align:null},"Original Size"),(0,i.kt)("th",{parentName:"tr",align:null},"Optimized Size"),(0,i.kt)("th",{parentName:"tr",align:null},"Optimization Rate"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"mscorlib"),(0,i.kt)("td",{parentName:"tr",align:null},"2139k"),(0,i.kt)("td",{parentName:"tr",align:null},"1329k"),(0,i.kt)("td",{parentName:"tr",align:null},"37.9%")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"System"),(0,i.kt)("td",{parentName:"tr",align:null},"186k"),(0,i.kt)("td",{parentName:"tr",align:null},"63.0k"),(0,i.kt)("td",{parentName:"tr",align:null},"66.2%")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"System.Core"),(0,i.kt)("td",{parentName:"tr",align:null},"96.3k"),(0,i.kt)("td",{parentName:"tr",align:null},"89.1k"),(0,i.kt)("td",{parentName:"tr",align:null},"7.4%")))),(0,i.kt)("p",null,"Sample code is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'\n        /// Further remove non-generic function metadata from AOT dll, output to StrippedAOTAssembly2 directory\n        public static void StripAOTAssembly()\n        {\n            BuildTarget target = EditorUserBuildSettings.activeBuildTarget;\n            string srcDir = SettingsUtil.GetAssembliesPostIl2CppStripDir(target);\n            string dstDir = $"{SettingsUtil.HybridCLRDataDir}/StrippedAOTAssembly2/{target}";\n            foreach (var src in Directory.GetFiles(srcDir, "*.dll"))\n            {\n                string dllName = Path.GetFileName(src);\n                string dstFile = $"{dstDir}/{dllName}";\n                AOTAssemblyMetadataStripper.Strip(src, dstFile);\n            }\n        }\n\n')),(0,i.kt)("h2",{id:"full-generic-sharing-technology"},"Full Generic Sharing Technology"),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"full generic sharing")," technology is currently only available in commercial versions.")),(0,i.kt)("p",null,"Although supplemental metadata completely solves AOT generic problems, supplemental metadata requires carrying or hot updating supplemental metadata dlls, leading to increased package size or increased hot update time.\nLoading supplemental metadata not only significantly increases memory usage (generally ",(0,i.kt)("strong",{parentName:"p"},"3-4")," times the supplemental metadata dll size), but also increases startup time. For scenarios like WeChat mini-games that have strict requirements for package size and memory, this is a significant impact.\nSupplemented generic functions execute in interpretation mode, which also reduces runtime performance."),(0,i.kt)("p",null,"After HybridCLR supports ",(0,i.kt)("inlineCode",{parentName:"p"},"full generic sharing"),", supplemental metadata is no longer needed, simplifying the workflow, running AOT generics natively with significantly improved performance, completely solving the above shortcomings of supplemental metadata.\nFor detailed documentation, see ",(0,i.kt)("a",{parentName:"p",href:"../business/fullgenericsharing"},"Full Generic Sharing"),"."),(0,i.kt)("h2",{id:"appendix-shared-generic-instantiation-examples-for-aot-generics"},"Appendix: Shared Generic Instantiation Examples for AOT Generics"),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"HybridCLR has excellent performance. Unless you actually encounter performance issues, in most cases you should use supplemental metadata technology or ",(0,i.kt)("inlineCode",{parentName:"p"},"full generic sharing")," technology to solve AOT generic problems.")),(0,i.kt)("h3",{id:"example-1"},"Example 1"),(0,i.kt)("p",null,"Error log"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"MissingMethodException: AOT generic method not instantiated in aot module \n  void System.Collections.Generic.List<System.String>.ctor()\n")),(0,i.kt)("p",null,"You can add a call to ",(0,i.kt)("inlineCode",{parentName:"p"},"List<string>.ctor()")," anywhere in the main project (e.g., in RefTypes.cs), which is ",(0,i.kt)("inlineCode",{parentName:"p"},"new List<string>()"),". Due to the ",(0,i.kt)("strong",{parentName:"p"},"generic sharing mechanism"),", you can call ",(0,i.kt)("inlineCode",{parentName:"p"},"new List<object>()"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"class RefTypes\n{\n  public void MyAOTRefs()\n  {\n      new List<object>(); // You can also use new List<string>()\n  }\n}\n")),(0,i.kt)("h3",{id:"example-2"},"Example 2"),(0,i.kt)("p",null,"Error log"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"MissingMethodException: AOT generic method not instantiated in aot module \n    void System.ValueType<System.Int32, System.String>.ctor()\n")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"The empty constructor of value types doesn't call the corresponding constructor, but corresponds to the initobj instruction. Actually you cannot directly reference it, but you just need to force instantiate this type, preserve all functions of this class, and naturally it will include the .ctor function.")),(0,i.kt)("p",null,"In practice, you can use forced boxing ",(0,i.kt)("inlineCode",{parentName:"p"},"(object)(default(ValueTuple<int, object>))"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"class RefTypes\n{\n  public void MyAOTRefs()\n  {\n      // Both of the following approaches work\n      _ = (object)(new ValueTuple<int, object>());\n      _ = (object)(default(ValueTuple<int, object>));\n  }\n}\n")),(0,i.kt)("h3",{id:"example-3"},"Example 3"),(0,i.kt)("p",null,"Error log"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"MissingMethodException: AOT generic method not instantiated in aot module \n  System.Void System.Runtime.CompilerService.AsyncVoidMethodBuilder::Start<UIMgr+ShowUId__2>(UIMgr+<ShowUI>d__2&)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"class RefTypes\n{\n  public void MyAOTRefs()\n  {\n      System.Runtime.CompilerService.AsyncVoidMethodBuilder builder = default;\n      IAsyncStateMachine asm = default;\n      builder.Start(ref asm);\n  }\n}\n")))}m.isMDXComponent=!0}}]);