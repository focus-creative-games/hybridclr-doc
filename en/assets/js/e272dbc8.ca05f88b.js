"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4255],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=o.createContext({}),s=function(e){var t=o.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},p=function(e){var t=s(e.components);return o.createElement(i.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=s(n),h=a,m=d["".concat(i,".").concat(h)]||d[h]||u[h]||r;return n?o.createElement(m,c(c({ref:t},p),{},{components:n})):o.createElement(m,c({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,c=new Array(r);c[0]=h;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l[d]="string"==typeof e?e:a,c[1]=l;for(var s=2;s<r;s++)c[s]=n[s];return o.createElement.apply(null,c)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},92245:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>c,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var o=n(87462),a=(n(67294),n(3905));const r={},c="il2cpp Bug Record",l={unversionedId:"basic/il2cppbugs",id:"basic/il2cppbugs",title:"il2cpp Bug Record",description:"Covariance and Contravariance Generic Interface Call Error",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/basic/il2cppbugs.md",sourceDirName:"basic",slug:"/basic/il2cppbugs",permalink:"/en/docs/basic/il2cppbugs",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"HybridCLR Source Code Structure and Debugging",permalink:"/en/docs/basic/sourceinspect"},next:{title:"\u5546\u4e1a\u5316\u7248\u672c",permalink:"/en/docs/business"}},i={},s=[{value:"Covariance and Contravariance Generic Interface Call Error",id:"covariance-and-contravariance-generic-interface-call-error",level:2},{value:"obj.Func() Non-virtual Call Does Not Comply with Specification",id:"objfunc-non-virtual-call-does-not-comply-with-specification",level:2},{value:"StructLayout pack does not take effect when struct contains class type objects",id:"structlayout-pack-does-not-take-effect-when-struct-contains-class-type-objects",level:2},{value:"Generic array function does not set token",id:"generic-array-function-does-not-set-token",level:2},{value:"throw null causes crash",id:"throw-null-causes-crash",level:2},{value:"Closed delegate with null this throws incorrect exception",id:"closed-delegate-with-null-this-throws-incorrect-exception",level:2},{value:"2019 generated delegate call code incorrectly handles open delegate when this is ValueType",id:"2019-generated-delegate-call-code-incorrectly-handles-open-delegate-when-this-is-valuetype",level:2},{value:"mono and il2cpp do not support InvokeDynamic on open delegate of instance method",id:"mono-and-il2cpp-do-not-support-invokedynamic-on-open-delegate-of-instance-method",level:2},{value:"2019 WebGL platform generated object member access code does not check null reference",id:"2019-webgl-platform-generated-object-member-access-code-does-not-check-null-reference",level:2},{value:"Mono bug with open delegate call on ValueType member function copying instead of passing ref",id:"mono-bug-with-open-delegate-call-on-valuetype-member-function-copying-instead-of-passing-ref",level:2}],p={toc:s},d="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"il2cpp-bug-record"},"il2cpp Bug Record"),(0,a.kt)("h2",{id:"covariance-and-contravariance-generic-interface-call-error"},"Covariance and Contravariance Generic Interface Call Error"),(0,a.kt)("p",null,'Finding obj\'s interface implementation is incorrect. According to the specification, the following code should print "Comput B", such as in .net 6, but under mono and il2cpp it prints "Comput A".'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'\ninterface ITest<out T>\n{\n    T Comput();\n}\n\nclass A : ITest<object>\n{\n    public object Comput()\n    {\n        return "Comput A";\n    }\n}\n\nclass B : A, ITest<string>\n{\n    public string Comput()\n    {\n        return "Comput B";\n    }\n}\n\nclass App\n{\n    public static void Main()\n    {\n        ITest<object> f = new B();\n        Debug.Log(f.Comput());\n    }\n}\n\n')),(0,a.kt)("h2",{id:"objfunc-non-virtual-call-does-not-comply-with-specification"},"obj.Func() Non-virtual Call Does Not Comply with Specification"),(0,a.kt)("p",null,'The ECMA specification allows using the call instruction for non-virtual calls on null, but il2cpp inserts a NullCheck operation before the call. This causes the following code to print "hello" under mono, but throw a NullReferenceException under il2cpp.'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'\nclass TestNull\n{\n    public void Show()\n    {\n        Debug.Log("hello");\n    }\n}\n\nclass App\n{\n    public void Main()\n    {\n        TestNull nu = null;\n        nu.Show();\n    }\n}\n\n')),(0,a.kt)("h2",{id:"structlayout-pack-does-not-take-effect-when-struct-contains-class-type-objects"},"StructLayout pack does not take effect when struct contains class type objects"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"    [StructLayout( LayoutKind.Sequential, Pack = 1)]\n    struct StructWithoutClass\n    {\n        byte a;\n        long b;\n    }\n\n    [StructLayout(LayoutKind.Sequential, Pack = 1)]\n    struct StructWithClass\n    {\n        byte a;\n        object b;\n    }\n")),(0,a.kt)("p",null,"On x64, both structs should have size=9, which is verified by running a .net 6 program. But in mono, the first struct calculates to 9, while the second is 16."),(0,a.kt)("h2",{id:"generic-array-function-does-not-set-token"},"Generic array function does not set token"),(0,a.kt)("p",null,"In metadata/ArrayMetadata.cpp:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"    static MethodInfo* ConstructGenericArrayMethod(const GenericArrayMethod& genericArrayMethod, Il2CppClass* klass, Il2CppGenericContext* context)\n    {\n        MethodInfo* inflatedMethod = (MethodInfo*)MetadataCalloc(1, sizeof(MethodInfo));\n        inflatedMethod->name = StringUtils::StringDuplicate(genericArrayMethod.name.c_str());\n        inflatedMethod->klass = klass;\n\n        const MethodInfo* methodToCopyDataFrom = genericArrayMethod.method;\n        if (genericArrayMethod.method->is_generic)\n        {\n            const Il2CppGenericMethod* genericMethod = MetadataCache::GetGenericMethod(genericArrayMethod.method, context->class_inst, context->method_inst);\n            methodToCopyDataFrom = GenericMethod::GetMethod(genericMethod);\n\n            inflatedMethod->is_inflated = true;\n            inflatedMethod->genericMethod = genericMethod;\n            inflatedMethod->rgctx_data = methodToCopyDataFrom->rgctx_data;\n        }\n        // ==={{ add by HybridCLR\n        inflatedMethod->token = methodToCopyDataFrom->token;\n        // ===}} add by HybridCLR\n        inflatedMethod->slot = methodToCopyDataFrom->slot;\n        inflatedMethod->parameters_count = methodToCopyDataFrom->parameters_count;\n        inflatedMethod->parameters = methodToCopyDataFrom->parameters;\n        inflatedMethod->return_type = methodToCopyDataFrom->return_type;\n\n        inflatedMethod->methodPointer = methodToCopyDataFrom->methodPointer;\n        inflatedMethod->invoker_method = methodToCopyDataFrom->invoker_method;\n\n        return inflatedMethod;\n    }\n")),(0,a.kt)("h2",{id:"throw-null-causes-crash"},"throw null causes crash"),(0,a.kt)("p",null,"For C# code ",(0,a.kt)("inlineCode",{parentName:"p"},"throw ex;"),", the following code is generated, which crashes when ",(0,a.kt)("inlineCode",{parentName:"p"},"ex = null"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"    IL2CPP_RAISE_MANAGED_EXCEPTION(L_107, TestCase_Run_m5B897FE9D1ABDC1AA114D3482A6613BAAE3243F6_RuntimeMethod_var);\n")),(0,a.kt)("h2",{id:"closed-delegate-with-null-this-throws-incorrect-exception"},"Closed delegate with null this throws incorrect exception"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"Delegate.Create(XXInstanceMethod, null)")," should throw a NullReferenceException when called, but Unity 2021 throws ArgumentException."),(0,a.kt)("h2",{id:"2019-generated-delegate-call-code-incorrectly-handles-open-delegate-when-this-is-valuetype"},"2019 generated delegate call code incorrectly handles open delegate when this is ValueType"),(0,a.kt)("p",null,"When using open delegate with ref ValueType as this parameter, it incorrectly produces two calls!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"    if (targetThis == NULL && il2cpp_codegen_class_is_value_type(il2cpp_codegen_method_get_declaring_type(targetMethod)))\n    {\n        typedef int32_t (*FunctionPointerType) (RuntimeObject*, int32_t, const RuntimeMethod*);\n        result = ((FunctionPointerType)targetMethodPointer)((reinterpret_cast<RuntimeObject*>(___a0) - 1), ___b1, targetMethod);\n    }\n    if (targetThis == NULL)\n    {\n        typedef int32_t (*FunctionPointerType) (RuntimeObject*, int32_t, const RuntimeMethod*);\n        result = ((FunctionPointerType)targetMethodPointer)((RuntimeObject*)(reinterpret_cast<RuntimeObject*>(___a0) - 1), ___b1, targetMethod);\n    }\n    else\n    {\n        typedef int32_t (*FunctionPointerType) (void*, FT_AOT_ValueType_t851DF541610F2A3DE72568571355F3953F0063AF *, int32_t, const RuntimeMethod*);\n        result = ((FunctionPointerType)targetMethodPointer)(targetThis, ___a0, ___b1, targetMethod);\n    }\n\n")),(0,a.kt)("h2",{id:"mono-and-il2cpp-do-not-support-invokedynamic-on-open-delegate-of-instance-method"},"mono and il2cpp do not support InvokeDynamic on open delegate of instance method"),(0,a.kt)("p",null,"Throws 'Object does not match target type' error."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'    public void void_class_intp_open_reflection()\n    {\n        var b = new FT_Class() { x = 1, y = 2f, z = "abc" };\n        var m = typeof(FT_Class).GetMethod("Run");\n        var del = (Action<FT_Class, int>)Delegate.CreateDelegate(typeof(Action<FT_Class, int>), null, m);\n        del.DynamicInvoke(b, 4);\n        Assert.Equal(5, b.x);\n\n        var dd = del + del;\n        dd.DynamicInvoke(b, 1);\n        Assert.Equal(7, b.x);\n\n        Assert.ExpectException<NullReferenceException>();\n        del.DynamicInvoke(null, 4);\n        Assert.Fail();\n    }\n')),(0,a.kt)("h2",{id:"2019-webgl-platform-generated-object-member-access-code-does-not-check-null-reference"},"2019 WebGL platform generated object member access code does not check null reference"),(0,a.kt)("p",null,"When accessing class member fields, it doesn't check for null pointer. Currently found only on WebGL platform."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"\n//WebGL platform has no NullCheck\nIL2CPP_EXTERN_C IL2CPP_METHOD_ATTR void FT_AOT_Class_Run2_m0451FFC153671CD294EB1178A01AB2D92202624C (FT_AOT_Class_t03C2F346FF0EA8694088FD3F901E6536935FB2BA * ___s0, int32_t ___b1, const RuntimeMethod* method)\n{\n    {\n        // s.x += b;\n        FT_AOT_Class_t03C2F346FF0EA8694088FD3F901E6536935FB2BA * L_0 = ___s0;\n        FT_AOT_Class_t03C2F346FF0EA8694088FD3F901E6536935FB2BA * L_1 = L_0;\n        int32_t L_2 = L_1->get_x_0();\n        int32_t L_3 = ___b1;\n        L_1->set_x_0(((int32_t)il2cpp_codegen_add((int32_t)L_2, (int32_t)L_3)));\n        // }\n        return;\n    }\n}\n\n// Other platforms have NullCheck\nIL2CPP_EXTERN_C IL2CPP_METHOD_ATTR void FT_AOT_Class_Run2_m0451FFC153671CD294EB1178A01AB2D92202624C (FT_AOT_Class_t03C2F346FF0EA8694088FD3F901E6536935FB2BA * ___s0, int32_t ___b1, const RuntimeMethod* method)\n{\n    {\n        // s.x += b;\n        FT_AOT_Class_t03C2F346FF0EA8694088FD3F901E6536935FB2BA * L_0 = ___s0;\n        FT_AOT_Class_t03C2F346FF0EA8694088FD3F901E6536935FB2BA * L_1 = L_0;\n        NullCheck(L_1);\n        int32_t L_2 = L_1->get_x_0();\n        int32_t L_3 = ___b1;\n        NullCheck(L_1);\n        L_1->set_x_0(((int32_t)il2cpp_codegen_add((int32_t)L_2, (int32_t)L_3)));\n        // }\n        return;\n    }\n}\n")),(0,a.kt)("h2",{id:"mono-bug-with-open-delegate-call-on-valuetype-member-function-copying-instead-of-passing-ref"},"Mono bug with open delegate call on ValueType member function copying instead of passing ref"),(0,a.kt)("p",null,"Works correctly in il2cpp."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'        public void void_valuetype_instance_open_interp()\n        {\n            var b = new FT_ValueType() { x = 1, y = 2f, z = "abc" };\n            var m = typeof(FT_ValueType).GetMethod("Run");\n            var invoke = typeof(ValueTypeRun).GetMethod("Invoke");\n            var del = (ValueTypeRun)Delegate.CreateDelegate(typeof(ValueTypeRun), null, m);\n\n            object c = b;\n            invoke.Invoke(del, new object[] { c, 1 });\n            // mono BUG!!! mono will assert fail here, get value 1.\n            // But il2cpp is correct!\n            Assert.Equal(2, ((FT_ValueType)c).x);\n\n            var dd = del + del;\n            invoke.Invoke(dd, new object[] { c, 1 });\n            Assert.Equal(4, ((FT_ValueType)c).x);\n        }\n')))}u.isMDXComponent=!0}}]);