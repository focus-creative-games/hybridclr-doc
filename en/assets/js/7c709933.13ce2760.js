"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1811],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>f});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=d(a),m=r,f=p["".concat(l,".").concat(m)]||p[m]||u[m]||o;return a?n.createElement(f,i(i({ref:t},c),{},{components:a})):n.createElement(f,i({ref:t},c))}));function f(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var d=2;d<o;d++)i[d]=a[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},45588:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var n=a(87462),r=(a(67294),a(3905));const o={},i="Best Practices",s={unversionedId:"basic/bestpractice",id:"basic/bestpractice",title:"Best Practices",description:"Unity Version Recommendation",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/basic/bestpractice.md",sourceDirName:"basic",slug:"/basic/bestpractice",permalink:"/en/docs/basic/bestpractice",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"hybridclr Package Manual",permalink:"/en/docs/basic/com.code-philosophy.hybridclr"},next:{title:"Migrating from netstandard to .Net Framework",permalink:"/en/docs/basic/migratefromnetstandard"}},l={},d=[{value:"Unity Version Recommendation",id:"unity-version-recommendation",level:2},{value:"Don&#39;t Save assemblyBytes After Assembly.Load",id:"dont-save-assemblybytes-after-assemblyload",level:2},{value:"Recommend Mounting Startup Scripts to the First Hot Update Scene Loaded After Hot Update Completion",id:"recommend-mounting-startup-scripts-to-the-first-hot-update-scene-loaded-after-hot-update-completion",level:2},{value:"Timing of <code>RuntimeApi.LoadMetadataForAOTAssembly</code> Calls",id:"timing-of-runtimeapiloadmetadataforaotassembly-calls",level:2},{value:"<code>Assembly.Load</code> or <code>RuntimeApi.LoadMetadataForAOTAssembly</code> Taking Too Long, Causing Game Stuttering",id:"assemblyload-or-runtimeapiloadmetadataforaotassembly-taking-too-long-causing-game-stuttering",level:2},{value:"For Performance-Sensitive Interactions Between Native and Interpreter Parts, Don&#39;t Use Reflection - Use Delegates or Virtual Functions Instead",id:"for-performance-sensitive-interactions-between-native-and-interpreter-parts-dont-use-reflection---use-delegates-or-virtual-functions-instead",level:2},{value:"Hot Update Layer Returns a Delegate",id:"hot-update-layer-returns-a-delegate",level:3},{value:"Use Delegate.Create to Create Corresponding Delegate Based on MethodInfo",id:"use-delegatecreate-to-create-corresponding-delegate-based-on-methodinfo",level:3},{value:"Don&#39;t Use <code>faster(smaller) builds</code> Option in 2021 Versions",id:"dont-use-fastersmaller-builds-option-in-2021-versions",level:2}],c={toc:d},p="wrapper";function u(e){let{components:t,...a}=e;return(0,r.kt)(p,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"best-practices"},"Best Practices"),(0,r.kt)("h2",{id:"unity-version-recommendation"},"Unity Version Recommendation"),(0,r.kt)("p",null,"Recommend using ",(0,r.kt)("inlineCode",{parentName:"p"},"2020.3.x(x >= 21)")," series and ",(0,r.kt)("inlineCode",{parentName:"p"},"2021.3.x")," series, which are the most stable."),(0,r.kt)("h2",{id:"dont-save-assemblybytes-after-assemblyload"},"Don't Save assemblyBytes After Assembly.Load"),(0,r.kt)("p",null,"Don't save the assembly's byte[] data after calling Assembly.Load, as Assembly.Load automatically makes a copy internally."),(0,r.kt)("h2",{id:"recommend-mounting-startup-scripts-to-the-first-hot-update-scene-loaded-after-hot-update-completion"},"Recommend Mounting Startup Scripts to the First Hot Update Scene Loaded After Hot Update Completion"),(0,r.kt)("p",null,"Recommend mounting startup scripts to the startup hot update scene, which allows zero-modification conversion of non-hot update projects to hot update projects without requiring any reflection operations."),(0,r.kt)("h2",{id:"timing-of-runtimeapiloadmetadataforaotassembly-calls"},"Timing of ",(0,r.kt)("inlineCode",{parentName:"h2"},"RuntimeApi.LoadMetadataForAOTAssembly")," Calls"),(0,r.kt)("p",null,"You only need to call it before using AOT generics (only needs to be called once), and theoretically the earlier the better. In practice, reasonable timing is after hot update completion, or after hot update dll loading but before executing any code. If supplemental metadata dlls are also packaged into the main package as additional data files, loading them during main project startup is better. Refer to the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/focus-creative-games/hybridclr_trial"},"HybridCLR_trial")," project"),(0,r.kt)("h2",{id:"assemblyload-or-runtimeapiloadmetadataforaotassembly-taking-too-long-causing-game-stuttering"},(0,r.kt)("inlineCode",{parentName:"h2"},"Assembly.Load")," or ",(0,r.kt)("inlineCode",{parentName:"h2"},"RuntimeApi.LoadMetadataForAOTAssembly")," Taking Too Long, Causing Game Stuttering"),(0,r.kt)("p",null,"You can put them in other threads for asynchronous loading."),(0,r.kt)("h2",{id:"for-performance-sensitive-interactions-between-native-and-interpreter-parts-dont-use-reflection---use-delegates-or-virtual-functions-instead"},"For Performance-Sensitive Interactions Between Native and Interpreter Parts, Don't Use Reflection - Use Delegates or Virtual Functions Instead"),(0,r.kt)("p",null,"Taking the Update function as an example, most people would think of interaction between the main project and hot update part like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'var klass = ass.GetType("App");\nvar method = klass.GetMethod("Update");\nmethod.Invoke(null, new object[] {deltaTime});\n')),(0,r.kt)("p",null,"The disadvantage of this approach is high reflection cost, and if parameters are involved, additional GC occurs. Actually, there are more efficient methods. There are mainly two approaches:"),(0,r.kt)("h3",{id:"hot-update-layer-returns-a-delegate"},"Hot Update Layer Returns a Delegate"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'// Hotfix.asmdf hot update part \nclass App\n{\n    public static Action<float> GetUpdateDelegate()\n    {\n        return Update;\n    }\n\n    public static void Update(float deltaTime)\n    {\n    }\n}\n\n// Main.asmdf main project\nvar klass = ass.GetType("App");\nvar method = klass.GetMethod("GetUpdateDelegate");\nvar updateDel = (Action<float>)method.Invoke(null, null);\n\nupdateDel(deltaTime);\n')),(0,r.kt)("h3",{id:"use-delegatecreate-to-create-corresponding-delegate-based-on-methodinfo"},"Use Delegate.Create to Create Corresponding Delegate Based on MethodInfo"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},'var klass = ass.GetType("App");\nvar method = klass.GetMethod("Update");\nupdateDel = (Action<float>)System.Delegate.CreateDelegate(typeof(Action<float>), null, method);\nupdateDel(deltaTime);\n')),(0,r.kt)("h2",{id:"dont-use-fastersmaller-builds-option-in-2021-versions"},"Don't Use ",(0,r.kt)("inlineCode",{parentName:"h2"},"faster(smaller) builds")," Option in 2021 Versions"),(0,r.kt)("p",null,"Starting from 2021.3.x LTS versions, il2cpp fully supports ",(0,r.kt)("inlineCode",{parentName:"p"},"full generic sharing")," technology. When the ",(0,r.kt)("inlineCode",{parentName:"p"},"Il2Cpp Code Generation")," option in Build Settings is ",(0,r.kt)("inlineCode",{parentName:"p"},"faster runtime"),", it uses the standard generic sharing mechanism; when it's ",(0,r.kt)("inlineCode",{parentName:"p"},"faster(smaller) builds"),", it enables the ",(0,r.kt)("inlineCode",{parentName:"p"},"full generic sharing")," mechanism."),(0,r.kt)("p",null,"When ",(0,r.kt)("inlineCode",{parentName:"p"},"full generic sharing")," is enabled, each generic function (regardless of whether generic parameters are value types or class types) completely shares a single copy of code. The advantage is saving package size, but the disadvantage is severely hurting generic function performance. Fully generic shared code compared to standard generic shared code can sometimes be several to dozens of times slower, even worse than pure interpretation versions. Therefore, it's strongly recommended to ",(0,r.kt)("strong",{parentName:"p"},"not enable")," the ",(0,r.kt)("inlineCode",{parentName:"p"},"faster(smaller) builds")," option."))}u.isMDXComponent=!0}}]);