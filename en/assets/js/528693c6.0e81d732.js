"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2261],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>y});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),p=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=p(e.components);return a.createElement(c.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),m=p(n),u=r,y=m["".concat(c,".").concat(u)]||m[u]||d[u]||i;return n?a.createElement(y,l(l({ref:t},s),{},{components:n})):a.createElement(y,l({ref:t},s))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=u;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o[m]="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},75523:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const i={},l="Memory and GC",o={unversionedId:"basic/memory",id:"basic/memory",title:"Memory and GC",description:"object memory size",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/basic/memory.md",sourceDirName:"basic",slug:"/basic/memory",permalink:"/en/docs/basic/memory",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"DOTS Support",permalink:"/en/docs/basic/dots"},next:{title:"Performance",permalink:"/en/docs/basic/performance"}},c={},p=[{value:"object memory size",id:"object-memory-size",level:2},{value:"primitive type",id:"primitive-type",level:3},{value:"struct value type",id:"struct-value-type",level:3},{value:"class type",id:"class-type",level:3},{value:"Compared with the object memory size of lua and ILRuntime",id:"compared-with-the-object-memory-size-of-lua-and-ilruntime",level:2},{value:"The memory occupied by the loaded assembly",id:"the-memory-occupied-by-the-loaded-assembly",level:2},{value:"GC during operation",id:"gc-during-operation",level:2}],s={toc:p},m="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(m,(0,a.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"memory-and-gc"},"Memory and GC"),(0,r.kt)("h2",{id:"object-memory-size"},"object memory size"),(0,r.kt)("p",null,"HybridCLR is a CLR-level implementation. The hot update type is executed in the interpretation mode, and the other methods are exactly the same as the AOT part. Therefore define equivalent types, whether in AOT or hot update, the object size is exactly the same."),(0,r.kt)("h3",{id:"primitive-type"},"primitive type"),(0,r.kt)("p",null,"Such as byte, int. As we all know, byte occupies 1 byte, int occupies 4 bytes, and others will not be described in detail."),(0,r.kt)("h3",{id:"struct-value-type"},"struct value type"),(0,r.kt)("p",null,"In the case where Explicit Layout is not specified, the total size is calculated according to the field size and memory alignment rules, which is similar to the struct calculation rules of C++. I won\u2019t elaborate here, just give an example."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// V1 object size 1\nstruct V1\n{\n     public byte a1;\n}\n\n// V2 object size 8\nstruct V2\n{\n     public byte a1;\n     public int a2;\n}\n\n// V3 object size 24\nstruct V3\n{\n     public int a1;\n     public int a2;\n     public object a3;\n     public byte a4;\n}\n")),(0,r.kt)("h3",{id:"class-type"},"class type"),(0,r.kt)("p",null,"Similar to the value type, but with 16 bytes of object header, and enforces memory alignment to 8 bytes. Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"// C1 object size 24\nclass C1\n{\n     public byte a1;\n}\n// C2 object size 24\nclass C2\n{\n     public byte a1;\n     public int a2;\n}\n// C3 object size 40\nclass C3\n{\n     public int a1;\n     public int a2;\n     public object a3;\n     public byte a4;\n}\n")),(0,r.kt)("h2",{id:"compared-with-the-object-memory-size-of-lua-and-ilruntime"},"Compared with the object memory size of lua and ILRuntime"),(0,r.kt)("p",null,"The calculation rules of lua are slightly complicated, see ",(0,r.kt)("a",{parentName:"p",href:"https://www.linuxidc.com/Linux/2018-10/154971.htm"},"third-party article"),". An empty table occupies 56 bytes, and each additional field occupies at least 32 bytes."),(0,r.kt)("p",null,"The type of ILRuntime is expressed in IlTypeInstance except enum. The empty type occupies 72 bytes, and each additional field uses at least 16 bytes. If the object contains reference type data, there will be at least 24 bytes more overall, and each additional object field will add 8 bytes."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"center"},"Type"),(0,r.kt)("th",{parentName:"tr",align:"center"},"Xlua"),(0,r.kt)("th",{parentName:"tr",align:"center"},"ILRuntime"),(0,r.kt)("th",{parentName:"tr",align:"center"},"HybridCLR/native il2cpp"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"V1"),(0,r.kt)("td",{parentName:"tr",align:"center"},"88+"),(0,r.kt)("td",{parentName:"tr",align:"center"},"88"),(0,r.kt)("td",{parentName:"tr",align:"center"},"1")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"V2"),(0,r.kt)("td",{parentName:"tr",align:"center"},"120+"),(0,r.kt)("td",{parentName:"tr",align:"center"},"104"),(0,r.kt)("td",{parentName:"tr",align:"center"},"8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"V3"),(0,r.kt)("td",{parentName:"tr",align:"center"},"184+"),(0,r.kt)("td",{parentName:"tr",align:"center"},"168"),(0,r.kt)("td",{parentName:"tr",align:"center"},"24")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"C1"),(0,r.kt)("td",{parentName:"tr",align:"center"},"88+"),(0,r.kt)("td",{parentName:"tr",align:"center"},"88"),(0,r.kt)("td",{parentName:"tr",align:"center"},"24")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"C2"),(0,r.kt)("td",{parentName:"tr",align:"center"},"120+"),(0,r.kt)("td",{parentName:"tr",align:"center"},"104"),(0,r.kt)("td",{parentName:"tr",align:"center"},"24")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"center"},"C3"),(0,r.kt)("td",{parentName:"tr",align:"center"},"184+"),(0,r.kt)("td",{parentName:"tr",align:"center"},"168"),(0,r.kt)("td",{parentName:"tr",align:"center"},"40")))),(0,r.kt)("h2",{id:"the-memory-occupied-by-the-loaded-assembly"},"The memory occupied by the loaded assembly"),(0,r.kt)("p",null,"When loading an assembly, a dll file byte array is copied, and metadata is dynamically generated in memory. The final memory is generally 1-5 times the size of the assembly (not a lot of statistics)."),(0,r.kt)("h2",{id:"gc-during-operation"},"GC during operation"),(0,r.kt)("p",null,"HybridCLR is implemented strictly according to the specifications. Except that the additional CPU and memory will be consumed when the assembly is loaded and the function is transferred for the first time, the memory consumed at runtime is exactly the same as that of il2cpp."),(0,r.kt)("p",null,"So you don't have to ask questions such as whether ",(0,r.kt)("inlineCode",{parentName:"p"},"foreach loop will generate GC"),". How many GCs are generated under il2cpp or mono, and the exact same GCs are also generated when interpreted and executed in HybridCLR."))}d.isMDXComponent=!0}}]);