"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1609],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>b});var a=n(67294);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,i=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=c(n),p=l,b=u["".concat(s,".").concat(p)]||u[p]||m[p]||i;return n?a.createElement(b,r(r({ref:t},d),{},{components:n})):a.createElement(b,r({ref:t},d))}));function b(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var i=n.length,r=new Array(i);r[0]=p;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[u]="string"==typeof e?e:l,r[1]=o;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},8794:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var a=n(87462),l=(n(67294),n(3905));const i={},r="Manual",o={unversionedId:"business/reload/manual",id:"business/reload/manual",title:"Manual",description:"Supported Features",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/business/reload/manual.md",sourceDirName:"business/reload",slug:"/business/reload/manual",permalink:"/en/docs/business/reload/manual",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Quick Start",permalink:"/en/docs/business/reload/quickstart"},next:{title:"Common Errors",permalink:"/en/docs/business/reload/commonerrors"}},s={},c=[{value:"Supported Features",id:"supported-features",level:2},{value:"Unsupported Features and Special Requirements",id:"unsupported-features-and-special-requirements",level:2},{value:"Memory Unload Rate",id:"memory-unload-rate",level:2},{value:"Installation",id:"installation",level:2},{value:"Full Generic Sharing",id:"full-generic-sharing",level:2},{value:"Code Encryption",id:"code-encryption",level:2},{value:"Access Control",id:"access-control",level:2},{value:"Unloading Assemblies",id:"unloading-assemblies",level:2},{value:"RuntimeApi::TryUnloadAssembly",id:"runtimeapitryunloadassembly",level:3},{value:"RuntimeApi::ForceUnloadAssembly",id:"runtimeapiforceunloadassembly",level:3},{value:"HotReload Compatibility Check",id:"hotreload-compatibility-check",level:2},{value:"Resolving References to Unloaded Objects",id:"resolving-references-to-unloaded-objects",level:2},{value:"Known Libraries with Compatibility Issues",id:"known-libraries-with-compatibility-issues",level:2}],d={toc:c},u="wrapper";function m(e){let{components:t,...i}=e;return(0,l.kt)(u,(0,a.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"manual"},"Manual"),(0,l.kt)("h2",{id:"supported-features"},"Supported Features"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Supports unloading assemblies, unloading 100% of the memory occupied by assemblies"),(0,l.kt)("li",{parentName:"ul"},"Supports reloading assemblies, code can change arbitrarily or even be completely different (MonoBehaviour and Scriptable have certain limitations)"),(0,l.kt)("li",{parentName:"ul"},"Supports ",(0,l.kt)("strong",{parentName:"li"},"limiting the set of functions that can be accessed within hot update assemblies"),", suitable for creating sandbox environments in UGC games to prevent malicious player code from causing damage.")),(0,l.kt)("h2",{id:"unsupported-features-and-special-requirements"},"Unsupported Features and Special Requirements"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Requires business code to no longer use objects or functions from unloaded assemblies, and to exit all executing old logic"),(0,l.kt)("li",{parentName:"ul"},"Cannot directly unload dependent assemblies; must unload in reverse dependency order, first unloading dependents, then dependencies. For example, if A.dll depends on B.dll, A.dll must be unloaded first, then B.dll"),(0,l.kt)("li",{parentName:"ul"},"MonoBehaviour and ScriptableObject related",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Requires that event or message functions like Awake, OnEnable in reloaded MonoBehaviour do not change in number (but function bodies can change)"),(0,l.kt)("li",{parentName:"ul"},"Requires that serialized field names of script classes with the same name in the old assembly do not change after reloading (types can change)"),(0,l.kt)("li",{parentName:"ul"},"If field type is a custom type A (class, struct, or enum) from an unloadable assembly, it must be marked with the ",(0,l.kt)("inlineCode",{parentName:"li"},"[Serializable]")," attribute"),(0,l.kt)("li",{parentName:"ul"},"Does not support field types like ",(0,l.kt)("inlineCode",{parentName:"li"},"List<A>")," where A is a type from an unloadable assembly; replace with ",(0,l.kt)("inlineCode",{parentName:"li"},"A[]")),(0,l.kt)("li",{parentName:"ul"},"Cannot inherit from generic types, e.g., ",(0,l.kt)("inlineCode",{parentName:"li"},"class MyScript : CommonScript<int>")))),(0,l.kt)("li",{parentName:"ul"},"Some libraries that cache reflection information (this behavior is most common in serialization-related libraries like LitJson) need to clear cached reflection information after hot reload"),(0,l.kt)("li",{parentName:"ul"},"Does not support destructors, ~XXX(). Also does not allow instantiation of generic classes with destructors where generic parameters include types from this assembly"),(0,l.kt)("li",{parentName:"ul"},"Incompatible with DOTS. Due to DOTS heavily caching type information and complex implementation, it's difficult to individually clear cached information.")),(0,l.kt)("h2",{id:"memory-unload-rate"},"Memory Unload Rate"),(0,l.kt)("p",null,"Except for the following metadata memory that cannot be unloaded, almost all (99.9%) metadata can be unloaded:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Script classes like MonoBehaviour, ScriptableObject. Their corresponding Il2CppClass at runtime level is referenced internally by Unity engine and cannot be released, but most member metadata like methods can be released"),(0,l.kt)("li",{parentName:"ul"},"Types marked with ",(0,l.kt)("inlineCode",{parentName:"li"},"[Serializable]"),". Similar to MonoBehaviour, they may also be referenced internally by Unity engine during serialization and cannot be released."),(0,l.kt)("li",{parentName:"ul"},"Generic classes used during assembly execution that don't involve types from this assembly. For example, ",(0,l.kt)("inlineCode",{parentName:"li"},"List<int>")," metadata won't be released, but ",(0,l.kt)("inlineCode",{parentName:"li"},"List<MyHotReloadClass>")," will be released")),(0,l.kt)("p",null,"All unreleased metadata (MonoBehaviour, Serializable classes) will be ",(0,l.kt)("strong",{parentName:"p"},"reused")," when reloading the assembly. Multiple loads and unloads of the same assembly will only cause one unreleased behavior and won't lead to leakage or continuous growth of unreleased metadata memory."),(0,l.kt)("p",null,"In actual projects, for most assemblies, over 99% of metadata memory can be unloaded."),(0,l.kt)("h2",{id:"installation"},"Installation"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Extract hybridclr_unity and place it in the project Packages directory, rename it to com.code-philosophy.hybridclr"),(0,l.kt)("li",{parentName:"ul"},"Extract the corresponding ",(0,l.kt)("inlineCode",{parentName:"li"},"il2cpp_plus-{version}.zip")," according to your Unity version"),(0,l.kt)("li",{parentName:"ul"},"Extract ",(0,l.kt)("inlineCode",{parentName:"li"},"hybridclr.zip")),(0,l.kt)("li",{parentName:"ul"},"Place the hybridclr directory from the extracted ",(0,l.kt)("inlineCode",{parentName:"li"},"hybridclr.zip")," into the libil2cpp directory from the extracted ",(0,l.kt)("inlineCode",{parentName:"li"},"il2cpp-{version}.zip")),(0,l.kt)("li",{parentName:"ul"},"Open ",(0,l.kt)("inlineCode",{parentName:"li"},"HybridCLR/Installer"),", enable the ",(0,l.kt)("inlineCode",{parentName:"li"},"Copy libil2cpp from local")," option, select the libil2cpp directory you just extracted, and perform the installation")),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"installer",src:n(69456).Z,width:"802",height:"563"})),(0,l.kt)("h2",{id:"full-generic-sharing"},"Full Generic Sharing"),(0,l.kt)("p",null,"See ",(0,l.kt)("a",{parentName:"p",href:"../fullgenericsharing"},"Full Generic Sharing"),"."),(0,l.kt)("h2",{id:"code-encryption"},"Code Encryption"),(0,l.kt)("p",null,"See ",(0,l.kt)("a",{parentName:"p",href:"../basicencryption"},"Code Protection"),"."),(0,l.kt)("h2",{id:"access-control"},"Access Control"),(0,l.kt)("p",null,"Sometimes you may want to limit the scope of types and functions that hot update code can access. For example, sandbox games may not want UGC code to access file reading interfaces. Access control can achieve this goal."),(0,l.kt)("p",null,"Please read the detailed documentation ",(0,l.kt)("a",{parentName:"p",href:"../accesspolicy"},"Access Control Policy"),"."),(0,l.kt)("h2",{id:"unloading-assemblies"},"Unloading Assemblies"),(0,l.kt)("p",null,"Currently, two interfaces are provided for unloading assemblies:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"RuntimeApi::TryUnloadAssembly"),(0,l.kt)("li",{parentName:"ul"},"RuntimeApi::ForceUnloadAssembly")),(0,l.kt)("h3",{id:"runtimeapitryunloadassembly"},"RuntimeApi::TryUnloadAssembly"),(0,l.kt)("p",null,"This interface attempts to unload an assembly. If unloading completes normally, report.success is true; otherwise, the report.success field is false."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'        /// <summary>\n        /// Attempts to unload the assembly.\n        /// </summary>\n        /// <param name="assembly">The assembly to unload.</param>\n        /// <param name="printObjectReferenceLink">If true, prints the reference chain when illegal references are detected. Enabling this may increase unloading time.</param>\n        /// <returns></returns>\n        public static UnloadAssemblyReport TryUnloadAssembly(Assembly assembly, bool printObjectReferenceLink)\n        {\n            //...\n        }\n')),(0,l.kt)("p",null,"If printObjectReferenceLink is true, it will significantly increase unloading time. It's recommended to first try unloading with printObjectReferenceLink as false, and if it fails, then use printObjectReferenceLink as true for unloading. Example code as follows:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},"\n    void TwoPhaseUnloadAssembly(Assembly ass)\n    {\n        var report = RuntimeApi.TryUnloadAssembly(ass, false);\n        if (!report.success)\n        {\n            report = RuntimeApi.TryUnloadAssembly(ass, true);\n            foreach (string log in report.invalidObjectReferenceLinkLogs)\n            {\n                Debug.LogError(log);\n            }\n        }\n    }\n\n")),(0,l.kt)("h3",{id:"runtimeapiforceunloadassembly"},"RuntimeApi::ForceUnloadAssembly"),(0,l.kt)("p",null,"This interface forcefully unloads an assembly and returns an UnloadAssemblyReport. If unloading completes normally, report.success is true; otherwise, the report.success field is false. Regardless of the return result, the assembly will be removed."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'        /// <summary>\n        /// Forcefully unloads the assembly regardless of remaining references to it in the AppDomain.\n        /// </summary>\n        /// <param name="assembly">The assembly to be unloaded.</param>\n        /// <param name="ignoreObjectReferenceValidation">Whether to skip LiveObjectValidator\'s illegal reference checking. Recommended to set to false.</param>\n        /// <param name="printObjectReferenceLink">If true, prints reference chains when illegal references are detected. Enabling this may increase unloading time.</param>\n        /// <returns>Indicates whether no illegal references were found (true means no illegal references, false means some exist).</returns>\n        /// <exception cref="UnloadAssemblyException">Thrown when assembly unloading fails.</exception>\n        public static UnloadAssemblyReport ForceUnloadAssembly(Assembly assembly, bool ignoreObjectReferenceValidation, bool printObjectReferenceLink)\n        {\n            // ...\n        }\n')),(0,l.kt)("h2",{id:"hotreload-compatibility-check"},"HotReload Compatibility Check"),(0,l.kt)("p",null,"Due to Unity engine internally caching some type (MonoBehaviour, Serializable classes) metadata, these classes have certain usage limitations. Violating these limitations may cause runtime crashes.\n",(0,l.kt)("inlineCode",{parentName:"p"},"HybridCLR.Editor.HotReload.HotReloadCompatibilityValidator")," can detect most code incompatible with hot reload in advance."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-csharp"},'        [MenuItem("Test/CheckCompatibility")]\n        public static void CheckCompatibility()\n        {\n            BuildTarget target = EditorUserBuildSettings.activeBuildTarget;\n            CompileDllCommand.CompileDll(target);\n            // This should contain hot reload assemblies, not hot update assemblies. \n            // Please don\'t add assemblies that don\'t need hot reload to this list.\n            var hotReloadDlls = new List<string> { "Tests" };\n            var assResolver = MetaUtil.CreateHotUpdateAndAOTAssemblyResolver(target, hotReloadDlls);\n            var validator = new HotReloadCompatibilityValidator(hotReloadDlls, assResolver);\n            if (!validator.Validate())\n            {\n                UnityEngine.Debug.LogError("CheckCompatibility failed");\n            }\n        }\n\n')),(0,l.kt)("h2",{id:"resolving-references-to-unloaded-objects"},"Resolving References to Unloaded Objects"),(0,l.kt)("p",null,"Hot reload technology requires that no metadata from unloaded assembly U should be held in unloaded assemblies or global memory. This includes but is not limited to:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Instances of types from unloaded assemblies"),(0,l.kt)("li",{parentName:"ul"},"Generic classes or functions with generic parameters containing types from unloaded assemblies"),(0,l.kt)("li",{parentName:"ul"},"Reflection information related to unloaded assemblies, such as Assembly, Type, MethodInfo, PropertyInfo, etc."),(0,l.kt)("li",{parentName:"ul"},"Delegates pointing to functions in unloaded assemblies"),(0,l.kt)("li",{parentName:"ul"},"Async Tasks defined in unloaded assemblies"),(0,l.kt)("li",{parentName:"ul"},"Others")),(0,l.kt)("p",null,"Actual projects can be very complex, and it's difficult and impractical for developers to find all illegal references. We have implemented illegal reference checking, and the unloading process will print logs of all illegal references. Developers can clear all illegal references based on the printed logs."),(0,l.kt)("h2",{id:"known-libraries-with-compatibility-issues"},"Known Libraries with Compatibility Issues"),(0,l.kt)("p",null,"Most incompatibility issues are essentially caused by caching of unloaded objects, types, or functions. These incompatibility issues can be resolved by manually clearing these illegal references."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Jobs in 2022 will cache type-related information, requiring minor ",(0,l.kt)("a",{parentName:"li",href:"/en/docs/business/reload/modifydll"},"modifications to UnityEngine.CoreModule.dll")," code. Versions below 2022 don't need modifications"),(0,l.kt)("li",{parentName:"ul"},"Deserialization libraries like LitJson will cache reflection information and need to clear cached reflection information in the library after hot reload. Specific operations depend on the library's implementation")))}m.isMDXComponent=!0},69456:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/ultimate-installer-2ca1e4616b01f9e02b2de3384a53f585.jpg"}}]);