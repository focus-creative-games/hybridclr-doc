"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[1693],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),l=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=l(e.components);return i.createElement(s.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),m=l(n),u=a,f=m["".concat(s,".").concat(u)]||m[u]||p[u]||r;return n?i.createElement(f,o(o({ref:t},d),{},{components:n})):i.createElement(f,o({ref:t},d))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=u;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c[m]="string"==typeof e?e:a,o[1]=c;for(var l=2;l<r;l++)o[l]=n[l];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5991:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var i=n(7462),a=(n(7294),n(3905));const r={},o="Execution performance",c={unversionedId:"basic/performance",id:"basic/performance",title:"Execution performance",description:"Although HybridCLR is also interpreted and executed, both theoretical principles and real machine test data show that HybridCLR has greatly improved performance (several times or even dozens of times) compared to the current popular hot update solutions such as lua and ILRuntime.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/basic/performance.md",sourceDirName:"basic",slug:"/basic/performance",permalink:"/en/docs/basic/performance",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Memory and GC",permalink:"/en/docs/basic/memory"},next:{title:"Unsupported features",permalink:"/en/docs/basic/notsupportedfeatures"}},s={},l=[{value:"testing report",id:"testing-report",level:2},{value:"principle",id:"principle",level:2},{value:"Rewritten streamlined and efficient metadata parsing library",id:"rewritten-streamlined-and-efficient-metadata-parsing-library",level:3},{value:"Use the register instruction set",id:"use-the-register-instruction-set",level:3},{value:"Direct access to data stack and execution stack",id:"direct-access-to-data-stack-and-execution-stack",level:3},{value:"Directive static specialization",id:"directive-static-specialization",level:3},{value:"Calculate the runtime metadata that needs to be resolved in advance",id:"calculate-the-runtime-metadata-that-needs-to-be-resolved-in-advance",level:3},{value:"Object member access instructions are simple and efficient",id:"object-member-access-instructions-are-simple-and-efficient",level:3},{value:"Directly support reference and pointer operations without indirect methods",id:"directly-support-reference-and-pointer-operations-without-indirect-methods",level:3},{value:"Unified metadata, more efficient object creation, and smaller memory footprint",id:"unified-metadata-more-efficient-object-creation-and-smaller-memory-footprint",level:3},{value:"The metadata is unified, the function calling method is unified, and there is no additional overhead of PInvoke and ReservePInvoke",id:"the-metadata-is-unified-the-function-calling-method-is-unified-and-there-is-no-additional-overhead-of-pinvoke-and-reservepinvoke",level:3},{value:"additionally provide a large number of instinct functions",id:"additionally-provide-a-large-number-of-instinct-functions",level:3},{value:"Strictly follow the specification and do not introduce additional unnecessary costs",id:"strictly-follow-the-specification-and-do-not-introduce-additional-unnecessary-costs",level:3},{value:"Other instruction optimization techniques",id:"other-instruction-optimization-techniques",level:3},{value:"Appendix: Test case code",id:"appendix-test-case-code",level:2}],d={toc:l},m="wrapper";function p(e){let{components:t,...r}=e;return(0,a.kt)(m,(0,i.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"execution-performance"},"Execution performance"),(0,a.kt)("p",null,"Although HybridCLR is also interpreted and executed, both theoretical principles and real machine test data show that HybridCLR has greatly improved performance (several times or even dozens of times) compared to the current popular hot update solutions such as lua and ILRuntime."),(0,a.kt)("h2",{id:"testing-report"},"testing report"),(0,a.kt)("p",null,"The community version of HybridCLR is much (several times to tens of times) better than the Lua solution except that its numerical calculation is equal to that of Lua."),(0,a.kt)("p",null,"The HybridCLR of the ",(0,a.kt)("strong",{parentName:"p"},"commercial version")," has greatly optimized the performance of numerical calculations, with a performance improvement of nearly 300%. Most other common instructions also have a performance improvement of 50%-200%. Developers who have strict requirements on performance can contact us ",(0,a.kt)("a",{parentName:"p",href:"/en/docs/other/business"},"Business Services"),"."),(0,a.kt)("p",null,"The following is the test report of the community version of HybridCLR under the iphone 11 and Xiaomi 5C mobile phones. The test code is at the end of the appendix."),(0,a.kt)("p",null,"!> Note that the test cases of test2, test8, and test9 are extremely unreasonable. In the case of AOT, they will be completely optimized by the compiler, resulting in a time of 0. real gap\nIt should be between 10-30 times."),(0,a.kt)("p",null,"AOT lines are native il2cpp data. The HotFix line is HybridCLR data. Lua lines are data for xlua."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"iphone11",src:n(6247).Z,width:"859",height:"487"})),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"xiaomi5c",src:n(8220).Z,width:"859",height:"512"})),(0,a.kt)("p",null,"The following is the performance improvement data of the commercial version under some test cases compared with the community version."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"interpreter_optimization",src:n(5980).Z,width:"859",height:"493"})),(0,a.kt)("p",null,"The following is the performance comparison between AOT and HybridCLR after optimization in terms of numerical calculation. The addition is about 7-16 times, the multiplication is 4 times, and the division is 2 times."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"benchmark_numeric",src:n(8412).Z,width:"859",height:"525"})),(0,a.kt)("h2",{id:"principle"},"principle"),(0,a.kt)("p",null,"Since HybridCLR is implemented in C++ and seamlessly integrated directly with il2cpp runtime, it can directly access the underlying data and various interfaces of runtime. Compared with ILRuntime and Xlua, the additional cost of the C# layer is saved, and the interaction cost is greatly reduced."),(0,a.kt)("p",null,"The excellent performance of HybridCLR mainly comes from the following aspects:"),(0,a.kt)("h3",{id:"rewritten-streamlined-and-efficient-metadata-parsing-library"},"Rewritten streamlined and efficient metadata parsing library"),(0,a.kt)("p",null,"We did not use the ready-made metadata parsing library, and implemented a C++ version of streamlined and efficient metadata according to the requirements of HybridCLR\nparsing library. Other C# hot update or hotfix solutions use C# libraries such as Cecil, and there is a huge gap in memory and loading efficiency!"),(0,a.kt)("h3",{id:"use-the-register-instruction-set"},"Use the register instruction set"),(0,a.kt)("p",null,"The original IL bytecode is a stack-based instruction set, and HybridCLR converts it into a register instruction set, which reduces the stack maintenance overhead."),(0,a.kt)("h3",{id:"direct-access-to-data-stack-and-execution-stack"},"Direct access to data stack and execution stack"),(0,a.kt)("p",null,"Stack operations are the most common operations in the CLI, and almost all instructions involve stack operations. Since the interpreter stack is the heap memory maintained by itself, the CLI has restrictions on the pointer operation of the struct. If the interpreter is implemented in C#,\nYou cannot directly manipulate data types on the interpreter stack, and you have to use various tricks to achieve this purpose indirectly. The HybridCLR is implemented in C++ and can be directly manipulated."),(0,a.kt)("p",null,"The efficiency of manipulating struct types is several times to dozens of times higher than other interpreters."),(0,a.kt)("h3",{id:"directive-static-specialization"},"Directive static specialization"),(0,a.kt)("p",null,"Some instructions such as the ",(0,a.kt)("inlineCode",{parentName:"p"},"add")," instruction are multi-function instructions, and the final operation is determined according to the type of the operand on the current stack. HybridCLR designed four instructions ",(0,a.kt)("inlineCode",{parentName:"p"},"add_i4, add_i8, add_r4, add_r8")," for it, when translating instructions\nCalculate the data type of the current stack and translate it into the corresponding specialization instruction. It saves the overhead of judging the type at runtime, and also saves the overhead of maintaining data types at runtime."),(0,a.kt)("h3",{id:"calculate-the-runtime-metadata-that-needs-to-be-resolved-in-advance"},"Calculate the runtime metadata that needs to be resolved in advance"),(0,a.kt)("p",null,"Some instructions such as ldtoken and ldstr need to convert the data in the instruction into actual runtime data at runtime. HybridCLR directly calculates the corresponding runtime data during translation and saves it in the converted instruction.\ngreatly improved performance"),(0,a.kt)("h3",{id:"object-member-access-instructions-are-simple-and-efficient"},"Object member access instructions are simple and efficient"),(0,a.kt)("p",null,"Object member access instructions like ",(0,a.kt)("inlineCode",{parentName:"p"},"v.x = b;")," are very common. Due to the limitations of the C# language, like ILRuntime and xlua, they have to be operated through a wrap function call. Since HybridCLR is implemented in C++, it can directly access\nFor the memory data of the object, by calculating the offset of the field in the object in advance, directly ",(0,a.kt)("inlineCode",{parentName:"p"},"*(int32_t*)(obj + offset) = b;")," can complete this access operation."),(0,a.kt)("p",null,"Compared with other hot update schemes, the efficiency is improved by dozens of times."),(0,a.kt)("h3",{id:"directly-support-reference-and-pointer-operations-without-indirect-methods"},"Directly support reference and pointer operations without indirect methods"),(0,a.kt)("p",null,"Due to the specification restrictions of the CLI, references in C# can only be placed on the managed stack, but not on the interpreter stack (because it is heap memory). To handle something like ",(0,a.kt)("inlineCode",{parentName:"p"},"ref int a = ref b; a = 5;"),", you have to use very complicated\nThe trick maintains this reference indirectly. And HybridCLR uses c++ to realize, can save and operate these data directly."),(0,a.kt)("p",null,"Compared with other hot update solutions, the efficiency is greatly improved."),(0,a.kt)("h3",{id:"unified-metadata-more-efficient-object-creation-and-smaller-memory-footprint"},"Unified metadata, more efficient object creation, and smaller memory footprint"),(0,a.kt)("p",null,"Due to the unified metadata, you can directly call il2cpp::vm::Object::New to create objects, the efficiency is very close to the original, and the memory is exactly the same. In contrast, other hot update schemes use fake types,\nThe object is bloated, and the process of creating the object is more complicated."),(0,a.kt)("p",null,"Compared with other hot update schemes, the efficiency is greatly improved."),(0,a.kt)("h3",{id:"the-metadata-is-unified-the-function-calling-method-is-unified-and-there-is-no-additional-overhead-of-pinvoke-and-reservepinvoke"},"The metadata is unified, the function calling method is unified, and there is no additional overhead of PInvoke and ReservePInvoke"),(0,a.kt)("p",null,"HybridCLR can directly call the C++ function translated by the IL function without any intermediate links, while ILRuntime and xlua require various complex judgments and parameter conversions, as well as PInvoke and ReservePInvoke between C# and bring a lot of extra overhead."),(0,a.kt)("p",null,"The interaction between HyridCLR and il2cpp AOT is extremely lightweight and efficient. No more performance issues."),(0,a.kt)("h3",{id:"additionally-provide-a-large-number-of-instinct-functions"},"additionally provide a large number of instinct functions"),(0,a.kt)("p",null,"For common operations such as ",(0,a.kt)("inlineCode",{parentName:"p"},"new Vector{2,3,4}"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"new string()"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"Nullable<T>.Value"),", etc., we directly provide the corresponding instructions, and the running overhead is even lower than the implementation of AOT ."),(0,a.kt)("p",null,"Compared with other hot update schemes, the efficiency is improved by dozens of times."),(0,a.kt)("h3",{id:"strictly-follow-the-specification-and-do-not-introduce-additional-unnecessary-costs"},"Strictly follow the specification and do not introduce additional unnecessary costs"),(0,a.kt)("p",null,"Due to careful design and optimization, HybridCLR tries to avoid all kinds of unnecessary overhead. For example, the GC of the execution process is exactly the same as that of native il2cpp and mono."),(0,a.kt)("h3",{id:"other-instruction-optimization-techniques"},"Other instruction optimization techniques"),(0,a.kt)("p",null,"Other Optimization Techniques"),(0,a.kt)("h2",{id:"appendix-test-case-code"},"Appendix: Test case code"),(0,a.kt)("p",null,"The following test cases are provided by a third party. The use cases are unreasonable, but we don\u2019t want to be deliberately constructed and directly quote their use cases."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'private static void Test0()\n{\n   var go = new GameObject("t");\n   var transform = go. transform;\n\n   var cnt = PerformanceSetting. Count * 1000;\n   for (var i = 0; i < cnt; i++)\n   {\n     transform.position = transform.position;\n   }\n\n   Object. Destroy(go);\n}\n\nprivate static void Test1()\n{\n   var go = new GameObject("t");\n   var transform = go. transform;\n\n   var cnt = PerformanceSetting. Count * 100;\n   for (var i = 0; i < cnt; i++)\n   {\n     transform. Rotate(Vector3. up, 1);\n   }\n\n   Object. Destroy(go);\n}\n\nprivate static void Test2()\n{\n   var cnt = PerformanceSetting. Count * 1000;\n   for (var i = 0; i < cnt; i++)\n   {\n     var v = new Vector3(i, i, i);\n     var x = v.x;\n     var y = v.y;\n     var z = v.z;\n     var r = x + y * z;\n   }\n}\n\nprivate static void Test3()\n{\n   var cnt = PerformanceSetting. Count * 10;\n   for (var i = 0; i < cnt; i++)\n   {\n     var go = new GameObject("t");\n     Object. Destroy(go);\n   }\n}\n\nprivate static void Test4()\n{\n   var cnt = PerformanceSetting. Count * 10;\n   for (var i = 0; i < cnt; i++)\n   {\n     var go = new GameObject();\n     go.AddComponent<SkinnedMeshRenderer>();\n     var c = go. GetComponent<SkinnedMeshRenderer>();\n     c. receiveShadows = false;\n     Object. Destroy(go);\n   }\n}\n\nprivate static void Test5()\n{\n   var cnt = PerformanceSetting. Count * 1000;\n   for (var i = 0; i < cnt; i++)\n   {\n     var p = Input. mousePosition;\n   }\n}\n\nprivate static void Test6()\n{\n   var cnt = PerformanceSetting. Count * 1000;\n   for (var i = 0; i < cnt; i++)\n   {\n     var v = new Vector3(i, i, i);\n     Vector3. Normalize(v);\n   }\n}\n\nprivate static void Test7()\n{\n   var cnt = PerformanceSetting. Count * 100;\n   for (var i = 0; i < cnt; i++)\n   {\n     var q1 = Quaternion. Euler(i, i, i);\n     var q2 = Quaternion. Euler(i * 2, i * 2, i * 2);\n     Quaternion. Slerp(Quaternion. identity, q1, 0.5f);\n   }\n}\n\nprivate static void Test8()\n{\n   double total = 0;\n   var cnt = PerformanceSetting. Count * 10000;\n   for (var i = 0; i < cnt; i++)\n   {\n     total = total + i - (i / 2) * (i + 3) / (i + 5);\n   }\n}\n\nprivate static void Test9()\n{\n   var cnt = PerformanceSetting. Count * 1000;\n   for (var i = 0; i < cnt; i++)\n   {\n     var a = new Vector3(1, 2, 3);\n     var b = new Vector3(4, 5, 6);\n     var c = a + b;\n   }\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-lua"},'local function test0()\n     local cnt = CS.GameMain.Scripts.Performance.PerformanceSetting.Count * 1000\n\n     local go = CS.UnityEngine.GameObject("_")\n     local transform = go.transform\n\n     for i = 1, cnt do\n         transform.position = transform.position\n     end\n\n     CS.UnityEngine.GameObject.Destroy(go)\nend\n\nlocal function test1()\n     local cnt = CS.GameMain.Scripts.Performance.PerformanceSetting.Count * 100\n\n     local go = CS.UnityEngine.GameObject("_")\n     local transform = go.transform\n\n     for i = 1, cnt do\n         transform:Rotate(CS.UnityEngine.Vector3.up, 1)\n     end\n\n     CS.UnityEngine.GameObject.Destroy(go)\nend\n\nlocal function test2()\n     local cnt = CS.GameMain.Scripts.Performance.PerformanceSetting.Count * 1000\n\n     local go = CS.UnityEngine.GameObject("_")\n     local transform = go.transform\n\n     for i = 1, cnt do\n         local tmp = CS.UnityEngine.Vector3(i, i, i)\n         local x = tmp.x\n         local y = tmp.y\n         local z = tmp.z\n         local r = x + y * z\n     end\nend\n\nlocal function test3()\n     local cnt = CS.GameMain.Scripts.Performance.PerformanceSetting.Count * 10\n     for i = 1, cnt do\n         local tmp = CS.UnityEngine.GameObject("___")\n         CS.UnityEngine.GameObject.Destroy(tmp)\n     end\nend\n\nlocal function test4()\n     local cnt = CS.GameMain.Scripts.Performance.PerformanceSetting.Count * 10\n     for i = 1, cnt do\n         local tmp = CS.UnityEngine.GameObject("___")\n         tmp:AddComponent(typeof(CS.UnityEngine.SkinnedMeshRenderer))\n         local c = tmp:GetComponent(typeof(CS.UnityEngine.SkinnedMeshRenderer))\n         c.receiveShadows = false\n         CS.UnityEngine.GameObject.Destroy(tmp)\n     end\nend\n\nlocal function test5()\n     local cnt = CS.GameMain.Scripts.Performance.PerformanceSetting.Count * 1000\n     for i = 1, cnt do\n         local tmp = CS.UnityEngine.Input.mousePosition;\n     end\nend\n\nlocal function test6()\n     local cnt = CS.GameMain.Scripts.Performance.PerformanceSetting.Count * 1000\n     for i = 1, cnt do\n         local tmp = CS.UnityEngine.Vector3(i, i, i)\n         CS.UnityEngine.Vector3.Normalize(tmp)\n     end\nend\n\nlocal function test7()\n     local cnt = CS.GameMain.Scripts.Performance.PerformanceSetting.Count * 100\n     for i = 1, cnt do\n         local t1 = CS.UnityEngine.Quaternion.Euler(i, i, i)\n         local t2 = CS.UnityEngine.Quaternion.Euler(i * 2, i * 2, i * 2)\n         CS.UnityEngine.Quaternion.Slerp(t1, t2, CS.UnityEngine.Random.Range(0.1, 0.9))\n     end\nend\n\nlocal function test8()\n     local cnt = CS.GameMain.Scripts.Performance.PerformanceSetting.Count * 10000\n     local total = 0\n     for i = 1, cnt do\n         total = total + i - (i / 2) * (i + 3) / (i + 5)\n     end\nend\n\nlocal function test9()\n     local cnt = CS.GameMain.Scripts.Performance.PerformanceSetting.Count * 1000\n     for i = 1, cnt do\n         local tmp0 = CS.UnityEngine.Vector3(1, 2, 3)\n         local tmp1 = CS.UnityEngine.Vector3(4, 5, 6)\n         local tmp2 = tmp0 + tmp1\n     end\nend\n\n')))}p.isMDXComponent=!0},6247:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/benchmark_iphone11-a513bad3b6d902ce13ea6ac4f6b3422b.png"},8412:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/benchmark_numeric-a9f0937015c58ce1bea581eda81947d4.jpg"},8220:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/benchmark_xiaomi-df74589e8f81b84d845a437348153e7e.png"},5980:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/interpreter_optimization-11b95b174b8636d5aca626539a18ef81.jpg"}}]);