"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7287],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=s(n),h=a,m=c["".concat(p,".").concat(h)]||c[h]||d[h]||o;return n?r.createElement(m,i(i({ref:t},u),{},{components:n})):r.createElement(m,i({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=h;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[c]="string"==typeof e?e:a,i[1]=l;for(var s=2;s<o;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},70979:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var r=n(87462),a=(n(67294),n(3905));const o={},i="Work with lua/js/python",l={unversionedId:"basic/workwithscriptlanguage",id:"version-7.6.0/basic/workwithscriptlanguage",title:"Work with lua/js/python",description:"Some projects have already been launched, and most of their codes have been implemented in lua; or some new projects have been developed in lua, and they cannot completely switch to full C# development, but hope",source:"@site/i18n/en/docusaurus-plugin-content-docs/version-7.6.0/basic/workwithscriptlanguage.md",sourceDirName:"basic",slug:"/basic/workwithscriptlanguage",permalink:"/en/docs/7.6.0/basic/workwithscriptlanguage",draft:!1,tags:[],version:"7.6.0",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Migrate from netstandard to .Net Framework",permalink:"/en/docs/7.6.0/basic/migratefromnetstandard"},next:{title:"Code Architecture And Version",permalink:"/en/docs/7.6.0/basic/architecture"}},p={},s=[{value:"xlua",id:"xlua",level:2},{value:"tolua, slua, puerts",id:"tolua-slua-puerts",level:2},{value:"MonoPInvokeCallbackAttribute support",id:"monopinvokecallbackattribute-support",level:2},{value:"Reserved ReversePInvokeWrapper function",id:"reserved-reversepinvokewrapper-function",level:2},{value:"Limitations",id:"limitations",level:2}],u={toc:s},c="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"work-with-luajspython"},"Work with lua/js/python"),(0,a.kt)("p",null,"Some projects have already been launched, and most of their codes have been implemented in lua; or some new projects have been developed in lua, and they cannot completely switch to full C# development, but hope\nIt can be connected to HybridCLR at the same time, helping to gradually transition to all native C# hot updates. Since HybridCLR is a native C# hot update technology, native support works with these scripting languages."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"What you need to do is to generate the hot update wrapper files to the hot update module, and reserve enough ReversePInvoke functions in advance.")),(0,a.kt)("h2",{id:"xlua"},"xlua"),(0,a.kt)("p",null,"xlua has not considered modularization. The generated code is all in the global Assembly-CSharp, and even made into a partial class associated with the Runtime code. Therefore, you may need to make a small adjustment to the generated code of these hot update solutions to cooperate with the hot update. Work."),(0,a.kt)("p",null,"A group of friends have already produced the ",(0,a.kt)("inlineCode",{parentName:"p"},"HybridCLR+xlua")," project ",(0,a.kt)("a",{parentName:"p",href:"https://gitee.com/ldr123/HybridCLRXlua"},"HybridCLRXlua"),", which has run through and improved the workflow. Recommended reference."),(0,a.kt)("h2",{id:"tolua-slua-puerts"},"tolua, slua, puerts"),(0,a.kt)("p",null,"Make sure that enough ReversePInvokeWrapper functions are reserved and the generated wrapper code can be placed in the hot update module and registered correctly."),(0,a.kt)("h2",{id:"monopinvokecallbackattribute-support"},"MonoPInvokeCallbackAttribute support"),(0,a.kt)("p",null,"HybridCLR supports ",(0,a.kt)("inlineCode",{parentName:"p"},"[MonoPInvokeCallbackAttribute]")," exactly as natively. Since each function marked ",(0,a.kt)("inlineCode",{parentName:"p"},"[MonoPInvokeCallbackAttribute]")," must have a unique corresponding c++ function, and AOT restrictions make it impossible to add functions at runtime,\nTherefore, it is necessary to generate a ",(0,a.kt)("inlineCode",{parentName:"p"},"c++ wrapper function")," for each ",(0,a.kt)("inlineCode",{parentName:"p"},"[MonoPInvokeCallbackAttribute]")," function in advance for binding with it. These wrapper functions are in ",(0,a.kt)("inlineCode",{parentName:"p"},"hybridclr/generated/ReversePInvokeMethodStub_{abi}.cpp")," file."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"/en/docs/7.6.0/basic/com.code-philosophy.hybridclr"},"com.code-philosophy.hybridclr")," has provided scripts to help automatically generate these wrapper functions, just run the menu command ",(0,a.kt)("inlineCode",{parentName:"p"},"HybridCLR/Generate/ReversePInvokeWrapper"),"."),(0,a.kt)("h2",{id:"reserved-reversepinvokewrapper-function"},"Reserved ReversePInvokeWrapper function"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"HybridCLR/Generate/ReversePInvokeWrapper")," generates a wrapper function for each function with ",(0,a.kt)("inlineCode",{parentName:"p"},"[MonoPInvokeCallbackAttribute]")," by default.\nHowever, if you only generate the same number of wrapper functions as the current functions with the ",(0,a.kt)("inlineCode",{parentName:"p"},"[MonoPInvokeCallbackAttribute]")," feature, the new hot update function will be\nThe problem of insufficient wrapper functions will occur. The solution is to use ",(0,a.kt)("inlineCode",{parentName:"p"},"HybridCLR.ReversePInvokeWrapperGenerationAttribute")," for reserved operations."),(0,a.kt)("p",null,"Add a feature ",(0,a.kt)("inlineCode",{parentName:"p"},"[ReversePInvokeWrapperGeneration(int preserveCount)]")," to the function with ",(0,a.kt)("inlineCode",{parentName:"p"},"MonoPInvokeCallbackAttribute"),", then generate preserveCount wrapper functions for functions with ",(0,a.kt)("strong",{parentName:"p"},"this signature"),". If this attribute is not included, it will only be generated for this function\nA wrapper function. If the ",(0,a.kt)("inlineCode",{parentName:"p"},"[ReversePInvokeWrapperGeneration(xx)]")," attribute is added to multiple functions with the same signature, the total number of wrapper functions is ",(0,a.kt)("inlineCode",{parentName:"p"},"the sum of all preserveCount + the number of functions that do not contain the ReversePInvokeWrapperGenerationAttribute attribute"),"."),(0,a.kt)("p",null,"As shown below, there are 10 wrappers of type ",(0,a.kt)("inlineCode",{parentName:"p"},"LuaFunction"),", 101 wrappers of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Func<int, int, int>"),", and 1 wrapper of type ",(0,a.kt)("inlineCode",{parentName:"p"},"Func<int, int>"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"\n[UnmanagedFunctionPointer(CallingConvention.Cdecl)]\ndelegate int LuaFunction(IntPtr luaState);\n\npublic class MonoPInvokeWrapperPreserves\n{\n     [ReversePInvokeWrapperGeneration(10)]\n     [MonoPInvokeCallback(typeof(LuaFunction))]\n     public static int LuaCallback(IntPtr luaState)\n     {\n         return 0;\n     }\n\n     [ReversePInvokeWrapperGeneration(100)]\n     [MonoPInvokeCallback(typeof(Func<int, int, int>))]\n     public static int Sum(int a, int b)\n     {\n         return a + b;\n     }\n\n     [MonoPInvokeCallback(typeof(Func<int, int, int>))]\n     public static int Sum2(int a, int b)\n     {\n         return a + b;\n     }\n\n     [MonoPInvokeCallback(typeof(Func<int, int>))]\n     public static int Inc(int a)\n     {\n         return a + 1;\n     }\n}\n\n")),(0,a.kt)("h2",{id:"limitations"},"Limitations"),(0,a.kt)("p",null,"Currently, when calling MonoPInvokeCallback type functions, no marshal processing is performed on the parameters. Ordinary int and float types work fine, but parameters like string will crash if they are used directly because the native layer passes 'char*' and is not marshaled to string!"),(0,a.kt)("p",null,"If you encounter string type parameters, there are two solutions:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"You can put the callback function in AOT and call back the hot update function in AOT.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Change the parameter to IntPtr type, and then call Marshal.PtrToStringUTF8 to convert the original char* type data of IntPtr type into string. The sample code is as follows."))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"[MonoPInvokeCallback(typeof(Func<Intptr, int>))]\npublic static int Inc(IntPtr ptr)\n{\nstring s = Marshal.PtrToStringUTF8(ptr);\nreturn s.Length;\n}\n\n")),(0,a.kt)("p",null,"Other non-primitive type parameters that need Marshal can be processed in the same way."))}d.isMDXComponent=!0}}]);